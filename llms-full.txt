# tmgrammar-toolkit - Complete Codebase

A modern, type-safe toolkit for creating TextMate grammars with TypeScript.

Version: 0.0.1
Generated: 2025-07-06T20:47:26.975Z

This file contains the complete codebase for LLM analysis and understanding.

## Project Structure

```
tmgrammar-toolkit/
├── docs/                    # User documentation
├── src/                     # Source code
│   ├── cli/                # Command-line interface
│   ├── scopes/             # Type-safe scope system
│   ├── helpers/            # Regex utilities
│   ├── terminals/          # Pre-built patterns
│   ├── testing/            # Testing framework
│   └── validation/         # Grammar validation
├── examples/               # Example implementations
└── tests/                  # Test suite
```


## Essential Files

### README.md

```
# TextMate Toolkit

A modern, type-safe toolkit for creating TextMate grammars with TypeScript. Build syntax highlighting grammars with confidence using comprehensive validation, testing, and development tools.

<div align="center">

[![npm version](https://img.shields.io/npm/v/tmgrammar-toolkit.svg)](https://www.npmjs.com/package/tmgrammar-toolkit)
[![TypeScript](https://img.shields.io/badge/TypeScript-5.0+-blue.svg)](https://www.typescriptlang.org/)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

</div>

## Why TextMate Toolkit?

Creating TextMate grammars manually means wrestling with massive JSON files, regex patterns, and scope naming without any safety net. This toolkit transforms that experience:

**❌ Before: Manual Grammar Development**
```json
{
  "patterns": [
    {
      "match": "\\b(if|else|while)\\b",
      "name": "keyword.control.mylang"
    }
  ]
}
```

**✅ After: Type-Safe Grammar Development**
```typescript
import { createGrammar, scopes, regex } from 'tmgrammar-toolkit';

const keywordRule = {
  key: 'keywords',
  match: regex.keywords(['if', 'else', 'while']),
  scope: scopes.keyword.control('mylang')
};

export const grammar = createGrammar('MyLang', 'source.mylang', ['mylang'], [keywordRule]);
```

## ✨ Features

- 🎯 **Type-Safe Development** - Full TypeScript support with comprehensive type definitions
- 🧪 **Integrated Testing** - Programmatic and declarative testing with snapshot support
- ✅ **Built-in Validation** - Catch regex errors and scope naming issues before deployment
- 🔄 **Multiple Output Formats** - Generate JSON or Plist grammar files
- 🛠️ **Powerful CLI** - Unified command-line interface for all operations
- 📚 **Rich Ecosystem** - Pre-built patterns, helpers, and comprehensive documentation
- 🚀 **Performance Optimized** - Smart repository management and efficient pattern generation

## 🚀 Quick Start

### Installation

```bash
# Using Bun (recommended)
bun add tmgrammar-toolkit

# Using npm
npm install tmgrammar-toolkit

# Using yarn
yarn add tmgrammar-toolkit
```

### Your First Grammar (5 minutes)

Create a simple grammar for a language called "MyLang":

```typescript
// mylang-grammar.ts
import { createGrammar, scopes, regex } from 'tmgrammar-toolkit';
import { COMMENT, NUM } from 'tmgrammar-toolkit/terminals';

const keywordRule = {
  key: 'keywords',
  match: regex.keywords(['if', 'else', 'while', 'function']),
  scope: scopes.keyword.control('mylang')
};

const commentRule = {
  key: 'comment',
  match: regex.concat('//', '.*$'),
  scope: scopes.comment.line['double-slash']('mylang')
};

const numberRule = {
  key: 'number',
  match: NUM.DEC,
  scope: scopes.constant.numeric('mylang')
};

export const myLangGrammar = createGrammar(
  'MyLang',
  'source.mylang',
  ['mylang'],
  [keywordRule, commentRule, numberRule]
);
```

Generate the grammar file:

```bash
# Using CLI with Bun (works directly with TypeScript!)
bunx tmt emit mylang-grammar.ts -o mylang.tmLanguage.json

# Or with npm
npx tmt emit mylang-grammar.ts -o mylang.tmLanguage.json

# Or programmatically
```

```typescript
import { emitJSON } from 'tmgrammar-toolkit';
import { myLangGrammar } from './mylang-grammar.js';

const grammarJson = await emitJSON(myLangGrammar);
console.log(grammarJson);
```

## 🏗️ Architecture

The toolkit is organized into focused modules that work together seamlessly:

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   TypeScript    │───▶│   Validation    │───▶│     Testing     │
│    Grammar      │    │   & Helpers     │    │   & Debugging   │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│  Factory & API  │───▶│  Type-Safe API  │───▶│  TextMate JSON  │
│   Functions     │    │     Scopes      │    │   Grammar       │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

**Core Modules:**
- **🏭 Factory** - Clean APIs for creating grammars and rules (`factory.ts`)
- **🎯 Scopes** - Type-safe scope management with autocomplete (`scopes/`)
- **🧩 Terminals** - Pre-built patterns for common language constructs (`terminals/`)
- **🛠️ Helpers** - Regex construction utilities (`helpers/`)
- **✅ Validation** - Pattern and grammar validation (`validation/`)
- **🧪 Testing** - Comprehensive testing framework (`testing/`)
- **📤 Emission** - Multi-format grammar generation (`emit.ts`)

## 💡 Key Concepts

### Type-Safe Rules

Everything in a TextMate grammar is a **Rule**. We support three types with full TypeScript safety:

```typescript
// Match Rule - for simple patterns
const keywordRule: MatchRule = {
  key: 'keywords',
  match: regex.keywords(['if', 'else']),
  scope: scopes.keyword.control('mylang')
};

// Begin/End Rule - for multi-line constructs
const stringRule: BeginEndRule = {
  key: 'string',
  begin: /"/,
  end: /"/,
  scope: scopes.string.quoted.double('mylang'),
  patterns: [escapeRule]
};

// Include Rule - for pattern composition
const expressionRule: IncludeRule = {
  key: 'expression',
  patterns: [numberRule, stringRule, identifierRule]
};
```

### Intelligent Repository Management

No more manual repository management! The toolkit automatically:
- ✅ Builds repository from rule keys
- ✅ Detects duplicate keys and circular references
- ✅ Optimizes pattern organization
- ✅ Generates clean, efficient JSON

### Comprehensive Testing

Write tests that actually verify your grammar works:

```typescript
import { createTesterFromContent } from 'tmgrammar-toolkit/testing';

const tester = createTesterFromContent(myGrammar, 'source.mylang');
const tokens = await tester.tokenize('if (condition) { /* comment */ }');

// Verify specific token scopes
tester.expectTokenScope(tokens, 'if', 'keyword.control.mylang');
tester.expectTokenScope(tokens, '/*', 'comment.block.mylang');
```

## 🛠️ CLI Commands

The `tmt` command provides unified access to all toolkit functionality. **Works seamlessly with Bun for direct TypeScript execution without build steps!**

### Grammar Generation

```bash
# Generate JSON (default)
tmt emit my-grammar.ts

# Generate Plist format
tmt emit my-grammar.ts --plist

# Generate YAML format
tmt emit my-grammar.ts --yaml

# Generate all formats
tmt emit my-grammar.ts --all

# Emit specific export
tmt emit my-grammar.ts myGrammarExport
```

### Testing & Validation

```bash
# Run declarative tests
tmt test 'tests/**/*.test.mylang' -g grammar.json

# Generate/update snapshots
tmt snap 'tests/**/*.mylang' --update

# Validate grammar files
tmt validate grammar.json
tmt validate my-grammar.ts
```

## 📚 Rich Pattern Library

Pre-built patterns for common language constructs:

```typescript
import { COMMENT, NUM, ID, OP, STRING } from 'tmgrammar-toolkit/terminals';

// Comments
COMMENT.SLASHES     // "//"
COMMENT.HASH        // "#"
COMMENT.BLOCK.START // "/*"

// Numbers
NUM.DEC             // Decimal: 123, 123.45
NUM.HEX             // Hex: 0xFF, 0xABCD
NUM.BIN             // Binary: 0b1010
NUM.OCT             // Octal: 0o777

// Identifiers
ID                  // Standard: [a-zA-Z_][a-zA-Z0-9_]*
CAMEL_CASE_ID       // camelCase
SNAKE_CASE_ID       // snake_case
PASCAL_CASE_ID      // PascalCase

// Operators
OP.ASSIGNMENT       // =, +=, -=, *=, /=
OP.COMPARISON       // ==, !=, <, >, <=, >=
OP.ARITHMETIC       // +, -, *, /, %
OP.LOGICAL          // &&, ||, !
```

## 🎯 Type-Safe Scope System

The toolkit features a revolutionary scope management system that eliminates string-based errors and provides excellent developer experience:

### Basic Scopes

```typescript
import { scopes } from 'tmgrammar-toolkit';

// Type-safe scope access with full autocomplete
scopes.keyword.control.conditional       // "keyword.control.conditional"
scopes.string.quoted.double             // "string.quoted.double"
scopes.entity.name.function             // "entity.name.function"

// Automatic string conversion in templates
const rule = `${scopes.comment.line.double_slash}`;  // "comment.line.double-slash"

// Call with language suffix
scopes.keyword.control.conditional('js'); // "keyword.control.conditional.js"
```

### Language-Specific Scopes

```typescript
import { scopesFor } from 'tmgrammar-toolkit';

// Create language-bound scopes
const jsScopes = scopesFor('js');
jsScopes.keyword.control.conditional;     // "keyword.control.conditional.js"
jsScopes.string.quoted.double;           // "string.quoted.double.js"

// Still callable for additional suffixes
jsScopes.keyword.control.conditional('async'); // "keyword.control.conditional.js.async"
```

### Extended Custom Scopes

```typescript
// Advanced: Custom scopes with extensions
const rclScopes = scopesFor({ 
  suffix: 'rcl', 
  allowScopeExtension: true 
}, {
  meta: {
    section: {
      agent: {
        definition: 'Agent definition blocks',
        name: 'Agent name identifiers'
      },
      message: {
        definition: 'Message definition blocks',
        shortcut: 'Message shortcut syntax'
      }
    }
  },
  punctuation: {
    definition: {
      flow: {
        arrow: 'Flow control arrows (->)'
      }
    }
  }
});

// Use both predefined and custom scopes
rclScopes.keyword.control.conditional;           // "keyword.control.conditional.rcl"
rclScopes.meta.section.agent.definition;        // "meta.section.agent.definition.rcl"
rclScopes.punctuation.definition.flow.arrow;    // "punctuation.definition.flow.arrow.rcl"
```

### Extension Modes

Control how custom scopes are merged with three modes:

```typescript
// No extensions - only language suffix
const basicScopes = scopesFor('lang');

// Extensions everywhere
const fullExtensions = scopesFor({ 
  suffix: 'lang', 
  allowScopeExtension: true 
}, customScopes);

// Extensions only on terminal/leaf scopes
const leafExtensions = scopesFor({ 
  suffix: 'lang', 
  allowScopeExtension: "on-leafs" 
}, customScopes);
```

### Multiple Naming Conventions

Access scopes using your preferred style:

```typescript
// All equivalent - use your preferred convention:
scopes.comment.line['double-slash']    // Kebab-case (TextMate standard)
scopes.comment.line.doubleSlash        // camelCase
scopes.comment.line.double_slash       // snake_case

// All produce: "comment.line.double-slash"
```

## 🎯 Real-World Examples

The toolkit includes complete, production-ready grammar implementations:

### Simple Language Example
```typescript
// Using language-specific scopes for consistency
const simpleScopes = scopesFor('simple');

const simpleGrammar = createGrammar('Simple', 'source.simple', ['simple'], [
  { key: 'keywords', match: regex.keywords(['if', 'else']), scope: simpleScopes.keyword.control },
  { key: 'strings', begin: /"/, end: /"/, scope: simpleScopes.string.quoted.double },
  { key: 'numbers', match: NUM.DEC, scope: simpleScopes.constant.numeric }
]);
```

### Advanced: RCL Language with Custom Scopes
```typescript
// Custom domain-specific scopes for RCL language
const rclScopes = scopesFor({ suffix: 'rcl', allowScopeExtension: true }, {
  meta: {
    section: {
      agent: { definition: null, name: null },
      message: { definition: null, shortcut: null },
      flow: { rule: null, condition: null }
    },
    embedded: {
      expression: { single: null, block: null }
    }
  },
  punctuation: {
    definition: {
      flow: { arrow: null },
      embedded: { marker: null }
    }
  }
});

const rclGrammar = createGrammar('RCL', 'source.rcl', ['rcl'], [
  {
    key: 'agent-section',
    begin: /^(\s*)(agent)(\s*)(:)/,
    beginCaptures: {
      2: { name: rclScopes.keyword.declaration },
      4: { name: rclScopes.punctuation.separator }
    },
    name: rclScopes.meta.section.agent.definition,
    patterns: [
      {
        name: rclScopes.meta.section.agent.name,
        match: /[A-Z][a-zA-Z0-9_\s-]*/
      }
    ]
  },
  {
    key: 'flow-arrow',
    name: rclScopes.punctuation.definition.flow.arrow,
    match: /->/
  },
  {
    key: 'embedded-js',
    name: rclScopes.meta.embedded.expression.single,
    begin: /\$js>/,
    beginCaptures: {
      0: { name: rclScopes.punctuation.definition.embedded.marker }
    },
    end: /$/
  }
]);
```

Find complete examples in the [`examples/`](examples/) directory.

## 📖 Documentation

Comprehensive documentation covering all aspects of the toolkit:

- **[📋 Getting Started Guide](docs/getting-started.md)** - Build your first grammar in 15 minutes
- **[🏗️ Architecture Overview](docs/modules-overview.md)** - Deep dive into toolkit design
- **[📚 API Reference](docs/api-reference.md)** - Complete function and type reference  
- **[🎯 Scopes Guide](docs/using-scopes.md)** - Master type-safe scope management
- **[🔧 Troubleshooting](docs/troubleshooting.md)** - Solutions for common issues
- **[📝 TextMate Scopes Reference](docs/textmate-scopes.md)** - Complete scope naming guide

**[📁 View All Documentation →](docs/)**

## 🧪 Testing Your Grammars

### Programmatic Testing

```typescript
import { createTesterFromContent } from 'tmgrammar-toolkit/testing';

const tester = createTesterFromContent(grammar, 'source.mylang');

// Test tokenization
const tokens = await tester.tokenize('function hello() { return "world"; }');

// Assertions
tester.expectTokenScope(tokens, 'function', 'keyword.declaration.mylang');
tester.expectTokenScope(tokens, 'hello', 'entity.name.function.mylang');
tester.expectTokenScope(tokens, '"world"', 'string.quoted.double.mylang');
```

### Declarative Testing

Create test files with embedded scope assertions:

```
// test.mylang
function hello() {
// <- keyword.declaration.mylang
//       ^ entity.name.function.mylang
  return "world";
  //     ^ string.quoted.double.mylang
}
```

Run tests:
```bash
npx tmt test 'tests/**/*.test.mylang' -g mylang.tmLanguage.json
```

## ⚡ Performance Features

- **Smart Pattern Optimization** - Automatic pattern combining and ordering
- **Efficient Repository Generation** - Minimal JSON output with optimal structure  
- **Regex Validation** - Catch expensive patterns before they cause performance issues
- **Atomic Grouping Support** - Use non-backtracking patterns for better performance
- **Memory-Efficient Processing** - Stream-based grammar generation for large grammars

## 🎨 Editor Integration

Works seamlessly with all editors supporting TextMate grammars:

- **VS Code** - First-class support with extension development tools
- **Sublime Text** - Direct .tmLanguage file support
- **Atom** - Grammar package integration
- **Vim/Neovim** - Via TreeSitter and syntax plugins
- **Emacs** - Multiple TextMate grammar packages
- **Any Editor** - Standard TextMate grammar format

## 🚀 Migration from Manual Grammars

Already have a TextMate grammar? The toolkit makes migration straightforward:

1.  **Convert patterns** using our regex helpers
2.  **Replace scope strings** with type-safe scope API
3.  **Add validation** to catch existing issues
4.  **Write tests** to prevent regressions
5.  **Optimize patterns** using our performance tools

## 🗺️ Roadmap

The future of `tmgrammar-toolkit` is focused on enhancing the developer experience, expanding authoring capabilities, and integrating with the broader ecosystem. Here's a look at what's planned for upcoming versions.

### Version 2.0: Polishing the Core Experience

The primary goal of v2.0 is to solidify the existing feature set and improve the overall authoring workflow.

- **CLI Enhancements**: A refactored and more maintainable CLI architecture. Full implementation of all documented flags, including `--plist` and other potential emission formats.
- **Advanced Authoring**: A fluent API for building grammars and improved repository management.
- **Improved Testing**: Richer test reporting and performance/complexity analysis for grammars.
- **Test Runner Integration**: Adapters for seamless integration with Jest and Vitest.

### Version 3.0: Advanced Tooling and Ecosystem Integration

Version 3.0 will introduce advanced tools to support large-scale grammar development and deeper integration with the TextMate ecosystem.

- **Developer Experience**: A development server with hot-reloading, project scaffolding, and a dedicated VS Code extension.
- **Advanced Composition**: Support for grammar inheritance and composition to manage complex language definitions.
- **Enhanced Quality Assurance**: Test coverage analysis and theme compatibility checks.
- **Ecosystem Integration**: Tools for converting, optimizing, and sharing grammars.

For a detailed breakdown of our future plans, see the [v2.0](roadmap/v2.0.md) and [v3.0](roadmap/v3.0.md) roadmaps.

## 🤝 Contributing

We welcome contributions! Whether you're:

- 🐛 **Reporting bugs** - Help us improve stability
- 💡 **Suggesting features** - Share ideas for new functionality  
- 📝 **Improving docs** - Make the toolkit more accessible
- 🧩 **Adding patterns** - Contribute to the terminal library
- 🔧 **Fixing issues** - Submit pull requests

See our [contributing guidelines](CONTRIBUTING.md) for details.

## 📦 Credits and Related Projects

This toolkit builds upon and integrates with excellent open-source projects:

- **[vscode-tmgrammar-test](https://github.com/PanAeon/vscode-tmgrammar-test)** - Grammar testing framework
- **[vscode-textmate](https://github.com/Microsoft/vscode-textmate)** - TextMate grammar parsing
- **[oniguruma](https://github.com/kkos/oniguruma)** - Regular expression engine
- **[VS Code Language Extensions](https://code.visualstudio.com/api/language-extensions/overview)** - Editor integration

We also vendor the TMLanguage JSON schema, originally created by Martin Ring. You can find the original project [here](https://github.com/martinring/tmlanguage).

We are grateful for the work of everyone that contributed to the projects above!

## 📄 License

MIT License - see [LICENSE](LICENSE) for details.


## 🌟 Why Choose TextMate Toolkit?

**For Individual Developers:**
- ⚡ **Faster Development** - Type safety and helpers accelerate grammar creation
- 🐛 **Fewer Bugs** - Validation catches issues early in development
- 📚 **Better Documentation** - Comprehensive guides and examples
- 🔧 **Easier Debugging** - Testing tools help isolate and fix issues

**For Teams:**
- 🤝 **Consistent Standards** - Shared patterns and conventions
- 👥 **Better Collaboration** - Code review-friendly TypeScript
- 📈 **Scalable Approach** - Reusable components and patterns
- ✅ **Quality Assurance** - Automated testing and validation

**For the Ecosystem:**
- 🌍 **Open Source** - MIT license encourages adoption and contribution
- 🔄 **Interoperable** - Standard TextMate format works everywhere
- 📊 **Well-Tested** - Comprehensive test suite ensures reliability
- 🚀 **Modern Tooling** - Built with current TypeScript and testing best practices

---

<div align="center">

**Ready to build better syntax highlighting?**

[📋 Get Started](docs/getting-started.md) • [📚 Read the Docs](docs/) • [🎨 See Examples](examples/)

</div> 
```

### package.json

```
{
  "name": "tmgrammar-toolkit",
  "version": "0.0.1",
  "description": "A modern, type-safe toolkit for creating TextMate grammars with TypeScript.",
  "author": {
    "name": "Sergio Vallory",
    "url": "https://github.com/svallory"
  },
  "license": "MIT",
  "files": [
    "bin",
    "lib",
    "vendor",
    "README.md",
    "LICENSE"
  ],
  "keywords": [
    "developer-tools",
    "grammar",
    "highlighting",
    "syntax-highlighting",
    "textmate",
    "tmgrammar",
    "tmlanguage",
    "typescript",
    "vscode"
  ],
  "scripts": {
    "build": "nr clean && tsc -p tsconfig.build.json",
    "clean": "rm -rf dist",
    "dev": "tsc -p tsconfig.build.json --watch",
    "format": "prettier --write .",
    "lint": "eslint src/**/*.ts",
    "lint:fix": "eslint src/**/*.ts --fix",
    "prepare": "bun run build",
    "test": "bun test",
    "test:regex": "bun test ./src/helpers/regex.test.ts",
    "test:watch": "bun test --watch",
    "docs:build": "node scripts/build-docs.js && node scripts/generate-llms-txt.js",
    "docs:serve": "bundle exec jekyll serve --watch --incremental",
    "validate": "bunx tmt validate"
  },
  "bin": {
    "tmt": "bin/tmt"
  },
  "main": "./lib/index.js",
  "types": "./lib/index.d.ts",
  "exports": {
    ".": "./lib/index.js",
    "./package.json": "./package.json",
    "./*": "./lib/*.js"
  },
  "imports": {
    "#src": "./src/index.ts",
    "#src/*": [
      "./src/*/index.ts",
      "./src/*.ts"
    ],
    "#tests/*": "./tests/*.ts"
  },
  "dependencies": {
    "onigasm": "^2.2.5",
    "vscode-tmgrammar-test": "^0.1.3",
    "js-yaml": "^4.1.0",
    "commander": "^11.0.0",
    "tsx": "^4.0.0"
  },
  "devDependencies": {
    "@types/js-yaml": "^4.0.5",
    "@types/node": "^20.0.0",
    "@types/plist": "^3.0.5",
    "expect-type": "^1.2.2",
    "tmlanguage-generator": "^0.6.1",
    "type-fest": "^4.41.0",
    "typescript": "^5.0.0",
    "vitest": "^1.0.0",
    "vscode-textmate": "^9.0.0"
  }
}

```

### src/types.ts

```
/**
 * Core types for TextMate grammar definitions
 * Direct mapping to tmlanguage schema with strong type safety
 */

import type { Scope } from './scopes/types.js';

/**
 * The URL to the TMLanguage JSON schema, used for validation and tooling.
 *
 * We vendor this schema from `martinring/tmlanguage` to ensure stability and
 * avoid external dependencies at runtime. The original schema can be found at:
 * https://github.com/martinring/tmlanguage
 *
 * @credits martinring
 */
export const schema = "https://raw.githubusercontent.com/svallory/tmgrammar-toolkit/main/vendor/schemas/tmlanguage.json";

/**
 * Special scope that indicates a larger construct that doesn't get a single color.
 * Expanded to meta.<key>.<grammar name> during emit.
 */
export const meta: unique symbol = Symbol("meta");

/**
 * Valid scope value - can be a string, result from scopes API, or meta symbol
 */
export type ScopeValue = string | Scope<string, string, string> | typeof meta;


/**
 * Base interface for all rules that must have a unique key for repository management
 */
export interface RuleKey {
  /** Rule's unique key through which identifies the rule in the repository. */
  key: string;
}

/**
 * A type representing a regular expression, either as a string or a RegExp object.
 */
export type RegexValue = string | RegExp;
export type RegexValueList = Array<RegexValue | RegexValue[]>;

/**
 * Scope assignment for a rule - can be a string, our scopes API, or meta symbol
 */
export interface RuleScope {
  /**
   * The TextMate scope that gets assigned to a match and colored by a theme.
   * Can be a string, result from scopes API, or meta symbol.
   * See https://macromates.com/manual/en/language_grammars#naming_conventions
   */
  scope: ScopeValue;
}

/**
 * Rules that can contain nested patterns
 */
export interface RulePatterns {
  patterns: Pattern[];
}

/**
 * Pattern can be a full rule definition, a rule reference, or a basic include pattern
 */
export type Pattern = Rule | RuleReference | BasicIncludePattern;

/**
 * Reference to a rule that will be converted to an include statement
 * Must be a rule with a key that exists in the repository
 */
export type RuleReference = MatchRule | BeginEndRule | IncludeRule;

/**
 * Capture group definitions for regex matches
 */
export type Captures = Record<
  string,
  RuleScope | RulePatterns
>;

/**
 * Union type for all possible rule types
 */
export type Rule =
  | MatchRule
  | BeginEndRule
  | IncludeRule
  | BasicIncludePattern;

/**
 * Simple pattern matching rule
 */
export interface MatchRule extends RuleScope, RuleKey {
  match: RegexValue;
  captures?: Captures;
}

/**
 * Begin/end block rule for multi-line constructs
 */
export interface BeginEndRule
  extends RuleKey,
    RuleScope,
    Partial<RulePatterns> {
  begin: RegexValue;
  end: RegexValue;
  beginCaptures?: Captures;
  endCaptures?: Captures;
  /** Optional content scope for text between begin/end */
  contentName?: string;
  /** Optional while pattern as alternative to end */
  while?: RegexValue;
}

/**
 * Include rule that references other patterns
 */
export interface IncludeRule extends RuleKey, RulePatterns {}

/**
 * For simple include directives like { include: '#repositoryKey' }
 */
export interface BasicIncludePattern {
  include: string;
}

/**
 * Type for a repository object
 */
export type Repository = Record<string, Rule>;

/**
 * Complete grammar definition
 */
export interface GrammarInput {
  name: string;
  scopeName: string;
  fileTypes: string[];
  patterns: Rule[];
  repositoryItems?: Rule[];
  firstLineMatch?: RegexValue;
  foldingStartMarker?: RegexValue;
  foldingStopMarker?: RegexValue;
  uuid?: string;
}

/**
 * Complete grammar definition with validation results
 */
export interface Grammar {
  isValid: boolean;
  grammar: GrammarInput;
  repository: Record<string, Rule>;
  errors: GrammarError[];
}

/**
 * Options for emitting grammars
 */
export interface EmitOptions {
  errorSourceFilePath?: string;
}

/**
 * Location information for errors
 */
export interface ErrorLocation {
  /** Source file path */
  filePath?: string;
  /** Rule key or identifier where error occurred */
  ruleKey?: string;
  /** Property name where error occurred */
  property?: string;
  /** Line number in source file */
  line?: number;
  /** Column number in source file */
  column?: number;
  /** Context path (e.g., "patterns[0].match") */
  contextPath?: string;
}

/**
 * Severity levels for errors and warnings
 */
export enum ErrorSeverity {
  ERROR = 'error',
  WARNING = 'warning',
  INFO = 'info'
}

/**
 * Error categories for better classification
 */
export enum ErrorCategory {
  VALIDATION = 'validation',
  REGEX = 'regex',
  SCOPE = 'scope',
  REFERENCE = 'reference',
  SYNTAX = 'syntax',
  SEMANTIC = 'semantic'
}

/**
 * Base grammar error interface
 */
export interface GrammarError {
  /** Error message */
  message: string;
  /** Error severity level */
  severity: ErrorSeverity;
  /** Error category */
  category: ErrorCategory;
  /** Location information */
  location?: ErrorLocation;
  /** Error code for programmatic handling */
  code?: string;
  /** Additional context or suggestions */
  context?: string;
  /** Nested errors (for complex validation) */
  innerErrors?: GrammarError[];
}

/**
 * Grammar validation error class
 */
export class GrammarValidationError extends Error implements GrammarError {
  public readonly severity: ErrorSeverity;
  public readonly category: ErrorCategory;
  public readonly location?: ErrorLocation;
  public readonly code?: string;
  public readonly context?: string;
  public readonly innerErrors?: GrammarError[];

  constructor(
    message: string,
    options: {
      severity?: ErrorSeverity;
      category?: ErrorCategory;
      location?: ErrorLocation;
      code?: string;
      context?: string;
      innerErrors?: GrammarError[];
    } = {}
  ) {
    super(message);
    this.name = 'GrammarValidationError';
    this.severity = options.severity ?? ErrorSeverity.ERROR;
    this.category = options.category ?? ErrorCategory.VALIDATION;
    this.location = options.location;
    this.code = options.code;
    this.context = options.context;
    this.innerErrors = options.innerErrors;
  }

  /**
   * Create a formatted error message with location information
   */
  public getFormattedMessage(): string {
    let formatted = this.message;
    
    if (this.location) {
      const parts: string[] = [];
      
      if (this.location.filePath) {
        parts.push(`File: ${this.location.filePath}`);
      }
      
      if (this.location.line !== undefined) {
        const lineCol = this.location.column !== undefined 
          ? `${this.location.line}:${this.location.column}`
          : `${this.location.line}`;
        parts.push(`Line: ${lineCol}`);
      }
      
      if (this.location.ruleKey) {
        parts.push(`Rule: ${this.location.ruleKey}`);
      }
      
      if (this.location.contextPath) {
        parts.push(`Context: ${this.location.contextPath}`);
      }
      
      if (parts.length > 0) {
        formatted += ` (${parts.join(', ')})`;
      }
    }
    
    if (this.context) {
      formatted += `\n${this.context}`;
    }
    
    return formatted;
  }

  /**
   * Convert to a plain object for serialization
   */
  public toJSON(): GrammarError {
    return {
      message: this.message,
      severity: this.severity,
      category: this.category,
      location: this.location,
      code: this.code,
      context: this.context,
      innerErrors: this.innerErrors
    };
  }
}

/**
 * Helper function to create grammar errors with location context
 */
export function createGrammarError(
  message: string,
  options: {
    severity?: ErrorSeverity;
    category?: ErrorCategory;
    location?: Partial<ErrorLocation>;
    code?: string;
    context?: string;
    innerErrors?: GrammarError[];
  } = {}
): GrammarValidationError {
  return new GrammarValidationError(message, {
    ...options,
    location: options.location ? {
      filePath: options.location.filePath,
      ruleKey: options.location.ruleKey,
      property: options.location.property,
      line: options.location.line,
      column: options.location.column,
      contextPath: options.location.contextPath
    } : undefined
  });
}

/**
 * Output grammar that matches the tmlanguage schema root definition
 */
export interface TMLanguageGrammar {
  name?: string;
  scopeName: string;
  fileTypes?: string[];
  patterns: any[];
  repository?: Record<string, any>;
  firstLineMatch?: string;
  foldingStartMarker?: string;
  foldingStopMarker?: string;
  uuid?: string;
}

 
```

### src/factory.ts

```
/**
 * Factory functions for creating TextMate grammar rules
 * Clean, type-safe constructors for all rule types
 */

import type {
  GrammarInput,
  Rule,
  RegexValue,
  Grammar
} from './types.js';
import { processGrammar } from './validation/grammar.js';
import type { GrammarResult } from './result.js';

/**
 * Creates a complete TextMate grammar with automatic repository management.
 * 
 * Rules with a `key` property are automatically collected and placed into the 
 * grammar's repository during emission. Use `repositoryItems` for explicit control
 * over which rules are included in the repository.
 * 
 * @param name - Human-readable name for the grammar (e.g., "TypeScript")
 * @param scopeName - Root scope identifier (e.g., "source.typescript")
 * @param fileTypes - File extensions this grammar applies to (e.g., ["ts", "tsx"])
 * @param patterns - Top-level grammar patterns/rules
 * @param options - Optional grammar configuration
 * @param options.variables - Variable definitions for pattern reuse
 * @param options.firstLineMatch - Regex to match first line for grammar detection
 * @param options.foldingStartMarker - Regex marking start of foldable sections
 * @param options.foldingStopMarker - Regex marking end of foldable sections
 * @returns Complete grammar ready for emission to TextMate format
 * 
 * @example
 * ```typescript
 * const grammar = createGrammar(
 *   'My Language',
 *   'source.mylang',
 *   ['mylang', 'ml'],
 *   [keywordRule, stringRule, commentRule],
 *   {
 *     firstLineMatch: /^#!/
 *   }
 * );
 * ```
 */
/**
 * Creates and processes a complete TextMate grammar with automatic repository management.
 * 
 * Returns a Result that forces you to check for validation errors before using the grammar.
 * 
 * @param name - Human-readable name for the grammar
 * @param scopeName - Root scope identifier (e.g., "source.typescript")
 * @param fileTypes - File extensions this grammar applies to
 * @param patterns - Top-level grammar patterns/rules
 * @param options - Optional configuration
 * @returns Result containing processed Grammar or validation errors
 */
export function createGrammar(
  name: string,
  scopeName: string,
  fileTypes: string[],
  patterns: Rule[],
  options?: {
    firstLineMatch?: RegexValue;
    foldingStartMarker?: RegexValue;
    foldingStopMarker?: RegexValue;
    uuid?: string;
    filePath?: string;
  }
): GrammarResult<Grammar> {
  const grammarInput: GrammarInput = {
    name,
    scopeName,
    fileTypes,
    patterns,
    firstLineMatch: options?.firstLineMatch,
    foldingStartMarker: options?.foldingStartMarker,
    foldingStopMarker: options?.foldingStopMarker,
    uuid: options?.uuid,
  };
  
  return processGrammar(grammarInput, options?.filePath);
} 
```

### src/emit.ts

```
/**
 * Grammar processing and emit functions
 * Handles validation, repository management, and output generation
 */

import type {
  BeginEndRule,
  GrammarInput,
  MatchRule,
  Rule,
  IncludeRule,
  Grammar,
  EmitOptions,
  TMLanguageGrammar,
  Pattern,
} from './types.js';
import { meta } from './types.js';
import { ErrorCodes, errorFactory } from './errors.js';
import { ok, error, type StringResult } from './result.js';

import { readFile } from 'node:fs/promises';
import { loadWASM, OnigRegExp } from 'onigasm';
import { dirname, resolve } from 'node:path';
import * as plist from 'plist';
import * as yaml from 'js-yaml';

let initialized = false;

/**
 * Initializes the Oniguruma WASM engine for regex validation.
 * This uses the same regex engine as VS Code for accurate pattern validation.
 * 
 * @internal
 */
async function initialize(): Promise<void> {
  if (!initialized) {
    const onigasmPath = require.resolve('onigasm');
    const wasmPath = resolve(dirname(onigasmPath), 'onigasm.wasm');
    const wasm = await readFile(wasmPath);
    await loadWASM(wasm.buffer as ArrayBuffer);
    initialized = true;
  }
}

/**
 * Converts a grammar to JSON format suitable for TextMate editors.
 * 
 * Performs automatic repository management, regex validation using Oniguruma engine,
 * and scope processing. The output JSON is formatted and ready for VS Code or other
 * TextMate-compatible editors.
 * 
 * @param grammar - The grammar to convert
 * @param options - Emission options for error reporting and validation control
 * @param options.errorSourceFilePath - Source file path for better error messages
 * @param options.validate - Whether to validate regex patterns (default: true)
 * @param options.formatOutput - Whether to format the JSON output (default: true)
 * @returns Promise resolving to formatted JSON string
 * 
 * @example
 * ```typescript
 * const grammarJson = await emitJSON(myGrammar, {
 *   errorSourceFilePath: './my-grammar.ts',
 *   validate: true
 * });
 * await writeFile('my-grammar.tmLanguage.json', grammarJson);
 * ```
 */
export async function emitJSON(processedGrammar: Grammar, options: EmitOptions = {}): Promise<StringResult<string>> {
  try {
    await initialize();
    const indent = 2;
    const processed = await processGrammarToTM(processedGrammar.grammar, options);
    const jsonString = JSON.stringify(processed, undefined, indent);
    return ok(jsonString);
  } catch (err) {
    return error(err instanceof Error ? err.message : String(err));
  }
}

/**
 * Converts a grammar to Apple PList XML format.
 * 
 * Produces a .tmLanguage file compatible with TextMate, Sublime Text, and other
 * editors that support the original PList format. Includes the same validation
 * and processing as emitJSON.
 * 
 * @param grammar - The grammar to convert
 * @param options - Emission options for error reporting and validation control
 * @returns Promise resolving to XML PList string
 * 
 * @example
 * ```typescript
 * const grammarPlist = await emitPList(myGrammar);
 * await writeFile('my-grammar.tmLanguage', grammarPlist);
 * ```
 */
export async function emitPList(processedGrammar: Grammar, options: EmitOptions = {}): Promise<StringResult<string>> {
  try {
    await initialize();
    const processed = await processGrammarToTM(processedGrammar.grammar, options);
    const plistString = plist.build(processed as any);
    return ok(plistString);
  } catch (err) {
    return error(err instanceof Error ? err.message : String(err));
  }
}

/**
 * Converts a processed grammar to YAML format.
 */
export async function emitYAML(processedGrammar: Grammar, options: EmitOptions = {}): Promise<StringResult<string>> {
  try {
    await initialize();
    const processed = await processGrammarToTM(processedGrammar.grammar, options);
    const yamlString = yaml.dump(processed, { indent: 2, lineWidth: -1 });
    return ok(yamlString);
  } catch (err) {
    return error(err instanceof Error ? err.message : String(err));
  }
}

/**
 * Convert the grammar from our representation to the tmlanguage schema.
 * Perform validation in the process.
 */
async function processGrammarToTM(grammar: GrammarInput, options: EmitOptions): Promise<TMLanguageGrammar> {
  await initialize();

  const internalRepositoryMap = new Map<string, [Rule, any]>(); // Maps rule key to [originalRule, processedRuleDefinition]
  const grammarNameLower = grammar.name.toLowerCase();

  // 1. Pre-populate and process all rules from repositoryItems
  if (grammar.repositoryItems) {
    for (const rule of grammar.repositoryItems) {
      if ('key' in rule) { // Only rules with keys can be in the repository
        const keyedRule = rule as MatchRule | BeginEndRule | IncludeRule;
        if (!internalRepositoryMap.has(keyedRule.key)) {
          const entry: [Rule, any] = [keyedRule, undefined]; // Placeholder for cyclic dependencies
          internalRepositoryMap.set(keyedRule.key, entry);
          // Process the rule definition itself and store it in entry[1]
          entry[1] = processNode(keyedRule, options, grammarNameLower, internalRepositoryMap, true);
        } else {
          const existingEntry = internalRepositoryMap.get(keyedRule.key);
          if (existingEntry && existingEntry[0] !== keyedRule) {
            const factory = errorFactory.withLocation({ 
              filePath: options.errorSourceFilePath,
              ruleKey: keyedRule.key,
              contextPath: 'repositoryItems'
            });
            throw factory.reference(
              `Duplicate key found in repositoryItems: '${keyedRule.key}'. The same key is used for different rule objects.`,
              keyedRule.key,
              ErrorCodes.DUPLICATE_KEY
            );
          }
        }
      }
    }
  } else {
    // Note: This is an informational message, not an error
    // Repository discovery will be on-the-fly, which might be incomplete for complex grammars
    // It is recommended to list all keyed rules in repositoryItems for reliable repository generation
  }

  // 2. Process the main grammar structure. processNode for the grammar object will handle its top-level fields
  // and its 'patterns' array. The 'repositoryItems' field itself will be skipped during this processing.
  const outputGrammarStructure = processNode(grammar, options, grammarNameLower, internalRepositoryMap, false);

  // 3. Construct the final repository object for the output from our populated internalRepositoryMap
  const finalRepositoryObject: any = {};
  const sortedKeys = Array.from(internalRepositoryMap.keys()).sort(); // For consistent output
  for (const key of sortedKeys) {
    const entry = internalRepositoryMap.get(key);
    if (entry && entry[1] !== undefined) { // entry[1] holds the processed rule definition
      finalRepositoryObject[key] = entry[1];
    }
  }
  outputGrammarStructure.repository = finalRepositoryObject;

  return outputGrammarStructure;
}

// Added internalRepo parameter, and isProcessingRepositoryItem flag
function processNode(
  node: any, 
  options: EmitOptions, 
  grammarName: string, 
  currentRepository: Map<string, [Rule, any]>, 
  isRepositoryItemContext: boolean
): any {
  if (typeof node !== 'object' || node === null) {
    return node;
  }
  if (Array.isArray(node)) {
    return node.map((n) => processNode(n, options, grammarName, currentRepository, isRepositoryItemContext));
  }

  const outputNode: any = {};
  for (const originalKey in node) {
    if (!Object.prototype.hasOwnProperty.call(node, originalKey)) {
      continue;
    }
    const value = node[originalKey];
    let processedValue = value;

    try {
      switch (originalKey) {
        case "key":
          if (!isRepositoryItemContext) {
            outputNode[originalKey] = value;
          }
          break;
        case "repositoryItems":
          break;
        case "scope": {
          const ruleKeyForMeta = node.key || 'unknown';
          outputNode.name = value === meta
            ? `meta.${ruleKeyForMeta}.${grammarName}`
            : String(value);
          break;
        }
        case "begin":
        case "end":
        case "match":
        case "while":
        case "firstLineMatch":
        case "foldingStartMarker":
        case "foldingStopMarker":
          if (value instanceof RegExp) {
            processedValue = value.source;
          }
          validateRegexp(processedValue, node, originalKey, options);
          outputNode[originalKey] = processedValue;
          break;
        case "captures":
        case "beginCaptures":
        case "endCaptures":
        case "whileCaptures":
          // Special handling for capture groups
          outputNode[originalKey] = processNode(value, options, grammarName, currentRepository, true);
          break;
        case "patterns":
          outputNode[originalKey] = processPatterns(value, options, grammarName, currentRepository);
          break;
        default:
          outputNode[originalKey] = processNode(value, options, grammarName, currentRepository, false);
          break;
      }
    } catch (error) {
      // Improve error context
      const newError = new Error(
        `Error processing property '${originalKey}' in rule with key '${node.key || "unknown"}': ${(error as any).message}`
      );
      if (options.errorSourceFilePath) {
        newError.message += ` (source: ${options.errorSourceFilePath})`;
      }
      newError.stack = (error as any).stack;
      throw newError;
    }
  }
  return outputNode;
}

function processPatterns(
  patterns: Pattern[], 
  options: EmitOptions, 
  grammarName: string, 
  currentRepository: Map<string, [Rule, any]>
): any[] {
  const processedPatternsArray: any[] = [];
  for (const pattern of patterns) {
    // Handle BasicIncludePattern (already an include directive)
    if ('include' in pattern && !('key' in pattern)) {
      processedPatternsArray.push(pattern); 
      continue;
    }

    // Handle rule references and rule definitions
    const rule = pattern as Rule;

    // Check if this is a keyed rule
    if ('key' in rule) {
      const keyedRule = rule as MatchRule | BeginEndRule | IncludeRule;

      if (!keyedRule.key) {
        // eslint-disable-next-line no-console
        console.warn('Processing a rule without a key directly in patterns (will be inlined):', rule);
        processedPatternsArray.push(processNode(rule, options, grammarName, currentRepository, false));
        continue;
      }

      // Rule has a key. Check if it's already in the repository
      if (!currentRepository.has(keyedRule.key)) {
        // This rule was referenced but not pre-processed via repositoryItems
        // eslint-disable-next-line no-console
        console.warn(`Discovered and processing new repository item on-the-fly: '${keyedRule.key}'. For best results, pre-declare all keyed rules in top-level 'repositoryItems'.`);
        const entry: [Rule, any] = [keyedRule, undefined]; // Placeholder
        currentRepository.set(keyedRule.key, entry);
        entry[1] = processNode(keyedRule, options, grammarName, currentRepository, true);
      } else {
        const existingEntry = currentRepository.get(keyedRule.key);
        if (existingEntry && existingEntry[0] !== keyedRule) {
           // This is a sanity check. It should ideally be caught by the pre-processing loop.
           throw new Error(`Duplicate key '${keyedRule.key}' detected with a different rule object.`);
        }
      }

      // Now that we know it's in the repo, add an include directive
      processedPatternsArray.push({ include: `#${keyedRule.key}` });

    } else {
      // It's a rule without a key, process it inline.
      processedPatternsArray.push(processNode(rule, options, grammarName, currentRepository, false));
    }
  }
  return processedPatternsArray;
}

/**
 * Validates a regular expression using the Oniguruma engine.
 * Throws a detailed error if the pattern is invalid.
 */
function validateRegexp(regexp: string, node: any, prop: string, options: EmitOptions) {
  if (regexp !== 'string') {
    return;
  }
  try {
    // eslint-disable-next-line no-new
    new OnigRegExp(regexp);
  } catch (error) {
    const errorMessage =
`Invalid regular expression in property '${prop}': /${regexp}/
Rule: ${JSON.stringify(node, null, 2)}
Error: ${(error as any).message || String(error)}`;

    const newError = new Error(errorMessage);
    if (options.errorSourceFilePath) {
      newError.message += ` (source: ${options.errorSourceFilePath})`;
    }
    newError.stack = (error as any).stack || [];
    throw newError;
  }
} 
```

### src/index.ts

```
//@index('./*/index.ts', f => `export * from '${f.path}.js'`)
export * from './helpers/index.js'
export * from './scopes/index.js'
export * from './terminals/index.js'
export * from './testing/index.js'
export * from './validation/index.js'
//@endindex

//@index(['./*.ts', '!cli.ts', '!*.d.ts'], f => `export * from '${f.path}.js'`)
export * from './emit.js'
export * from './errors.js'
export * from './factory.js'
export * from './result.js'
export * from './types.js'
//@endindex
```


## Documentation

### docs/README.md

```markdown
# TextMate Toolkit Documentation

Complete documentation for building, testing, and shipping TextMate grammars with TypeScript.

## 📚 Documentation Overview

This documentation suite covers everything you need to know about the TextMate Toolkit, from basic concepts to advanced techniques.

### Getting Started
- **[Getting Started Guide](getting-started.md)** - Your first grammar in 15 minutes
- **[Core Concepts](modules-overview.md)** - Understanding the toolkit architecture
- **[API Reference](api-reference.md)** - Complete function and type reference

### Deep Dives
- **[TextMate Scopes Reference](textmate-scopes.md)** - Complete scope naming conventions
- **[Using Scopes](using-scopes.md)** - Type-safe scope management
- **[Troubleshooting Guide](troubleshooting.md)** - Common issues and solutions

## 🎯 Quick Navigation

### By Experience Level

**New to TextMate Grammars?**
1. Start with [Getting Started Guide](getting-started.md)
2. Read [Core Concepts](modules-overview.md) 
3. Try the examples in the toolkit

**Experienced with TextMate?**
1. Check out [API Reference](api-reference.md)
2. Explore [TextMate Scopes Reference](textmate-scopes.md)
3. Use [Troubleshooting Guide](troubleshooting.md) when needed

**Building Production Grammars?**
1. Master [Testing patterns](modules-overview.md#testing---making-sure-it-actually-works)
2. Follow [Performance tips](troubleshooting.md#performance-optimization)
3. Set up comprehensive validation workflows

### By Task

| I want to... | Read this |
|--------------|-----------|
| Create my first grammar | [Getting Started Guide](getting-started.md) |
| Understand the architecture | [Modules Overview](modules-overview.md) |
| Look up API functions | [API Reference](api-reference.md) |
| Use type-safe scopes | [Using Scopes](using-scopes.md) |
| Fix highlighting issues | [Troubleshooting Guide](troubleshooting.md) |
| Learn scope conventions | [TextMate Scopes Reference](textmate-scopes.md) |
| Understand the CLI | [Modules Overview](modules-overview.md#cli-architecture) |

## 🏗️ Architecture Overview

The toolkit is built around these core concepts:

```
Grammar Definition (TypeScript)
         ↓
    Factory Functions
         ↓
    Rule System (Match/BeginEnd/Include)
         ↓
    Validation (during emit/load)
         ↓
    Emission (JSON/Plist)
         ↓
    TextMate Grammar File
```

**Key Components:**
- **Factory Functions** - Clean APIs for creating grammars and rules
- **Type-Safe Scopes** - Prevent typos and ensure consistency
- **Regex Helpers** - Readable pattern construction
- **Terminal Patterns** - Pre-built patterns for common constructs
- **Validation System** - On-demand validation during emission and loading
- **Testing Framework** - Programmatic and declarative testing
- **Emission System** - Convert TypeScript to TextMate JSON/Plist
- **CLI** - A modular and maintainable command-line interface

## 📖 Documentation Categories

### Core Documentation

**[Modules Overview](modules-overview.md)** *(15 min read)*
- Complete architectural guide
- Module-by-module breakdown
- Real-world workflow examples
- Performance optimization tips

**[API Reference](api-reference.md)** *(Reference)*
- All public functions and types
- Complete parameter documentation
- Usage examples for every API
- TypeScript interface definitions

### Scope Management

**[TextMate Scopes Reference](textmate-scopes.md)** *(20 min read)*
- Complete scope naming conventions
- TextMate specification compliance
- Best practices for editor compatibility
- Scope hierarchy explanations

**[Using Scopes](using-scopes.md)** *(10 min read)*
- Type-safe scope API usage
- Creating static and extensible scopes
- Language-specific scope patterns
- Editor integration tips

### Practical Guides

**[Getting Started Guide](getting-started.md)** *(10 min read)*
- Step-by-step first grammar
- Core concept explanations
- Testing your grammar
- Common patterns and examples

**[Troubleshooting Guide](troubleshooting.md)** *(Reference)*
- Common issues and solutions
- Debugging techniques
- Performance optimization
- Error message explanations

## 🎨 Examples and Patterns

The toolkit includes complete example implementations:

- **Simple Language** - Basic keywords, comments, strings
- **Bicep** - Azure resource definitions with complex patterns
- **TypeSpec** - API definition language with advanced features

Find these in the `examples/` directory.

## 🚀 Quick Reference

### Essential APIs

```typescript
// Grammar creation
import { createGrammar, scopes, regex } from 'tmgrammar-toolkit';

// Terminal patterns
import { COMMENT, NUM, ID, OP } from 'tmgrammar-toolkit/terminals';

// Testing
import { createTesterFromContent } from 'tmgrammar-toolkit/testing';

// Validation
import { validateRegex, validateGrammar } from 'tmgrammar-toolkit/validation';

// Emission
import { emitJSON, emitPList } from 'tmgrammar-toolkit';
```

### Common Patterns

```typescript
// Keywords
const keywords = { 
  key: 'keywords',
  match: regex.keywords(['if', 'else', 'while']),
  scope: scopes.keyword.control
};

// Strings with escapes
const strings = {
  key: 'string',
  begin: /"/,
  end: /"/,
  scope: scopes.string.quoted.double,
  patterns: [
    { key: 'escape', match: /\\./, scope: scopes.constant.character.escape }
  ]
};

// Numbers
const numbers = {
  key: 'numbers',
  match: NUM.DEC,
  scope: scopes.constant.numeric
};
```

## 🔗 External Resources

- **[TextMate Grammar Manual](https://macromates.com/manual/en/language_grammars)** - Official specification
- **[VS Code Syntax Highlighting Guide](https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide)** - VS Code specifics
- **[Oniguruma Regular Expressions](https://github.com/kkos/oniguruma/blob/master/doc/RE)** - Regex engine reference
- **[TextMate Scope Naming](https://www.sublimetext.com/docs/scope_naming.html)** - Naming conventions

## 📝 Contributing to Documentation

Found an error or want to improve the docs?

1. **Small fixes**: Edit the Markdown files directly
2. **New sections**: Follow the existing structure and style
3. **Examples**: Include working code samples
4. **Cross-references**: Link to related sections

The documentation is written in Markdown and should be:
- **Clear and concise** - Get to the point quickly
- **Example-driven** - Show, don't just tell
- **Comprehensive** - Cover edge cases and gotchas
- **Up-to-date** - Reflect the current API

## 📋 Document Status

| Document | Status | Last Updated | Covers Version |
|----------|--------|--------------|----------------|
| Getting Started | ✅ Complete | Latest | v2.x |
| Modules Overview | ✅ Complete | Latest | v2.x |
| API Reference | ✅ Complete | Latest | v2.x |
| Scopes Reference | ✅ Complete | Latest | v2.x |
| Using Scopes | ✅ Complete | Latest | v2.x |
| Troubleshooting | ✅ Complete | Latest | v2.x |

---

**Need help?** Start with the [Getting Started Guide](getting-started.md) or jump to the [Troubleshooting Guide](troubleshooting.md) if you're facing specific issues. 
```

### docs/api-reference.md

```markdown
# API Reference

Complete reference for all public APIs in the TextMate Toolkit.

## Core Factory Functions

### `createGrammar(name, scopeName, fileTypes, patterns, options?)`

Creates a new TextMate grammar.

**Parameters:**
- `name: string` - Human-readable name for the grammar
- `scopeName: string` - Root scope name (e.g., 'source.typescript')
- `fileTypes: string[]` - File extensions this grammar applies to
- `patterns: Rule[]` - Top-level patterns/rules
- `options?: object` - Optional grammar configuration
  - `firstLineMatch?: RegexValue` - Regex to match first line for grammar detection
  - `foldingStartMarker?: RegexValue` - Regex marking start of foldable sections
  - `foldingStopMarker?: RegexValue` - Regex marking end of foldable sections
  - `repositoryItems?: Rule[]` - Explicitly declare all repository rules for reliable processing

**Returns:** `GrammarResult<Grammar>` - Result type requiring error checking

**Example:**
```typescript
const grammar = createGrammar(
  'My Language',
  'source.mylang',
  ['mylang', 'ml'],
  [keywordRule, commentRule],
  {
    firstLineMatch: /^#!/,
    repositoryItems: [keywordRule, commentRule]
  }
);
```

### `createRule(key, definition)`

Creates a rule with automatic type inference.

**Parameters:**
- `key: string` - Unique identifier for the rule
- `definition: RuleDefinition` - Rule pattern definition

**Returns:** `Rule`

## Emission Functions

### `emitJSON(grammar, options?)`

Converts a grammar to JSON format.

**Parameters:**
- `grammar: Grammar` - The grammar to emit
- `options?: EmitOptions` - Optional emission configuration

**Returns:** `Promise<StringResult<string>>` - Result type with potential validation errors

**Options:**
```typescript
interface EmitOptions {
  errorSourceFilePath?: string;  // For better error messages
  validate?: boolean;            // Validate patterns (default: true)
  formatOutput?: boolean;        // Pretty-print JSON (default: true)
}
```

### `emitPlist(grammar, options?)`

Converts a grammar to Plist format.

**Parameters:**
- `grammar: Grammar` - The grammar to emit
- `options?: EmitOptions` - Optional emission configuration

**Returns:** `Promise<StringResult<string>>` - Result type with potential validation errors

### `prepareGrammarForEmit(grammar, options?)`

Processes a grammar for emission without serializing it. This is useful for validating a grammar and then emitting it to multiple formats.

**Parameters:**
- `grammar: Grammar` - The grammar to process
- `options?: EmitOptions` - Optional emission configuration

**Returns:** `Promise<any>` - The processed grammar object

**Example:**
```typescript
const processedGrammar = await prepareGrammarForEmit(myGrammar);
const jsonOutput = JSON.stringify(processedGrammar, null, 2);
const plistOutput = plist.build(processedGrammar);
```

## Rule Types

### `MatchRule`

For simple pattern matching.

```typescript
interface MatchRule {
  key: string;
  match: RegExp | string;
  scope?: string;
  captures?: CaptureMap;
}
```

**Example:**
```typescript
const keywordRule: MatchRule = {
  key: 'keywords',
  match: /\b(if|else|while)\b/,
  scope: 'keyword.control'
};
```

### `BeginEndRule`

For multi-line constructs.

```typescript
interface BeginEndRule {
  key: string;
  begin: RegExp | string;
  end: RegExp | string;
  scope?: string;
  contentScope?: string;
  beginCaptures?: CaptureMap;
  endCaptures?: CaptureMap;
  patterns?: Rule[];
}
```

**Example:**
```typescript
const stringRule: BeginEndRule = {
  key: 'string',
  begin: /"/,
  end: /"/,
  scope: 'string.quoted.double',
  patterns: [escapeRule]
};
```

### `IncludeRule`

For grouping patterns or including other grammars.

```typescript
interface IncludeRule {
  key: string;
  patterns?: Rule[];
  include?: string;
}
```

**Example:**
```typescript
const expressionRule: IncludeRule = {
  key: 'expression',
  patterns: [numberRule, stringRule, identifierRule]
};
```

## Scopes API

### Accessing Scopes

```typescript
import { scopes, scopesFor } from 'tmgrammar-toolkit';

// Recommended: Use scopesFor for language-specific grammars
const langScopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });
const keywordScope = langScopes.keyword;          // "keyword.mylang"
const controlScope = langScopes.keyword.control;  // "keyword.control.mylang"

// Alternative: Global scopes (for dynamic or extensible grammars)
const jsKeyword = scopes.keyword('javascript');   // "keyword.javascript"
const pyControl = scopes.keyword.control('python'); // "keyword.control.python"
```

### Common Scope Categories

#### Keywords
```typescript
scopes.keyword                    // "keyword"
scopes.keyword.control           // "keyword.control"
scopes.keyword.control.conditional // "keyword.control.conditional"
scopes.keyword.operator          // "keyword.operator"
scopes.keyword.operator.assignment // "keyword.operator.assignment"
```

#### Constants
```typescript
scopes.constant                  // "constant"
scopes.constant.numeric         // "constant.numeric"
scopes.constant.numeric.integer // "constant.numeric.integer"
scopes.constant.language        // "constant.language"
scopes.constant.character.escape // "constant.character.escape"
```

#### Entities
```typescript
scopes.entity.name.function     // "entity.name.function"
scopes.entity.name.class        // "entity.name.class"
scopes.entity.name.type         // "entity.name.type"
scopes.entity.other.attribute   // "entity.other.attribute-name"
```

#### Comments
```typescript
scopes.comment.line             // "comment.line"
scopes.comment.line['double-slash'] // "comment.line.double-slash"
scopes.comment.block            // "comment.block"
```

#### Strings
```typescript
scopes.string.quoted.single     // "string.quoted.single"
scopes.string.quoted.double     // "string.quoted.double"
scopes.string.quoted.triple     // "string.quoted.triple"
```

## Regex Helpers

### Basic Helpers

```typescript
import { regex } from 'tmgrammar-toolkit/helpers';

// Word boundaries
regex.bounded('text')            // "\\btext\\b"
regex.wordBoundary               // "\\b"

// Quantifiers
regex.optional('text')           // "(?:text)?"
regex.zeroOrMore('text')         // "(?:text)*"
regex.oneOrMore('text')          // "(?:text)+"

// Grouping
regex.capture('text')            // "(text)"
regex.group('text')              // "(?:text)"
regex.nonCapture('text')         // "(?:text)"

// Escaping
regex.escape('text.with.dots')   // "text\\.with\\.dots"

// Wrapping
regex.wrap('foo', '"')           // "\\"foo\\""

### Pattern Construction

```typescript
// Alternation
regex.oneOf(['if', 'else'])      // "(?:if|else)"
regex.keywords(['if', 'else'])   // "\\b(?:if|else)\\b"

// Lookahead/Lookbehind
regex.before('pattern')          // "(?=pattern)"
regex.notBefore('pattern')       // "(?!pattern)"
regex.after('pattern')           // "(?<=pattern)"
regex.notAfter('pattern')        // "(?<!pattern)"

// Character classes
regex.anyOf('abc')               // "[abc]"
regex.range('a', 'z')            // "[a-z]"
regex.notAnyOf('abc')            // "[^abc]"

// Concatenation
regex.concat('a', /b/, 'c')      // "(?:abc)"
```

## Terminal Patterns

### Comments

```typescript
import { COMMENT } from 'tmgrammar-toolkit/terminals';

COMMENT.SLASHES                  // "//"
COMMENT.HASH                     // "#"
COMMENT.DASHES                   // "--"
COMMENT.PERCENT                  // "%"
COMMENT.BLOCK.START              // "/*"
COMMENT.BLOCK.END                // "*/"
```

### Numbers

```typescript
import { NUM } from 'tmgrammar-toolkit/terminals';

NUM.INT                          // Integer patterns
NUM.FLOAT                        // Float patterns
NUM.DEC                          // Decimal numbers
NUM.HEX                          // Hexadecimal (0xFF)
NUM.BIN                          // Binary (0b1010)
NUM.OCT                          // Octal (0o777)
```

### Identifiers

```typescript
import { ID } from 'tmgrammar-toolkit/terminals';

ID                               // Standard identifier
CAMEL_CASE_ID                    // camelCase
PASCAL_CASE_ID                   // PascalCase
SNAKE_CASE_ID                    // snake_case
CONSTANT_ID                      // ALL_CAPS
KEBAB_CASE_ID                    // kebab-case
```

### Operators

```typescript
import { OP } from 'tmgrammar-toolkit/terminals';

OP.ASSIGNMENT                    // =, +=, -=, etc.
OP.COMPARISON                    // ==, !=, <, >, etc.
OP.ARITHMETIC                    // +, -, *, /, %
OP.LOGICAL                       // &&, ||, !
OP.BITWISE                       // &, |, ^, ~, <<, >>
```

### Character and Marker Patterns

```typescript
import { DOT, WB, EOL, BOL } from 'tmgrammar-toolkit/terminals';

// From terminals/chars.ts
DOT                              // /\./

// From terminals/markers.ts  
WB                               // /\b/ (word boundary)
EOL                              // /$/ (end of line)
BOL                              // /^/ (beginning of line)
```

## Testing API

### Programmatic Testing

```typescript
import { createTesterFromFile, createTesterFromContent } from 'tmgrammar-toolkit/testing';

// From grammar file
const tester = createTesterFromFile('./grammar.json', 'source.mylang');

// From grammar object
const tester = createTesterFromContent(grammarObject, 'source.mylang');

// Tokenize code
const tokens = await tester.tokenize('if (true) { }');

// Expectations
tester.expectTokenScope(tokens, 'if', 'keyword.control');
tester.expectTokenContent(tokens, 1, '(');
tester.expectTokenLength(tokens, 5);
```

### Declarative Testing

**Note:** The correct function names are `declarativeTest` and `snapshot`.

```typescript
import { declarativeTest, snapshot } from 'tmgrammar-toolkit/testing';

// Run tests with embedded scope assertions
await declarativeTest('./tests/**/*.test.mylang', {
  grammar: './grammar.json',
  compact: true
});

// Snapshot testing
await snapshot('./tests/**/*.mylang', {
  grammar: './grammar.json',
  updateSnapshots: false
});
```

## Validation API

### Pattern Validation

```typescript
import { validateRegex, validateRegexPatterns } from 'tmgrammar-toolkit/validation';

// Single pattern
const result = await validateRegex('\\b(if|else)\\b');
if (!result.valid) {
  console.error(result.error);
}

// Multiple patterns
const results = await validateRegexPatterns([
  '\\b(if|else)\\b',
  '[a-zA-Z_]\\w*'
]);
```

### Grammar Validation

```typescript
import { validateGrammar, validateScopeName } from 'tmgrammar-toolkit/validation';

// Grammar structure
const grammarResult = validateGrammar(myGrammar);

// Scope names
const scopeResult = validateScopeName('keyword.control.conditional');
```

## CLI Commands

### Grammar Emission

```bash
# Basic emission to JSON
tmt emit grammar.ts -o output.json

# Specific export
tmt emit grammar.ts myGrammarExport

# The CLI currently only supports JSON output.
# For other formats like Plist, use the programmatic API.
```

### Testing

```bash
# Declarative tests
tmt test 'tests/**/*.test.mylang'
tmt test 'tests/**/*.test.mylang' -g grammar.json --compact

# Snapshot tests  
tmt snap 'tests/**/*.mylang'
tmt snap 'tests/**/*.mylang' --update
```

### Validation

```bash
# Validate grammar files
tmt validate grammar.json
tmt validate grammar.ts
tmt validate grammar.ts specificExport
```

## Type Definitions

### Core Types

```typescript
interface Grammar {
  name: string;
  scopeName: string;
  fileTypes: string[];
  patterns: Rule[];
  repository?: Record<string, Rule>;
  foldingStartMarker?: string;
  foldingStopMarker?: string;
  firstLineMatch?: string;
  injections?: Record<string, Rule>;
}

type Rule = MatchRule | BeginEndRule | IncludeRule;

interface CaptureMap {
  [key: string]: {
    name?: string;
    patterns?: Rule[];
  };
}
```

### Emission Types

```typescript
interface EmitOptions {
  errorSourceFilePath?: string;
  validate?: boolean;
  formatOutput?: boolean;
}

interface ValidationResult {
  valid: boolean;
  error?: string;
  warnings?: string[];
}
```

### Testing Types

```typescript
interface Token {
  content: string;
  scope: string[];
  startIndex: number;
  endIndex: number;
}

interface TestOptions {
  grammar?: string;
  compact?: boolean;
  updateSnapshots?: boolean;
}
``` 
```

### docs/getting-started.md

```markdown
# Getting Started

Welcome to the TextMate Toolkit! This guide will walk you through creating your first grammar and understanding the core concepts.

## Prerequisites

- **Bun (highly recommended)** or Node.js 18+
- TypeScript knowledge
- Basic understanding of regular expressions
- Familiarity with syntax highlighting concepts

**Why Bun?** The toolkit leverages Bun's seamless TypeScript integration to let you work directly with `.ts` grammar files without a separate build step. This dramatically improves the development experience.

## Installation

```bash
# Using Bun (recommended)
bun add tmgrammar-toolkit

# Using npm
npm install tmgrammar-toolkit

# Using yarn
yarn add tmgrammar-toolkit
```

## Your First Grammar

Let's create a simple grammar for a fictional language called "MyLang". We'll add support for keywords, comments, and strings.

### Step 1: Create the Grammar File

Create a new file `mylang-grammar.ts`:

```typescript
import { createGrammar, scopesFor, regex } from 'tmgrammar-toolkit';
import { COMMENT } from 'tmgrammar-toolkit/terminals';
import type { MatchRule, BeginEndRule } from 'tmgrammar-toolkit';

// Create static scopes for performance (recommended)
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });

// Define keywords rule
const keywordRule: MatchRule = {
  key: 'keywords',
  match: regex.keywords(['if', 'else', 'while', 'for', 'function', 'return']),
  scope: scopes.keyword.control
};

// Define line comment rule
const lineCommentRule: MatchRule = {
  key: 'line-comment',
  match: regex.concat(COMMENT.SLASHES, /.*$/),
  scope: scopes.comment.line.double_slash
};

// Define string rule with escape sequences
const stringRule: BeginEndRule = {
  key: 'string',
  begin: /"/,
  end: /"/,
  scope: scopes.string.quoted.double,
  patterns: [
    {
      key: 'string-escape',
      match: /\\./,
      scope: scopes.constant.character.escape
    }
  ]
};

// Create the complete grammar
export const myLangGrammar = createGrammar(
  'MyLang',              // Human-readable name
  'source.mylang',       // Root scope identifier
  ['mylang', 'ml'],      // File extensions
  [                      // Top-level patterns
    keywordRule,
    lineCommentRule,
    stringRule
  ]
);
```

### Step 2: Generate the Grammar File

Now generate the actual TextMate grammar file. With Bun, you can work directly with TypeScript:

```bash
# Using the CLI with Bun (works directly with .ts files!)
bunx tmt emit mylang-grammar.ts -o mylang.tmLanguage.json

# Or with npx
npx tmt emit mylang-grammar.ts -o mylang.tmLanguage.json
```

Or programmatically:

```typescript
import { emitJSON, isError } from 'tmgrammar-toolkit';
import { myLangGrammar } from './mylang-grammar.js';
import { writeFile } from 'node:fs/promises';

// emitJSON accepts a Result and handles the unwrapping
const result = await emitJSON(myLangGrammar);
if (isError(result)) {
  console.error('Grammar validation failed:', result.error);
  process.exit(1);
}

await writeFile('mylang.tmLanguage.json', result.value);
```

### Step 3: Test Your Grammar

Create a test file to verify your grammar works. The CLI provides a handy test runner:

```bash
# Create a test file with assertions
# See the testing documentation for more details
# tests/mylang.test.lang

# Run the test command
bunx tmt test 'tests/**/*.test.lang' -g mylang.tmLanguage.json
```

Or test programmatically:

```typescript
// mylang-test.ts
import { createTesterFromContent } from 'tmgrammar-toolkit/testing';
import { myLangGrammar } from './mylang-grammar.js';

const tester = createTesterFromContent(myLangGrammar, 'source.mylang');

// Test code sample
const code = `
if (condition) {
  // This is a comment
  return "Hello, world!";
}
`;

const tokens = await tester.tokenize(code);

// Verify token scopes
tester.expectTokenScope(tokens, 'if', 'keyword.control.mylang');
tester.expectTokenScope(tokens, '//', 'comment.line.double-slash.mylang');
tester.expectTokenScope(tokens, 'Hello, world!', 'string.quoted.double.mylang');

console.log('All tests passed!');
```

## Core Concepts

### Rules Are Everything

In TextMate grammars, everything is a **Rule**. There are three types:

1. **MatchRule** - For simple patterns
2. **BeginEndRule** - For multi-line constructs  
3. **IncludeRule** - For grouping patterns

```typescript
// Simple pattern matching
const numberRule: MatchRule = {
  key: 'numbers',
  match: /\d+(\.\d+)?/,
  scope: scopes.constant.numeric
};

// Multi-line constructs
const blockCommentRule: BeginEndRule = {
  key: 'block-comment',
  begin: /\/\*/,
  end: /\*\//,
  scope: scopes.comment.block
};

// Grouping patterns
const expressionRule: IncludeRule = {
  key: 'expression',
  patterns: [numberRule, stringRule, identifierRule]
};
```

### Scopes Define Meaning

Scopes tell editors how to highlight and understand your code. Use our type-safe scopes API:

```typescript
// Create scopes for your language
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });

// Use the type-safe scope properties
scope: scopes.keyword.control.conditional  // "keyword.control.conditional.mylang"
```

Common scope patterns:
- `keyword.*` - Language keywords
- `string.*` - String literals
- `comment.*` - Comments
- `constant.*` - Constants and literals
- `entity.name.*` - Names of functions, classes, etc.

### Automatic Repository Management

**This is a major convenience feature**: The toolkit automatically collects rules with a `key` property and places them into the grammar's repository during emission. You don't need to manually manage the repository structure!

```typescript
const keywordRule = { key: 'keywords', /* ... */ };
const stringRule = { key: 'strings', /* ... */ };
// No duplicate keys allowed - the emit system catches this

// For explicit control, use repositoryItems:
export const myLangGrammar = createGrammar(
  'My Language',
  'source.mylang',
  ['mylang'],
  [keywordRule, stringRule],
  {
    repositoryItems: [keywordRule, stringRule], // Explicitly declare all rules
    firstLineMatch: /^#!/
  }
);
```

**Why this matters**: Traditional TextMate grammar development requires manually managing a complex repository structure. Our system eliminates this source of errors and makes grammars much more maintainable.

## Adding More Features

### Numbers with Multiple Formats

```typescript
import { NUM } from 'tmgrammar-toolkit/terminals';

const numberRule: MatchRule = {
  key: 'numbers',
  match: regex.oneOf([
    NUM.DEC,    // Decimal: 123, 123.45, 1.23e-4
    NUM.HEX,    // Hexadecimal: 0xFF, 0xABCD  
    NUM.BIN,    // Binary: 0b1010
    NUM.OCT     // Octal: 0o777
  ]),
  scope: scopes.constant.numeric
};
```

### Function Declarations with Parameters

```typescript
const functionDeclaration: BeginEndRule = {
  key: 'function-declaration',
  scope: scopes.meta.function,
  begin: regex.concat(
    /(function)\s+/,     // function keyword
    regex.capture(ID),   // function name
    /\s*(\()/           // opening parenthesis
  ),
  beginCaptures: {
    '1': { scope: scopes.keyword.declaration.function },
    '2': { scope: scopes.entity.name.function },
    '3': { scope: scopes.punctuation.section.parens.begin }
  },
  end: /\)/,
  endCaptures: {
    '0': { scope: scopes.punctuation.section.parens.end }
  },
  patterns: [
    {
      key: 'parameter',
      scope: scopes.variable.parameter,
      match: ID
    },
    {
      key: 'parameter-separator',
      scope: scopes.punctuation.separator.comma,
      match: /,/
    }
  ]
};
```

### Block Comments with Nesting

```typescript
const blockComment: BeginEndRule = {
  key: 'block-comment',
  scope: scopes.comment.block,
  begin: /\/\*/,
  end: /\*\//,
  patterns: [
    // Nested block comments
    { include: '#block-comment' }
  ]
};
```

## Scope System Deep Dive

### Static vs Callable Scopes

```typescript
// Static scopes (recommended for production)
const staticScopes = scopesFor({ suffix: 'lang', allowScopeExtension: false });
console.log(staticScopes.keyword.control.conditional);  // "keyword.control.conditional.lang"

// Callable scopes (for extensible grammars)
const callableScopes = scopesFor({ suffix: 'lang', allowScopeExtension: true });
console.log(callableScopes.keyword.control.conditional('async'));  // "keyword.control.conditional.lang.async"
```

### Custom Scope Definitions

```typescript
const customScopes = scopesFor({ 
  suffix: 'mylang', 
  allowScopeExtension: false 
}, {
  // Add language-specific custom scopes
  meta: {
    section: {
      header: null,
      body: null
    }
  }
});

// Use your custom scopes
scope: customScopes.meta.section.header  // "meta.section.header.mylang"
```

## Testing Your Grammar

### Basic Testing

```typescript
import { createTesterFromContent } from 'tmgrammar-toolkit/testing';

const tester = createTesterFromContent(myGrammar, 'source.mylang');
const tokens = await tester.tokenize('if (true) { }');

// Check individual tokens
tester.expectTokenScope(tokens, 'if', 'keyword.control.mylang');
tester.expectTokenScope(tokens, 'true', 'constant.language.mylang');
```

### Advanced Testing

```typescript
// Test multi-line constructs
const multiLineCode = `
function hello() {
  /* block comment */
  return "world";
}
`;

const tokens = await tester.tokenize(multiLineCode);

// Test scope hierarchy
tester.expectScopeAtPosition(tokens, { line: 1, character: 0 }, [
  'source.mylang',
  'meta.function.mylang',
  'keyword.declaration.function.mylang'
]);

// Test that comments don't interfere with function scope
tester.expectTokenScope(tokens, 'return', 'keyword.control.mylang');
```

## Common Patterns

### Keywords with Boundaries

```typescript
// Always use word boundaries for keywords
const keywords: MatchRule = {
  key: 'keywords',
  match: regex.keywords(['class', 'interface', 'extends']),  // Automatically adds \b boundaries
  scope: scopes.keyword.declaration
};
```

### Identifiers vs Function Calls

```typescript
// Regular identifiers
const identifier: MatchRule = {
  key: 'identifier',
  match: regex.concat(ID, regex.notBefore(/\s*\(/)),  // Not followed by opening paren
  scope: scopes.variable.other.readwrite
};

// Function calls
const functionCall: MatchRule = {
  key: 'function-call',
  match: regex.concat(ID, regex.before(/\s*\(/)),    // Followed by opening paren
  scope: scopes.entity.name.function
};
```

### String Interpolation

```typescript
const templateLiteral: BeginEndRule = {
  key: 'template-literal',
  scope: scopes.string.template,
  begin: /`/,
  end: /`/,
  patterns: [
    {
      key: 'template-expression',
      scope: scopes.meta.interpolation,
      begin: /\$\{/,
      end: /\}/,
      patterns: [
        // Include all expressions here
        { include: '#expression' }
      ]
    }
  ]
};
```

## Development Workflow with Bun

The toolkit is designed for rapid iteration. Here's the recommended workflow:

```bash
# 1. Create your grammar in TypeScript
code my-grammar.ts

# 2. Generate and validate in one step
bunx tmt emit my-grammar.ts --validate -o grammar.json

# 3. Test with real code samples
bunx tmt test 'tests/**/*.test' -g grammar.json

# 4. Iterate quickly - no build step needed!
```

**Key Benefits:**
- **No Build Step**: Work directly with TypeScript files
- **Instant Feedback**: CLI commands work immediately
- **Type Safety**: Catch errors at development time
- **Rich Testing**: Comprehensive testing APIs

## Key Concepts Recap

1. **Automatic Repository**: Rules with `key` properties are automatically managed
2. **Type-Safe Scopes**: Use `scopesFor()` to avoid scope name typos
3. **Rich Terminals**: Pre-built patterns for common language constructs
4. **Validation**: Built-in regex and grammar validation using VS Code's engine
5. **Testing First**: Comprehensive testing APIs for reliable grammars

## Next Steps

1. **Study the Examples**: Check out the complete examples in the toolkit:
   - [Simple Example](../examples/simple-example.ts) - Educational with best practices
   - [Bicep Example](../examples/tmgrammar-toolkit/bicep.ts) - Real-world language
   - [TypeSpec Example](../examples/tmgrammar-toolkit/typespec.ts) - Complex features

2. **Read the Guides**:
   - [Modules Overview](modules-overview.md) - Understand the architecture
   - [Using Scopes](using-scopes.md) - Master the scope system
   - [API Reference](api-reference.md) - Complete function reference
   - [Troubleshooting](troubleshooting.md) - Common issues and solutions

3. **Test Everything**: Use the testing framework to ensure your grammar works correctly

4. **Performance**: Use static scopes for production grammars for better performance

Happy grammar building! 🎉 
```

### docs/modules-overview.md

```markdown
# TextMate Toolkit: Complete Guide

You know that feeling when you're staring at a 500-line JSON file full of regex patterns, wondering if there's a better way to build TextMate grammars? We've been there too. After building several language grammars and watching our team struggle with the same repetitive patterns, we created this toolkit to make the whole process more... human.

## What This Toolkit Actually Solves

TextMate grammars are powerful, but writing them by hand is like performing surgery with oven mitts. You're dealing with:

- **Regex soup**: Hundreds of patterns scattered across a massive JSON file
- **Scope name typos**: One wrong character and your highlighting breaks
- **Repository chaos**: Managing references between patterns without going insane  
- **Testing nightmares**: "Did my change break something? Let me manually check 47 test cases..."
- **Copy-paste hell**: The same patterns showing up in every grammar you write

We built this toolkit because we got tired of reinventing the wheel every time we needed to tokenize a new language.

## The Mental Model

Think of building a TextMate grammar like constructing a building:

1. **Foundation** (`types.ts`): The architectural blueprints - strict TypeScript definitions that map exactly to the tmlanguage spec
2. **Building Blocks** (`terminals/`, `helpers/`): Pre-fabricated components - common patterns you'll use everywhere
3. **Assembly Tools** (`factory.ts`, `scopes.ts`): The construction equipment - clean APIs for putting pieces together
4. **Quality Control** (`validation/`): The inspectors - making sure your regex actually works
5. **Final Output** (`emit.ts`): The general contractor - converts your readable code into the JSON that VS Code expects
6. **Testing Suite** (`testing/`): The stress tests - make sure everything works before you ship

## Core Architecture: How It All Fits Together

### The Rule System

Everything in a TextMate grammar is a **Rule**. We've designed our type system around this concept:

```typescript
// Every rule needs a unique key for the repository
interface RuleKey {
  key: string;
}

// Three main rule types:
type Rule = MatchRule | BeginEndRule | IncludeRule;
```

The beauty here is that you define rules using clean TypeScript objects, and our emit system handles all the gnarly repository management behind the scenes.

### Scope Management 

Instead of typing `"keyword.control.conditional"` everywhere and inevitably fat-fingering it, we built a type-safe scopes API:

```typescript
import { scopesFor } from 'tmgrammar-toolkit';

// Create type-safe scopes for your language (recommended)
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });

// This gives you autocomplete and catches typos at compile time
const conditionalScope = scopes.keyword.control.conditional;  // "keyword.control.conditional.mylang"
```

### Automatic Repository Management 

**This is the killer feature**: TextMate grammars use a "repository" to organize patterns, but managing it manually is a nightmare. You end up with duplicate keys, circular references, and patterns that reference things that don't exist.

Our emit system solves this by:
- **Automatically collecting rules** with a `key` property during emission
- **Detecting duplicate keys** and throwing clear errors with helpful context
- **Converting rule objects** into the messy JSON format VS Code expects
- **Supporting explicit control** via the `repositoryItems` array when needed

```typescript
// Rules are automatically collected into the repository
const keywordRule = { key: 'keywords', match: /\b(if|else)\b/, scope: 'keyword.control' };
const stringRule = { key: 'strings', begin: /"/, end: /"/, scope: 'string.quoted.double' };

// The emit system builds this repository automatically:
// {
//   "repository": {
//     "keywords": { "match": "\\b(if|else)\\b", "name": "keyword.control" },
//     "strings": { "begin": "\"", "end": "\"", "name": "string.quoted.double" }
//   }
// }
```

### The `meta` Symbol System

The special `meta` symbol gets expanded to `meta.<rule_key>.<grammar_name>` during emission, providing structural scopes without boilerplate:

```typescript
import { meta } from 'tmgrammar-toolkit';

const functionRule: BeginEndRule = {
  key: 'function-declaration',
  scope: meta,  // Expands to "meta.function-declaration.mylang"
  begin: /function\s+(\w+)/,
  // ...
};
```

This creates consistent, meaningful meta scopes that help editors understand code structure.

## Module Deep Dive

### `/helpers` - Regex Construction Kit

When you're building regex patterns, you end up writing the same utility functions over and over. We collected all the common ones:

```typescript
import { regex } from 'tmgrammar-toolkit/helpers';

// Instead of: "\\b(if|else|while)\\b"
const keywords = regex.keywords(['if', 'else', 'while']);

// Instead of: "(?=\\()"  
const beforeParen = regex.before('\\(');

// Instead of manually escaping: "test\\.file\\.name"
const escaped = regex.escape('test.file.name');
```

**Why we built this**: After the fourth time someone wrote a buggy `oneOf` function, we realized this should just be a library.

The helpers include:
- `bounded()` - Word boundaries around text
- `before()`, `notBefore()` - Positive/negative lookahead
- `after()`, `notAfter()` - Positive/negative lookbehind  
- `oneOf()` - Alternation from arrays
- `keywords()` - Word-bounded alternation
- `escape()` - Proper regex escaping
- `optional()`, `zeroOrMore()`, `oneOrMore()` - Quantifiers
- `capture()`, `group()` - Grouping utilities

### `/terminals` - The Pattern Library

Every programming language has the same basic building blocks. Instead of reinventing these patterns for each grammar, we've collected the most common ones:

#### Comments (`/terminals/comments.ts`)
```typescript
import { COMMENT } from 'tmgrammar-toolkit/terminals';

// Line comments: //
COMMENT.SLASHES

// Block comments: /* */
COMMENT.BLOCK.START
COMMENT.BLOCK.END
```

#### Numbers (`/terminals/numbers.ts`)
```typescript
import { NUM } from 'tmgrammar-toolkit/terminals';

// Covers decimal, hex, binary, octal with proper edge cases
NUM.DEC   // 123, 123.45, 1.23e-4, 123n
NUM.HEX   // 0xFF, 0xABCD_1234
NUM.BIN   // 0b1010_1111
NUM.OCT   // 0o777
NUM.INT   // Simple integers
NUM.FLOAT // Simple floats with scientific notation
```

#### Identifiers (`/terminals/identifiers.ts`)
Different languages have different identifier conventions:
```typescript
ID                // Standard: [a-zA-Z_][a-zA-Z0-9_]*
CAMEL_CASE_ID     // camelCase
PASCAL_CASE_ID    // PascalCase  
SNAKE_CASE_ID     // snake_case
CONSTANT_ID       // ALL_CAPS
KEBAB_CASE_ID     // kebab-case
```

#### And More...
- **Operators**: Assignment, comparison, logical, arithmetic operators
- **Strings**: Escape sequences, quote patterns
- **Whitespace**: Required/optional spaces, tabs, newlines
- **Markers**: Word boundaries, line start/end

**The philosophy**: If you find yourself writing the same regex pattern in multiple grammars, it probably belongs in terminals.

### `/validation` - Catching Problems Early

Nothing's worse than spending an hour debugging a grammar only to find out you had a typo in a regex pattern. Our validation system catches these issues before they become problems.

#### Regex Validation (`/validation/regex.ts`)
```typescript
import { validateRegex, validateRegexPatterns } from 'tmgrammar-toolkit/validation';

// Test a single pattern
const result = await validateRegex('\\b(if|else)\\b');
if (!result.valid) {
  console.log(`Bad regex: ${result.error}`);
}

// Test multiple patterns at once
const results = await validateRegexPatterns([
  '\\b(if|else)\\b',
  '[invalid[regex',
  '(?<=start)content(?=end)'
]);
```

**This uses the actual Oniguruma engine that VS Code uses**, so you're testing against the real thing. This catches regex issues that would only surface when your grammar is loaded in an editor, saving hours of debugging.

#### Scope Validation (`/validation/scope.ts`)
```typescript
import { validateScopeName } from 'tmgrammar-toolkit/validation';

const result = validateScopeName('keyword.control.conditional');
// Checks for:
// - Valid characters (letters, numbers, dots, hyphens)
// - Proper structure (no empty parts, no consecutive dots)
// - Common root scopes
// - TextMate conventions
```

#### Grammar Validation (`/validation/grammar.ts`)
Basic structural validation for your complete grammar:
```typescript
import { validateGrammar } from 'tmgrammar-toolkit/validation';

const result = validateGrammar(myGrammar);
// Checks for required fields, proper types, common issues
```

### `/testing` - Making Sure It Actually Works

We learned the hard way that a grammar that "looks right" and a grammar that "works right" are different things. The testing module gives you tools to actually verify your patterns work.

#### Programmatic Testing (`/testing/programmatic.ts`)

This is your bread and butter for unit testing individual patterns:

```typescript
import { createTesterFromFile } from 'tmgrammar-toolkit/testing';

const tester = createTesterFromFile('./my-grammar.json', 'source.mylang');

// Test tokenization
const tokens = await tester.tokenize('if (condition) { }');

// Verify specific tokens have expected scopes
tester.expectTokenScope(tokens, 'if', 'keyword.control.conditional');
tester.expectTokenScope(tokens, '(', 'punctuation.section.parens');
```

**Why this matters**: We once spent three days debugging why function calls weren't highlighting properly, only to discover our `(` pattern was being matched by the wrong rule. Programmatic testing catches this stuff immediately.

#### Declarative Testing (`/testing/helpers.ts`)

For integration testing, we support the vscode-tmgrammar-test format:

```typescript
import { declarativeTest, snapshot } from 'tmgrammar-toolkit/testing';

// Run tests with embedded scope assertions
declarativeTest('./tests/**/*.test.mylang', {
  grammar: './grammars/mylang.json',
  compact: true
});

// Generate/compare snapshots
snapshot('./tests/**/*.test.mylang', {
  updateSnapshots: true
});
```

This lets you write test files like:
```
if (true) {
// <- keyword.control.conditional
//   ^ constant.language.boolean
}
```

## The Complete Workflow

Here's how we typically build a grammar with this toolkit:

### 1. Start with Types and Structure

```typescript
import { createGrammar, scopes, regex } from 'tmgrammar-toolkit';

const myGrammar = createGrammar(
  'MyLanguage',           // Display name
  'source.mylang',        // Scope name  
  ['mylang', 'ml'],       // File extensions
  [                       // Top-level patterns
    keywordRule,
    commentRule,
    stringRule
  ]
);
```

### 2. Build Rules with Helpers and Terminals

```typescript
import { COMMENT, NUM, ID } from 'tmgrammar-toolkit/terminals';
import { regex } from 'tmgrammar-toolkit/helpers';

const keywordRule: MatchRule = {
  key: 'keywords',
  match: regex.keywords(['if', 'else', 'while', 'for']),
  scope: scopes.keyword.control
};

const numberRule: MatchRule = {
  key: 'numbers', 
  match: NUM.DEC,
  scope: scopes.constant.numeric
};
```

### 3. Validate as You Go

```typescript
import { validateRegex } from 'tmgrammar-toolkit/validation';

// Check your patterns before using them
const regexResult = await validateRegex(regex.keywords(['if', 'else']));
if (!regexResult.valid) {
  throw new Error(`Invalid regex: ${regexResult.error}`);
}
```

### 4. Test Your Patterns

```typescript
import { createTesterFromContent } from 'tmgrammar-toolkit/testing';

const tester = createTesterFromContent(myGrammar, 'source.mylang');
const tokens = await tester.tokenize('if (true) { return 42; }');

// Verify each token gets the right scope
tester.expectTokenScope(tokens, 'if', 'keyword.control');
tester.expectTokenScope(tokens, 'true', 'constant.language.boolean');
tester.expectTokenScope(tokens, '42', 'constant.numeric');
```

### 5. Generate the Final Grammar

```typescript
import { emitJSON } from 'tmgrammar-toolkit';

const grammarJSON = await emitJSON(myGrammar, {
  errorSourceFilePath: './my-grammar.ts' // For better error messages
});

// Write to .tmLanguage.json file
await writeFile('./grammars/mylang.tmLanguage.json', grammarJSON);
```

## Real-World Patterns

### Complex Begin/End Rules

For multi-line constructs like strings or comments:

```typescript
const multiLineStringRule: BeginEndRule = {
  key: 'multiline-string',
  scope: scopes.string.quoted.triple,
  begin: /"""/,
  end: /"""/,
  patterns: [
    {
      key: 'string-escape',
      match: COMMON_ESCAPE,
      scope: scopes.constant.character.escape
    }
  ]
};
```

### Embedded Languages

For things like SQL in Python strings or CSS in HTML:

```typescript
const sqlStringRule: BeginEndRule = {
  key: 'sql-string',
  scope: scopes.string.quoted.double,
  begin: regex.after('sql\\s*=\\s*')/"/,
  end: /"/,
  patterns: [
    {
      key: 'embedded-sql',
      include: 'source.sql' // Reference external grammar
    }
  ]
};
```

## Common Gotchas We've Learned

### Repository Key Conflicts
Every rule needs a unique key. We've seen this pattern too many times:
```typescript
// ❌ Both rules have the same key
const stringRule1 = { key: 'string', match: /"[^"]*"/, scope: 'string.quoted.double' };
const stringRule2 = { key: 'string', match: /'[^']*'/, scope: 'string.quoted.single' };
```

The emit system will catch this and throw a clear error.

### Regex Escaping
JavaScript strings and regex have different escaping rules:
```typescript
// ❌ Wrong - not enough escaping
match: "\b(function)\b"

// ✅ Right - proper escaping  
match: "\\b(function)\\b"

// ✅ Even better - use our helpers
match: regex.bounded('function')
```

### Scope Ordering
More specific scopes should come before general ones:
```typescript
patterns: [
  functionDeclarationRule,  // matches "function foo()"
  keywordRule              // matches "function" 
]
```

## Performance Tips

### Use Atomic Groups
For performance, use atomic groups when you don't need backtracking:
```typescript
// Instead of: (if|else|while)+
// Use: (?>if|else|while)+
```

### Limit Lookahead/Lookbehind
These are expensive operations. Use sparingly:
```typescript
// ❌ Expensive
match: /(?<=\w)\.(?=\w)/

// ✅ Often faster
match: /\w\.\w/
```

### Profile Your Grammar
Use the testing tools to identify slow patterns:
```typescript
const start = performance.now();
const tokens = await tester.tokenize(largeCodeSample);
const time = performance.now() - start;
console.log(`Tokenized ${largeCodeSample.length} chars in ${time}ms`);
```

## What's Next?

This toolkit is designed to grow with your needs. We're constantly adding new terminals and helpers based on patterns we see across different grammars. 

If you find yourself writing the same pattern multiple times, consider contributing it back to the terminals library. And if you run into edge cases our validation doesn't catch, let us know - we want this toolkit to save you from the same mistakes we made.

## CLI Architecture

The `tmt` CLI is designed for a seamless development experience, especially when working with TypeScript.

### Key Features

- **Modular Design**: The CLI is architected with a clear separation of concerns, with each command residing in its own module under `src/cli/commands`. This makes the CLI easy to maintain and extend.
- **Direct TypeScript Execution**: Powered by Bun, the CLI can execute `.ts` grammar files directly, eliminating the need for a separate build step.
- **Automatic Runtimes**: It gracefully falls back to Node.js for `.js` files, so you can use the toolkit in any JavaScript environment.
- **Smart Grammar Loading**: The CLI automatically detects and loads the correct grammar export from a file, whether it's a default export, a named `grammar` export, or another named export you specify.

### Workflow Example

The refactored CLI streamlines the grammar development workflow:

1. **Write your grammar** in a TypeScript file (`my-grammar.ts`).
2. **Generate the grammar file** directly from the source:
   ```bash
   bunx tmt emit my-grammar.ts -o mylang.tmLanguage.json
   ```
3. **Run tests** against your source file or the generated grammar:
   ```bash
   bunx tmt test 'tests/**/*.test.lang' -g mylang.tmLanguage.json
   ```
4. **Iterate quickly**. Since there's no build step, you can make changes and re-run commands instantly.

This architecture is designed to reduce friction and keep you focused on what matters: building a high-quality grammar. 
```

### docs/textmate-scopes.md

```markdown
# TextMate Scope Naming Conventions

A practical guide to scope naming for tmLanguage files. This covers the conventions used by TextMate, Sublime Text, VS Code, and other editors that support TextMate grammars.

## Understanding Scopes

Scopes are hierarchical, dot-separated strings that identify code elements. They flow from general to specific, enabling powerful contextual features such as syntax highlighting, intelligent code completion, and context-aware key bindings.

**Example breakdown:**
~~~
keyword.control.conditional.php
│       │       │           │
│       │       │           └── Language
│       │       └─────────────── Specific keyword type
│       └─────────────────────── Category of control
└─────────────────────────────── Root scope
~~~

This hierarchy enables **cascading styles** – if a theme doesn't define `keyword.control.conditional.php`, it falls back to `keyword.control.conditional`, then `keyword.control`, and finally to `keyword`.

**Key principles:**
- Always end with the language name (e.g., `.python`, `.javascript`)
- Reuse existing sub-types rather than inventing new ones
- Choose scopes based on meaning, not just appearance
- Spread elements across different root categories for better theme support

## Scope Categories

### `comment`

Comments are non-executable text. Use specific variants for better tooling support.

- `comment.line` - Single-line comments
  - `double-slash` - `// comment`
  - `double-dash` - `-- comment`  
  - `number-sign` - `# comment`
  - `percentage` - `% comment`
- `comment.block` - Multi-line comments
  - `documentation` - JSDoc, PHPDoc, etc.

Apply `punctuation.definition.comment` to comment delimiters (`//`, `/*`, `*/`). Use `meta.toc-list` for section headers that should appear in symbol lists.

### `constant`

Fixed values including literals, language constants, and escape sequences. Distinguish between user-defined constants (`entity.name.constant`) and literal values.

- `constant.numeric` - All numeric literals
  - `integer` - Integer values
    - `binary` - Binary integers (`0b1010`)
    - `octal` - Octal integers (`0o777`)
    - `decimal` - Decimal integers (`42`)
    - `hexadecimal` - Hex integers (`0xFF`)
    - `other` - Other integer formats
  - `float` - Floating-point values
    - `binary` - Binary floats
    - `octal` - Octal floats
    - `decimal` - Decimal floats (`3.14`)
    - `hexadecimal` - Hex floats (`0x1.5p3`)
    - `other` - Other float formats
  - `complex` - Complex numbers
    - `real` - Real part
    - `imaginary` - Imaginary part
- `constant.character.escape` - Escape sequences (`\\n`, `\\t`, `\\u0041`)
- `constant.language` - Built-in constants (`true`, `false`, `nil`, `undefined`)
- `constant.other.placeholder` - Format placeholders (`%s`, `{0}`)
- `constant.other` - Other constants (CSS colors, symbols)

### `entity`

Names of data structures, types, and uniquely-identifiable constructs. **Avoid** `entity.name.type.class` and `entity.name.type.struct` - use specific terminology instead.

The entity scopes target the **names** only, not entire constructs (use `meta.*` for that). Notable exceptions are `entity.name.tag` and `entity.other.attribute-name` for HTML/XML.

- `entity.name.class` - Class names
- `entity.name.struct` - Struct names  
- `entity.name.enum` - Enumeration names
- `entity.name.union` - Union names
- `entity.name.trait` - Trait names
- `entity.name.interface` - Interface names
- `entity.name.impl` - Implementation names
- `entity.name.type` - Generic type names
- `entity.name.function` - Function names (when defined)
  - `constructor` - Constructor names
  - `destructor` - Destructor names
- `entity.name.namespace` - Namespace/module/package names
- `entity.name.constant` - Named constants (vs `variable.other.constant`)
- `entity.name.label` - Labels for goto statements
- `entity.name.section` - Section/heading names in markup
- `entity.name.tag` - HTML/XML tag names (only `entity.name` scope applied to repeated constructs)
- `entity.other.inherited-class` - Superclass/baseclass names
- `entity.other.attribute-name` - HTML/XML attribute names

**Forward declarations:** Use `.forward-decl` variants (e.g., `entity.name.class.forward-decl`) to exclude from symbol lists and indexing.

### `invalid`

Invalid or deprecated code. Use sparingly to avoid unpleasant highlighting.

- `invalid.illegal` - Syntax errors, illegal characters
- `invalid.deprecated` - Deprecated features (use very rarely)

### `keyword`

Reserved words and operators with special language meaning.

- `keyword.control` - Control flow keywords
  - `conditional` - Conditional keywords (`if`, `else`)
  - `import` - Import/include keywords
- `keyword.operator` - Operators
  - `assignment` - Assignment operators
  - `arithmetic` - Math operators
  - `bitwise` - Bitwise operators
  - `logical` - Logical operators
  - `word` - Word operators (`and`, `or`, `not`)
- `keyword.declaration` - Declaration keywords (see `storage` section for combined usage)
  - `function` - Function declaration keywords
  - `class` - Class declaration keywords
  - `struct` - Struct declaration keywords
  - `enum` - Enum declaration keywords
  - `union` - Union declaration keywords
  - `trait` - Trait declaration keywords
  - `interface` - Interface declaration keywords
  - `impl` - Implementation declaration keywords
  - `type` - Type declaration keywords
- `keyword.other` - Other keywords

Apply `punctuation.definition.keyword` to punctuation within keywords (e.g., `@` in CSS).

### `markup`

Content markup in documentation and markup languages. Use for content formatting, not code syntax.

- `markup.heading` - Section headings
- `markup.list.unnumbered` - Bullet lists
- `markup.list.numbered` - Numbered lists
- `markup.bold` - Bold text
- `markup.italic` - Italic text
- `markup.underline` - Underlined text
  - `link` - Links (inherits underline styling)
- `markup.inserted` - Inserted content (diff)
- `markup.deleted` - Deleted content (diff)
- `markup.quote` - Blockquotes
- `markup.raw.inline` - Inline code
- `markup.raw.block` - Code blocks (disables spell checking)
- `markup.other` - Other markup constructs

### `meta`

Structural sections for larger code constructs. **Not intended for styling** - used by preferences and plugins for contextual behavior.

**Critical:** Never stack meta scopes of the same type. For example, `meta.function.php meta.function.parameters.php` should never occur - alternate between different meta scopes.

- `meta.class` - Complete class definitions
- `meta.struct` - Complete struct definitions
- `meta.enum` - Complete enum definitions
- `meta.union` - Complete union definitions
- `meta.trait` - Complete trait definitions
- `meta.interface` - Complete interface definitions
- `meta.impl` - Complete implementation definitions
- `meta.type` - Complete type definitions
- `meta.function` - Complete function definitions
  - `parameters` - Parameter lists
  - `return-type` - Return type annotations
- `meta.namespace` - Namespace/module definitions
- `meta.preprocessor` - Preprocessor statements
- `meta.annotation` - Annotations/decorators
  - `identifier` - Annotation names
  - `parameters` - Annotation parameters
- `meta.path` - Qualified identifiers
- `meta.function-call` - Function invocations
- `meta.block` - Code blocks `{}`
- `meta.braces` - Alternative for curly braces
- `meta.group` - Grouped expressions `()`
- `meta.parens` - Alternative for parentheses
- `meta.brackets` - Bracket expressions `[]`
- `meta.generic` - Generic type parameters `<>`
- `meta.tag` - Complete HTML/XML tags
- `meta.paragraph` - Paragraphs in markup
- `meta.string` - Complete string literals
- `meta.interpolation` - String interpolation
- `meta.toc-list` - Table of contents entries

### `punctuation`

Structural and syntactic punctuation. Use specific subtypes for precise editor behavior.

- `punctuation.separator` - Commas, colons
  - `continuation` - Line continuation characters
- `punctuation.terminator` - Semicolons, statement terminators
- `punctuation.accessor` - Member access (`.`, `->`, `::`)
- `punctuation.definition` - Punctuation that defines other scopes
  - `comment` - Comment delimiters
  - `string.begin` / `string.end` - String quotes
  - `keyword` - Keyword punctuation
  - `variable` - Variable symbols (`$` in PHP)
  - `annotation` - Annotation symbols
  - `generic.begin` / `generic.end` - Generic delimiters `<>`
- `punctuation.section` - Section delimiters
  - `block.begin` / `block.end` - Block delimiters `{}`
  - `group.begin` / `group.end` - Group delimiters `()`
  - `parens.begin` / `parens.end` - Alternative for parentheses
  - `brackets.begin` / `brackets.end` - Bracket delimiters `[]`
  - `braces.begin` / `braces.end` - Alternative for curly braces
  - `interpolation.begin` / `interpolation.end` - Interpolation delimiters

### `source` and `text`

Root scopes for different document types:
- `source` - Programming languages and executable code
- `text` - Content and markup (disables many code features)
  - `text.html` - HTML documents (variants like `text.html.markdown`)
  - `text.xml` - XML documents

### `storage`

Keywords affecting how variables, functions, or data structures are stored or accessed.

- `storage.type` - Type keywords (`int`, `bool`, `char`)
  - `function` - Function keywords (`def`, `function`) + `keyword.declaration.function`
  - `class` - Class keywords (`class`) + `keyword.declaration.class`
  - `struct` - Struct keywords + `keyword.declaration.struct`
  - `enum` - Enum keywords + `keyword.declaration.enum`
  - `union` - Union keywords + `keyword.declaration.union`
  - `trait` - Trait keywords + `keyword.declaration.trait`
  - `interface` - Interface keywords + `keyword.declaration.interface`
  - `impl` - Implementation keywords + `keyword.declaration.impl`
- `storage.modifier` - Storage modifiers (`static`, `const`, `public`, `private`)

**Note:** Declaration keywords should use both `storage.type.*` and `keyword.declaration.*` for backward compatibility.

### `string`

String literals and related constructs. Use `meta.string` for entire strings including punctuation.

- `string.quoted.single` - Single-quoted strings
- `string.quoted.double` - Double-quoted strings
- `string.quoted.triple` - Triple-quoted strings
- `string.quoted.other` - Other quoting styles
- `string.unquoted` - Unquoted strings (`shell`, `batch`)
- `string.regexp` - Regular expression literals

**String interpolation pattern:**
```
meta.string
  punctuation.definition.string.begin
  meta.interpolation
    punctuation.section.interpolation.begin
    source.language.embedded
    punctuation.section.interpolation.end
  punctuation.definition.string.end
```

When strings contain interpolated code, remove the `string.*` scope using `clear_scopes:` and apply `meta.interpolation` to the entire interpolation including punctuation.

### `support`

Elements provided by frameworks, libraries, and language runtimes (as opposed to user-defined elements).

- `support.function` - Library functions (`console.log`, `NSLog`)
- `support.class` - Library classes
- `support.type` - Library types
- `support.constant` - Library constants
- `support.module` - Library modules
- `support.variable` - Library variables

Many syntaxes also apply these to unrecognized user constructs, effectively scoping all user-defined elements.

### `variable`

Variable names and identifiers representing mutable data.

- `variable.other` - Generic variables
  - `readwrite` - Mutable variables
  - `constant` - Immutable variables
  - `member` - Object properties/fields
- `variable.language` - Language-reserved variables (`this`, `self`, `super`)
- `variable.parameter` - Function parameters
- `variable.function` - Function names (when called, not defined)
- `variable.annotation` - Annotation identifiers

Apply `punctuation.definition.variable` to variable prefixes like `$` in PHP.

## Color Scheme Guidelines

### Essential Scopes for Themes

Target these scopes for broad compatibility:

- `entity.name` (with overrides for `entity.name.tag` and `entity.name.section`)
- `entity.other.inherited-class`
- `variable` (with specific variants)
- `constant` (with specific variants)
- `storage.type` and `storage.modifier`
- `support`
- `keyword` (with specific variants)
- `string`
- `comment`
- `invalid`

### Best Practices

- Style general scopes first, then override specific ones
- Avoid styling `meta` scopes - they're for structural information
- Use scope inheritance - specific scopes inherit from general ones

## Common Decision Points

**Definition vs Usage:**
- Function definition: `entity.name.function`
- Function call: `variable.function`

**Constants vs Variables:**
- Named constants: `entity.name.constant` (appears in symbol list)
- Immutable variables: `variable.other.constant` (doesn't appear in symbol list)

**Framework vs User Code:**
- Library functions: `support.function`
- User-defined functions: `entity.name.function`

This guide covers the semantic foundation for creating consistent tmLanguage files that work well with existing themes and editor features. 
```

### docs/troubleshooting.md

```markdown
# Troubleshooting Guide

Common issues and solutions when working with the TextMate Toolkit.

## Build and Compilation Issues

### TypeScript Compilation Errors

**Problem**: TypeScript compilation fails when importing the toolkit

**Solution**: Ensure you have compatible TypeScript settings

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "strict": true
  }
}
```

**Problem**: Cannot find module declarations

**Solution**: Install type dependencies
```bash
npm install --save-dev @types/node
```

### Import/Export Issues

**Problem**: `Cannot find module 'tmgrammar-toolkit/testing'`

**Solution**: Check your import paths and ensure submodule exports are correct
```typescript
// ✅ Correct
import { createTesterFromFile } from 'tmgrammar-toolkit/testing';
import { scopes } from 'tmgrammar-toolkit';

// ❌ Incorrect  
import { createTesterFromFile } from 'tmgrammar-toolkit/src/testing';
```

## Grammar Definition Issues

### Regex Pattern Problems

**Problem**: Regex patterns not matching expected text

**Common Causes & Solutions**:

1. **Escaping Issues**
   ```typescript
   // ❌ Wrong - not enough escaping
   match: "\b(function)\b"
   
   // ✅ Right - proper escaping
   match: "\\b(function)\\b"
   
   // ✅ Best - use helpers
   match: regex.bounded('function')
   ```

2. **Case Sensitivity**
   ```typescript
   // ❌ Won't match "Function" or "FUNCTION"
   match: /function/
   
   // ✅ Case insensitive
   match: /function/i
   
   // ✅ Using helpers
   match: regex.caseInsensitive('function')
   ```

3. **Anchoring Issues**
   ```typescript
   // ❌ Matches anywhere in string
   match: /if/
   
   // ✅ Word boundaries
   match: /\bif\b/
   
   // ✅ Using helpers
   match: regex.keywords(['if'])
   ```

**Problem**: Oniguruma regex validation fails

**Solution**: Use the validation API to debug patterns
```typescript
import { validateRegex } from 'tmgrammar-toolkit/validation';

const result = await validateRegex('\\b(if|else)\\b');
if (!result.valid) {
  console.error(`Invalid regex: ${result.error}`);
  // Common fixes:
  // - Check escape sequences
  // - Verify character classes
  // - Test lookbehind/lookahead syntax
}
```

### Repository Key Conflicts

**Problem**: `Error: Duplicate repository key 'string'`

**Solution**: Ensure all rule keys are unique across your grammar
```typescript
// ❌ Duplicate keys
const singleQuotedString = { key: 'string', /* ... */ };
const doubleQuotedString = { key: 'string', /* ... */ };

// ✅ Unique keys
const singleQuotedString = { key: 'string-single', /* ... */ };
const doubleQuotedString = { key: 'string-double', /* ... */ };
```

### Scope Naming Issues

**Problem**: Editor not applying correct highlighting

**Common Causes**:

1. **Typos in scope names**
   ```typescript
   // ❌ Typo in scope name
   scope: 'keyword.controll.conditional'
   
   // ✅ Use scopes API to prevent typos
   scope: scopes.keyword.control.conditional
   ```

2. **Non-standard scope names**
   ```typescript
   // ❌ Non-standard scope
   scope: 'my.custom.scope'
   
   // ✅ Standard TextMate scope
   scope: scopes.keyword.control
   ```

3. **Missing language suffix**
   ```typescript
   // ❌ Generic scope (might conflict)
   scope: 'keyword.control'
   
   // ✅ Language-specific scope with scopesFor
   const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });
   scope: scopes.keyword.control
   ```

### Scope Issues

If your scopes aren't being highlighted correctly:

```typescript
// ❌ Typo in scope name
scope: scopes.keyword.control

// ✅ Use proper scope hierarchy
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });
scope: scopes.keyword.control
```

## Pattern Matching Issues

### Patterns Not Matching

**Problem**: Your patterns aren't matching the expected code

**Debugging Steps**:

1. **Test patterns in isolation**
   ```typescript
   import { validateRegex } from 'tmgrammar-toolkit/validation';
   
   const pattern = /\b(if|else|while)\b/;
   const testString = 'if (condition)';
   
   console.log(pattern.test(testString)); // Should be true
   ```

2. **Use the testing API to debug**
   ```typescript
   import { createTesterFromContent } from 'tmgrammar-toolkit/testing';
   
   const tester = createTesterFromContent(myGrammar, 'source.mylang');
   const tokens = await tester.tokenize('if (condition)');
   
   // Print all tokens to see what's being matched
   tokens.forEach((token, i) => {
     console.log(`Token ${i}: "${token.content}" -> ${token.scope.join('.')}`);
   });
   ```

### Pattern Order Issues

**Problem**: Wrong patterns are matching first

**Solution**: Order patterns from most specific to most general
```typescript
// ❌ General pattern matches before specific one
patterns: [
  { key: 'keyword', match: /\w+/, scope: 'keyword' },
  { key: 'function-keyword', match: /function/, scope: 'keyword.declaration' }
]

// ✅ Specific pattern first
patterns: [
  { key: 'function-keyword', match: /function/, scope: 'keyword.declaration' },
  { key: 'keyword', match: /\w+/, scope: 'keyword' }
]
```

### Performance Issues

**Problem**: Grammar causes slow syntax highlighting

**Common Causes & Solutions**:

1. **Expensive regex patterns**
   ```typescript
   // ❌ Catastrophic backtracking
   match: /(a+)+b/
   
   // ✅ Atomic grouping
   match: /(?>a+)+b/
   ```

2. **Excessive lookahead/lookbehind**
   ```typescript
   // ❌ Expensive
   match: /(?<=\w)\.(?=\w)/
   
   // ✅ Simpler alternative
   match: /\w\.\w/
   ```

3. **Too many patterns**
   ```typescript
   // ❌ Many individual rules
   patterns: [
     { key: 'if', match: /if/, scope: 'keyword' },
     { key: 'else', match: /else/, scope: 'keyword' },
     // ... 50 more
   ]
   
   // ✅ Combined rule
   patterns: [
     { 
       key: 'keywords', 
       match: regex.keywords(['if', 'else', /* ... */]), 
       scope: 'keyword' 
     }
   ]
   ```

## Testing Issues

### Test Failures

**Problem**: `expectTokenScope` assertions fail

**Debugging Steps**:

1. **Check actual token scopes**
   ```typescript
   const tokens = await tester.tokenize('if (condition)');
   const ifToken = tokens.find(t => t.content === 'if');
   console.log('Actual scopes:', ifToken?.scope);
   console.log('Expected:', 'keyword.control.mylang');
   ```

2. **Verify token content**
   ```typescript
   // Make sure you're checking the right token content
   tester.expectTokenScope(tokens, 'if', 'keyword.control.mylang');
   // Not: tester.expectTokenScope(tokens, 'IF', '...');
   ```

3. **Check scope hierarchy**
   ```typescript
   // Token might have multiple scopes
   // ['source.mylang', 'keyword.control.mylang']
   // Test for the most specific one
   ```

### Snapshot Test Issues

**Problem**: Snapshot tests always failing

**Solution**: Update snapshots when grammar changes are intentional
```bash
# Update all snapshots
npx tmt snap 'tests/**/*.mylang' --update

# Update specific test
npx tmt snap 'tests/keywords.test.mylang' --update
```

## CLI Debugging

### Command Issues

**Problem**: A CLI command is not behaving as expected.

**Solutions**:

1.  **Isolate the Command**: Since each command is a module, you can test it in isolation. Look in `src/cli/commands` to find the relevant command file.
2.  **Check Argument Parsing**: Ensure that the arguments and options you are passing on the command line are correctly defined and parsed in the command's file. The `commander` package handles this, so check the `.argument()` and `.option()` calls.
3.  **Verify Utility Functions**: Many commands use helpers from `src/cli/utils`. Check these functions (`loadGrammarFromFile`, etc.) to see if the issue lies there.
4.  **Run with Verbosity**: Add `console.log` statements within the command's action to trace its execution and inspect the values of variables.

### File Path Issues

**Problem**: `Cannot find file 'grammar.ts'`

**Solutions**:

1.  **Check Working Directory**: Make sure you are running the `tmt` command from the root of your project.
    ```bash
    pwd
    ls -la grammar.ts
    ```
2.  **Use Relative or Absolute Paths**: The CLI should handle both, but if you're having trouble, try providing a full path to the file.
3.  **Check File Extensions**: Ensure you're including the correct file extension (`.ts`, `.js`, etc.) in the command.

## Editor Integration Issues

### VS Code Not Recognizing Grammar

**Problem**: VS Code doesn't use your grammar for syntax highlighting

**Solutions**:

1. **Check file association**
   ```json
   // In your extension's package.json
   {
     "contributes": {
       "languages": [{
         "id": "mylang",
         "extensions": [".mylang", ".ml"],
         "configuration": "./language-configuration.json"
       }],
       "grammars": [{
         "language": "mylang",
         "scopeName": "source.mylang",
         "path": "./syntaxes/mylang.tmLanguage.json"
       }]
     }
   }
   ```

2. **Verify scope name matches**
   ```typescript
   // In your grammar
   const grammar = createGrammar('MyLang', 'source.mylang', ['mylang']);
   
   // Must match the scopeName in package.json
   ```

3. **Reload VS Code**
   - Press `Ctrl+Shift+P` (or `Cmd+Shift+P`)
   - Type "Developer: Reload Window"

### Incorrect Highlighting

**Problem**: Some tokens have wrong colors

**Debugging Steps**:

1. **Check scope inspector**
   - Press `Ctrl+Shift+P`
   - Type "Developer: Inspect Editor Tokens and Scopes"
   - Click on problematic tokens

2. **Verify theme support**
   ```typescript
   // Some themes might not support all scopes
   // Use common scopes for better compatibility
   scope: scopes.keyword.control  // Well-supported
   // vs
   scope: scopes.keyword.control.loop.for  // Might not be themed
   ```

## Common Error Messages

### "Invalid regular expression"

**Cause**: Regex syntax error
**Solution**: Use regex validation
```typescript
import { validateRegex } from 'tmgrammar-toolkit/validation';
const result = await validateRegex(yourPattern);
```

### "Cannot resolve include"

**Cause**: Including non-existent repository key
**Solution**: Check repository key names
```typescript
// ❌ Key doesn't exist
{ include: '#non-existent-key' }

// ✅ Valid repository key
{ include: '#existing-pattern' }
```

### "Circular reference detected"

**Cause**: Patterns referencing each other in a loop
**Solution**: Restructure pattern hierarchy
```typescript
// ❌ Circular reference
const patternA = { key: 'a', patterns: [{ include: '#b' }] };
const patternB = { key: 'b', patterns: [{ include: '#a' }] };

// ✅ Hierarchical structure
const patternA = { key: 'a', patterns: [patternB] };
const patternB = { key: 'b', match: /some-pattern/ };
```

## Getting Help

If you're still experiencing issues:

1. **Check the Examples**: Look at complete grammar implementations in `examples/`
2. **Read the API Reference**: Detailed documentation in `docs/api-reference.md`
3. **Use Validation Tools**: Run validation on your patterns and grammar
4. **Create Minimal Reproduction**: Isolate the problem to the smallest possible case
5. **Check GitHub Issues**: Search for similar issues in the repository

## Performance Optimization

### Profiling Your Grammar

```typescript
// Time tokenization performance
const start = performance.now();
const tokens = await tester.tokenize(largeCodeSample);
const time = performance.now() - start;
console.log(`Tokenized ${largeCodeSample.length} chars in ${time}ms`);
```

### Optimization Strategies

1. **Combine similar patterns**
2. **Use atomic groups for non-backtracking patterns**
3. **Avoid deep nesting of begin/end rules**
4. **Profile with realistic code samples**
5. **Use character classes instead of alternation when possible**

Remember: Most issues stem from regex patterns, scope naming, or pattern ordering. The validation and testing APIs are your best tools for debugging! 🔧 
```

### docs/using-scopes.md

```markdown
# Using Scopes in TMGrammar Toolkit

The TMGrammar Toolkit provides a powerful, type-safe scope system for creating TextMate grammars. This guide covers all the ways you can use scopes in your projects.

## Quick Start

The most common pattern is to create static scopes with a language suffix:

```typescript
import { scopesFor } from 'tmgrammar-toolkit';

// Create static scopes for your language (recommended)
const myScopes = scopesFor({ 
  suffix: 'mylang', 
  allowScopeExtension: false 
});

// Use in your grammar rules
const keywordRule = {
  name: myScopes.keyword.control.conditional,  // "keyword.control.conditional.mylang"
  match: /\b(if|else|for|while)\b/
};
```

## Scope Patterns

### 1. Static Scopes (Recommended)

Static scopes provide the best performance and are recommended for production grammars:

```typescript
const staticScopes = scopesFor({ 
  suffix: 'typescript', 
  allowScopeExtension: false 
});

// These return string values directly
console.log(staticScopes.keyword.control.conditional); // "keyword.control.conditional.typescript"
console.log(staticScopes.string.quoted.double); // "string.quoted.double.typescript"

// Perfect for template literals
const rule = `${staticScopes.comment.line.double_slash}`; // "comment.line.double-slash.typescript"

// Not callable (optimized for performance)
// staticScopes.keyword.control.conditional('extra'); // ❌ TypeError
```

**Benefits:**
- Best performance (no function call overhead)
- Smaller bundle size
- Easier for bundlers to optimize
- Clear, predictable behavior

### 2. Callable Scopes

Callable scopes allow dynamic extension with additional suffixes:

```typescript
const callableScopes = scopesFor({ 
  suffix: 'javascript', 
  allowScopeExtension: true 
});

// Base usage
console.log(callableScopes.keyword.control.conditional); // "keyword.control.conditional.javascript"

// Dynamic extension
console.log(callableScopes.keyword.control.conditional('async')); // "keyword.control.conditional.javascript.async"
console.log(callableScopes.string.quoted.double('template')); // "string.quoted.double.javascript.template"
```

**Use cases:**
- Grammar extensions or plugins
- Development and testing
- When you need runtime flexibility

### 3. On-Leafs Extension Mode

Only leaf nodes (terminal scopes) are callable, branch nodes are static:

```typescript
const leafScopes = scopesFor({ 
  suffix: 'python', 
  allowScopeExtension: 'on-leafs' 
});

// Leaf nodes are callable
console.log(leafScopes.keyword.control.conditional('comprehension')); // "keyword.control.conditional.python.comprehension"

// Branch nodes are not callable
console.log(leafScopes.keyword.control); // "keyword.control.python" (not callable)
// leafScopes.keyword.control('extra'); // ❌ TypeError
```

**Benefits:**
- Balance between performance and flexibility
- Prevents accidental extension of intermediate scopes
- Clear distinction between terminal and intermediate scopes

## Custom Scope Definitions

You can extend the base TextMate scopes with your own custom definitions:

```typescript
const customScopes = scopesFor({ 
  suffix: 'rcl', 
  allowScopeExtension: false 
}, {
  // Custom meta scopes for your language
  meta: {
    section: {
      agent: null,
      messages: null,
      flows: null
    },
    embedded: {
      expression: null,
      code: null
    }
  },
  // Custom source scopes
  source: {
    rcl: {
      import: null,
      section_header: null
    }
  }
});

// Use custom scopes
console.log(customScopes.meta.section.agent); // "meta.section.agent.rcl"
console.log(customScopes.source.rcl.import); // "source.rcl.import.rcl"

// Base scopes are still available
console.log(customScopes.keyword.control.conditional); // "keyword.control.conditional.rcl"
```

## Advanced Configuration

### Prefix for Embedded Languages

Use prefixes when creating scopes for embedded languages:

```typescript
const embeddedScopes = scopesFor({ 
  prefix: 'source.html.embedded',
  suffix: 'javascript',
  allowScopeExtension: false 
});

console.log(embeddedScopes.keyword.control.conditional); 
// "source.html.embedded.keyword.control.conditional.javascript"
```

### No Suffix (Base Scopes)

Create scopes without language suffixes:

```typescript
const baseScopes = scopesFor({ 
  allowScopeExtension: false 
});

console.log(baseScopes.keyword.control.conditional); // "keyword.control.conditional"
```

## Predefined Scopes

The toolkit provides predefined scopes that are always callable:

```typescript
import { scopes } from 'tmgrammar-toolkit';

// Global scopes (always callable)
console.log(scopes.keyword.control.conditional); // "keyword.control.conditional"
console.log(scopes.keyword.control.conditional('js')); // "keyword.control.conditional.js"

// Snake_case to kebab-case conversion
console.log(scopes.comment.line.double_slash); // "comment.line.double-slash"
console.log(scopes.entity.name.class.forward_decl); // "entity.name.class.forward-decl"
```

## Type Safety Features

The scope system provides full TypeScript support:

### Compile-time Type Checking

```typescript
const myScopes = scopesFor({ suffix: 'lang', allowScopeExtension: false });

// ✅ Valid scope paths
myScopes.keyword.control.conditional;
myScopes.string.quoted.double;
myScopes.comment.line.double_slash;

// ❌ Invalid scope paths (TypeScript errors)
// myScopes.invalid.path.here;
// myScopes.keyword.invalid.property;
```

### Autocomplete and IntelliSense

Your editor will provide full autocomplete for all scope properties:

- `myScopes.keyword.` → shows `control`, `operator`, `other`
- `myScopes.keyword.control.` → shows `conditional`, `exception`, `flow`, etc.
- `myScopes.string.quoted.` → shows `single`, `double`, `triple`

### Hover Documentation

Hover over any scope to see its full path and type information.

## Best Practices

### 1. Prefer Static Scopes

Use static scopes unless you specifically need dynamic extension:

```typescript
// ✅ Recommended for production
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });

// ⚠️ Only when needed
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: true });
```

### 2. Use Descriptive Suffixes

Choose clear, standard language identifiers:

```typescript
// ✅ Good
scopesFor({ suffix: 'typescript' })
scopesFor({ suffix: 'python' })
scopesFor({ suffix: 'rust' })

// ❌ Avoid
scopesFor({ suffix: 'ts' })
scopesFor({ suffix: 'py' })
scopesFor({ suffix: 'rs' })
```

### 3. Organize Custom Scopes Logically

Group related custom scopes under appropriate categories:

```typescript
const scopes = scopesFor({ suffix: 'mylang' }, {
  meta: {
    // Language structure scopes
    section: { header: null, body: null },
    block: { begin: null, end: null }
  },
  entity: {
    // Custom entity types
    name: { 
      custom_type: null,
      special_identifier: null 
    }
  }
});
```

### 4. Follow TextMate Naming Conventions

Stick to established TextMate scope naming patterns:

- `keyword.control.*` for control flow keywords
- `string.quoted.*` for string literals
- `comment.line.*` for line comments
- `entity.name.*` for identifiers and names
- `constant.numeric.*` for numeric literals

See the [TextMate scope naming conventions](https://macromates.com/manual/en/language_grammars#naming_conventions) for complete guidelines.

## Performance Considerations

### Static vs Callable Scopes

| Pattern | Performance | Flexibility | Use Case |
|---------|-------------|-------------|----------|
| Static (`false`) | ⭐⭐⭐⭐⭐ | ⭐⭐ | Production grammars |
| On-leafs (`"on-leafs"`) | ⭐⭐⭐⭐ | ⭐⭐⭐ | Balanced approach |
| Callable (`true`) | ⭐⭐⭐ | ⭐⭐⭐⭐⭐ | Development/extensible |

### Bundle Size Impact

Static scopes result in smaller bundles because:
- No function objects are created
- Better tree-shaking opportunities
- Simpler object structures

## Migration Guide

If you're updating from an older version:

### Old Pattern
```typescript
// Old complex API
const scopes = scopesFor('mylang');
const customScopes = scopesFor({ suffix: 'mylang' }, { custom: { token: null } });
```

### New Pattern
```typescript
// New simplified API
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });
const customScopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false }, { 
  custom: { token: null } 
});
```

The new API is more explicit about extension behavior and provides better performance defaults.

## Examples

Check out these complete examples:

- [Simple Example](../examples/simple-example.ts) - Basic static scopes usage
- [Features Demo](../examples/scope-features-demo.ts) - Comprehensive feature showcase
- [Bicep Language](../examples/tmgrammar-toolkit/bicep.ts) - Real-world language example
- [TypeSpec Language](../examples/tmgrammar-toolkit/typespec.ts) - Another real-world example

## Further Reading

- [TMGrammar Toolkit API Reference](./api-reference.md)
- [TextMate Language Grammars](https://macromates.com/manual/en/language_grammars)
- [VSCode Syntax Highlighting Guide](https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide) 
```


## Source Code

### src/ambient.d.ts

```ts
/**
 * TypeScript declarations for in-file testing with Bun
 */

declare global {
  namespace ImportMeta {
    /**
     * When true, includes in-file tests. Set via --define import.meta.TEST=true
     * When false or undefined, test code is eliminated via dead code elimination
     */
    const TEST: boolean;
  }
}

export {}; 
```

### src/cli.ts

```ts
/**
 * This file is the entry point for the TextMate Toolkit CLI.
 * It has been refactored to delegate all command handling to the `src/cli` directory.
 * This modular approach improves maintainability and separation of concerns.
 *
 * To add a new command, create a file in `src/cli/commands` and export a function
 * that returns a `commander.Command` instance. Then, add it to the main `program`
 * in `src/cli/index.ts`.
 *
 * For more details, see the architecture documentation in `src/README.md`.
 */
import "./cli/index.js"; 
```

### src/cli/commands/emit.ts

```ts
import { Command } from "commander";
import { writeFile as writeFileAsync } from "node:fs/promises";
import { emitJSON, emitPList, emitYAML } from "../../emit.js";
import { loadGrammarFromFile } from "../utils/grammar.js";
import { processGrammar } from "../../validation/grammar.js";
import { isError } from "../../result.js";

export function createEmitCommand(): Command {
  const emitCommand = new Command("emit")
    .description("Emit a TextMate grammar from a TypeScript file")
    .argument("<ts-file>", "Path to TypeScript file containing grammar")
    .argument(
      '[export-name]',
      'Name of export (defaults to "default" then "grammar")',
    )
    .option("-o, --output <file>", "Output file path (defaults to stdout)")
    .option("--json", "Emit JSON format (default)")
    .option("--plist", "Emit PList XML format")
    .option("--yaml", "Emit YAML format")
    .option("--all", "Emit all formats")
    .action(
      async (
        tsFile: string,
        exportName?: string,
        options?: {
          output?: string;
          json?: boolean;
          plist?: boolean;
          yaml?: boolean;
          all?: boolean;
        },
      ) => {
        try {
          // Load and validate grammar
          const grammarInput = await loadGrammarFromFile(tsFile, exportName);
          const processResult = processGrammar(grammarInput, tsFile);

          if (isError(processResult)) {
            const errorMessage = processResult.error instanceof Error && 'getFormattedMessage' in processResult.error
              ? (processResult.error as any).getFormattedMessage()
              : processResult.error.message || String(processResult.error);
            console.error("❌ Grammar validation failed:");
            console.error(errorMessage);
            process.exit(1);
          }

          const processedGrammar = processResult.value;

          // Determine output formats
          const formats: Array<{ name: string; extension: string; emitter: typeof emitJSON }> = [];
          
          if (options?.all) {
            formats.push(
              { name: 'JSON', extension: '.tmLanguage.json', emitter: emitJSON },
              { name: 'PList', extension: '.tmLanguage', emitter: emitPList },
              { name: 'YAML', extension: '.tmLanguage.yaml', emitter: emitYAML }
            );
          } else {
            // Default to JSON if no format specified
            if (!options?.json && !options?.plist && !options?.yaml) {
              options = { ...options, json: true };
            }
            
            if (options?.json) {
              formats.push({ name: 'JSON', extension: '.tmLanguage.json', emitter: emitJSON });
            }
            if (options?.plist) {
              formats.push({ name: 'PList', extension: '.tmLanguage', emitter: emitPList });
            }
            if (options?.yaml) {
              formats.push({ name: 'YAML', extension: '.tmLanguage.yaml', emitter: emitYAML });
            }
          }

          // Emit each format
          for (const format of formats) {
            const emitResult = await format.emitter(processedGrammar);
            
            if (isError(emitResult)) {
              console.error(`❌ Failed to emit ${format.name} format: ${emitResult.error}`);
              process.exit(1);
            }

            const output = emitResult.value;

            // Determine output file path
            let outputPath: string | undefined;
            if (options?.output) {
              if (formats.length === 1) {
                outputPath = options.output;
              } else {
                // Multiple formats - append extension
                const baseName = options.output.replace(/\.[^.]*$/, '');
                outputPath = baseName + format.extension;
              }
            }

            // Output to file or stdout
            if (outputPath) {
              await writeFileAsync(outputPath, output, "utf-8");
              console.log(`✅ ${format.name} grammar written to ${outputPath}`);
            } else {
              if (formats.length > 1) {
                console.log(`\n--- ${format.name} ---`);
              }
              console.log(output);
            }
          }
        } catch (error) {
          console.error(
            "❌ Error:",
            error instanceof Error ? error.message : String(error),
          );
          process.exit(1);
        }
      },
    );

  return emitCommand;
} 
```

### src/cli/commands/index.ts

```ts
export * from "./emit.js";
export * from "./snap.js";
export * from "./test.js";
export * from "./validate.js"; 
```

### src/cli/commands/snap.ts

```ts
import { Command } from "commander";
import { execSync } from "node:child_process";

export function createSnapCommand(): Command {
  const snapCommand = new Command("snap")
    .description("Run grammar snapshot tests using vscode-tmgrammar-snap")
    .argument("<test-files>", "Glob pattern for test files")
    .option("-g, --grammar <file>", "Path to grammar file")
    .option("-c, --config <file>", "Path to language configuration file")
    .option("-u, --update", "Update snapshot files")
    .option("--expand-diff", "Expand diff output")
    .option("--print-not-modified", "Include not modified scopes in output")
    .action(
      (
        testFiles: string,
        options?: {
          grammar?: string;
          config?: string;
          update?: boolean;
          expandDiff?: boolean;
          printNotModified?: boolean;
        },
      ) => {
        try {
          const args = [testFiles];

          if (options?.grammar) {
            args.push("-g", options.grammar);
          }

          if (options?.config) {
            args.push("-c", options.config);
          }

          if (options?.update) {
            args.push("-u");
          }

          if (options?.expandDiff) {
            args.push("--expand-diff");
          }

          if (options?.printNotModified) {
            args.push("--print-not-modified");
          }

          execSync(`vscode-tmgrammar-snap ${args.join(" ")}`, {
            stdio: "inherit",
          });
        } catch (error) {
          console.error("Snapshot command failed");
          process.exit(1);
        }
      },
    );

  return snapCommand;
} 
```

### src/cli/commands/test.ts

```ts
import { Command } from "commander";
import { execSync } from "node:child_process";

export function createTestCommand(): Command {
  const testCommand = new Command("test")
    .description("Run grammar tests using vscode-tmgrammar-test")
    .argument(
      "<test-files>",
      'Glob pattern for test files (e.g., "tests/**/*.test.lang")',
    )
    .option("-g, --grammar <file>", "Path to grammar file")
    .option("-c, --config <file>", "Path to language configuration file")
    .option("--compact", "Display output in compact format")
    .action(
      (
        testFiles: string,
        options?: {
          grammar?: string;
          config?: string;
          compact?: boolean;
        },
      ) => {
        try {
          const args = [testFiles];

          if (options?.grammar) {
            args.push("-g", options.grammar);
          }

          if (options?.config) {
            args.push("-c", options.config);
          }

          if (options?.compact) {
            args.push("--compact");
          }

          execSync(`vscode-tmgrammar-test ${args.join(" ")}`, {
            stdio: "inherit",
          });
        } catch (error) {
          console.error("Test command failed");
          process.exit(1);
        }
      },
    );

  return testCommand;
} 
```

### src/cli/commands/validate.ts

```ts
import { Command } from "commander";
import { processGrammar } from "../../validation/grammar.js";
import { loadGrammarFromFile } from "../utils/grammar.js";
import { readJson } from "../../utils/file.js";
import { isOk } from "../../result.js";

export function createValidateCommand(): Command {
  const validateCommand = new Command("validate")
    .description("Validate a grammar file or TypeScript export")
    .argument(
      "<file>",
      "Path to grammar file (.tmLanguage.json) or TypeScript file",
    )
    .argument("[export-name]", "Export name for TypeScript files")
    .action(async (file: string, exportName?: string) => {
      try {
        let grammarToValidate: any;

        if (file.endsWith(".json")) {
          // Load JSON grammar file
          grammarToValidate = await readJson(file);
        } else {
          // Load from TypeScript file
          grammarToValidate = await loadGrammarFromFile(file, exportName);
        }

        const result = processGrammar(grammarToValidate, file);

        if (isOk(result)) {
          const grammar = result.value;
          console.log("✅ Grammar is valid");
          console.log(`   - Repository items: ${Object.keys(grammar.repository).length}`);
          
          // Show warnings if any
          const warnings = grammar.errors.filter(e => e.severity === 'warning');
          if (warnings.length > 0) {
            console.log("\nWarnings:");
            for (const warning of warnings) {
              const message = 'getFormattedMessage' in warning
                ? (warning as any).getFormattedMessage()
                : warning.message;
              console.log(`  ⚠️  ${message}`);
            }
          }
        } else {
          console.log("❌ Grammar validation failed");
          const message = 'getFormattedMessage' in result.error
            ? (result.error as any).getFormattedMessage()
            : result.error.message || String(result.error);
          console.log(`\nError: ${message}`);
          process.exit(1);
        }
      } catch (error) {
        console.error(
          "Validation failed:",
          error instanceof Error ? error.message : String(error),
        );
        process.exit(1);
      }
    });

  return validateCommand;
} 
```

### src/cli/index.ts

```ts
import { Command } from "commander";
import {
  createEmitCommand,
  createSnapCommand,
  createTestCommand,
  createValidateCommand,
} from "./commands/index.js";

const program = new Command();

program
  .name("tmt")
  .description(
    "TextMate Toolkit CLI - A unified toolkit for TextMate grammar authoring, testing, and validation",
  )
  .version("0.1.0");

program.addCommand(createEmitCommand());
program.addCommand(createTestCommand());
program.addCommand(createSnapCommand());
program.addCommand(createValidateCommand());

program.parse(); 
```

### src/cli/utils/bun.ts

```ts
import { execSync } from "node:child_process";
import { restoreRegexObjects } from "./grammar.js";
import type { GrammarInput, Grammar } from "../../types.js";

/**
 * Checks if Bun runtime is available on the system.
 * Bun provides seamless TypeScript execution without build steps.
 *
 * @returns Promise resolving to true if Bun is available, false otherwise
 * @internal
 */
export async function isBunAvailable(): Promise<boolean> {
  try {
    execSync("bun --version", { stdio: "ignore" });
    return true;
  } catch {
    return false;
  }
}

/**
 * Loads a grammar from a TypeScript file using Bun's runtime.
 * Supports named exports, default exports, and 'grammar' exports.
 *
 * @param filePath - Path to the TypeScript file containing the grammar
 * @param exportName - Optional specific export name to use
 * @returns Promise resolving to the loaded grammar
 * @throws {Error} If the file cannot be loaded or no grammar export is found
 * @internal
 */
export async function loadGrammarWithBun(
  filePath: string,
  exportName?: string,
): Promise<GrammarInput> {
  const escapedPath = filePath.replace(/'/g, "\\'");
  const exportToTry = exportName || "default";

  const script = `
    import { pathToFileURL } from 'node:url';
    try {
      const module = await import(pathToFileURL('${escapedPath}').toString());
      const exportToTry = '${exportToTry}';
      const grammar = module[exportToTry] || module.default || module.grammar;
      
      if (!grammar) {
        const availableExports = Object.keys(module).filter(k => k !== 'default');
        console.error('Error: No grammar found. Available exports: ' + availableExports.join(', '));
        process.exit(1);
      }
      
      console.log(JSON.stringify(grammar, (key, value) => 
        value instanceof RegExp ? { __regex: value.source } : value
      ));
    } catch (error) {
      console.error('Error loading grammar:', error.message);
      process.exit(1);
    }
  `;

  try {
    const result = execSync(`bun -e "${script}"`, {
      encoding: "utf8",
      stdio: ["pipe", "pipe", "inherit"],
    });
    const parsed = JSON.parse(result);
    const restoredGrammar = restoreRegexObjects(parsed);
    
    // Handle Result<Grammar>, Grammar, and GrammarInput objects
    if (isResult(restoredGrammar)) {
      if (restoredGrammar._tag === 'Ok' && isProcessedGrammar(restoredGrammar.value)) {
        return restoredGrammar.value.grammar;
      }
      // Handle other Result cases or throw error for Error results
      throw new Error(`Grammar export contains an error result`);
    }
    
    if (isProcessedGrammar(restoredGrammar)) {
      return restoredGrammar.grammar;
    }
    
    return restoredGrammar;
  } catch (error) {
    throw new Error(
      `Failed to load grammar with Bun: ${
        error instanceof Error ? error.message : String(error)
      }`,
    );
  }
}

/**
 * Type guard to check if an object is a Result type
 */
function isResult(obj: any): boolean {
  return obj && typeof obj === 'object' && 
         typeof obj._tag === 'string' && 
         (obj._tag === 'Ok' || obj._tag === 'Error');
}

/**
 * Type guard to check if an object is a processed Grammar
 */
function isProcessedGrammar(obj: any): obj is Grammar {
  return obj && typeof obj === 'object' && 
         typeof obj.isValid === 'boolean' && 
         obj.grammar && 
         Array.isArray(obj.errors);
} 
```

### src/cli/utils/grammar.ts

```ts
import { resolve, extname } from "node:path";
import { pathToFileURL as convertPathToURL } from "node:url";
import { isBunAvailable, loadGrammarWithBun } from "./bun.js";
import type { GrammarInput, Grammar } from "../../types.js";

/**
 * Load grammar from JavaScript file using Node.js direct import
 */
async function loadGrammarWithNode(
  filePath: string,
  exportName?: string,
): Promise<GrammarInput> {
  const moduleUrl = convertPathToURL(filePath).toString();
  const module = await import(moduleUrl);

  const grammar = module[exportName || "default"] || module.default || module.grammar;

  if (!grammar) {
    const availableExports = Object.keys(module).filter((k) => k !== "default");
    throw new Error(
      `No grammar found in ${filePath}. Available exports: ${availableExports.join(
        ", ",
      )}`,
    );
  }

  // Handle Result<Grammar>, Grammar, and GrammarInput objects
  if (isResult(grammar)) {
    if (grammar._tag === 'Ok' && isProcessedGrammar(grammar.value)) {
      return grammar.value.grammar;
    }
    // Handle other Result cases or throw error for Error results
    throw new Error(`Grammar export contains an error result`);
  }
  
  if (isProcessedGrammar(grammar)) {
    return grammar.grammar;
  }

  return grammar;
}

/**
 * Type guard to check if an object is a Result type
 */
function isResult(obj: any): boolean {
  return obj && typeof obj === 'object' && 
         typeof obj._tag === 'string' && 
         (obj._tag === 'Ok' || obj._tag === 'Error');
}

/**
 * Type guard to check if an object is a processed Grammar
 */
function isProcessedGrammar(obj: any): obj is Grammar {
  return obj && typeof obj === 'object' && 
         typeof obj.isValid === 'boolean' && 
         obj.grammar && 
         Array.isArray(obj.errors);
}

/**
 * Load and validate a grammar from a TypeScript or JavaScript file
 */
export async function loadGrammarFromFile(
  filePath: string,
  exportName?: string,
): Promise<GrammarInput> {
  const resolvedPath = resolve(filePath);
  const ext = extname(resolvedPath);

  // Validate file extension
  if (![".ts", ".js", ".mts", ".mjs"].includes(ext)) {
    throw new Error(
      `Unsupported file type: ${ext}. Expected .ts, .js, .mts, or .mjs`,
    );
  }

  let grammar: GrammarInput;

  try {
    if ([".ts", ".mts"].includes(ext)) {
      // TypeScript: Require Bun
      if (!(await isBunAvailable())) {
        throw new Error(
          "Bun is required for TypeScript file support.\n" +
            "Install Bun: https://bun.sh/docs/installation\n" +
            "Or convert your grammar to JavaScript.",
        );
      }
      grammar = await loadGrammarWithBun(resolvedPath, exportName);
    } else {
      // JavaScript: Use Node.js direct import
      grammar = await loadGrammarWithNode(resolvedPath, exportName);
    }

    return grammar;
  } catch (error) {
    if (error instanceof Error) {
      throw new Error(`Failed to load grammar from ${filePath}: ${error.message}`);
    }
    throw error;
  }
}

/**
 * Helper function to restore RegExp objects from serialized format
 */
export function restoreRegexObjects(obj: any): any {
  if (obj && typeof obj === "object") {
    if (obj.__regex) {
      return new RegExp(obj.__regex);
    }
    if (Array.isArray(obj)) {
      return obj.map(restoreRegexObjects);
    }
    const result: any = {};
    for (const [key, value] of Object.entries(obj)) {
      result[key] = restoreRegexObjects(value);
    }
    return result;
  }
  return obj;
} 
```

### src/emit.ts

```ts
/**
 * Grammar processing and emit functions
 * Handles validation, repository management, and output generation
 */

import type {
  BeginEndRule,
  GrammarInput,
  MatchRule,
  Rule,
  IncludeRule,
  Grammar,
  EmitOptions,
  TMLanguageGrammar,
  Pattern,
} from './types.js';
import { meta } from './types.js';
import { ErrorCodes, errorFactory } from './errors.js';
import { ok, error, type StringResult } from './result.js';

import { readFile } from 'node:fs/promises';
import { loadWASM, OnigRegExp } from 'onigasm';
import { dirname, resolve } from 'node:path';
import * as plist from 'plist';
import * as yaml from 'js-yaml';

let initialized = false;

/**
 * Initializes the Oniguruma WASM engine for regex validation.
 * This uses the same regex engine as VS Code for accurate pattern validation.
 * 
 * @internal
 */
async function initialize(): Promise<void> {
  if (!initialized) {
    const onigasmPath = require.resolve('onigasm');
    const wasmPath = resolve(dirname(onigasmPath), 'onigasm.wasm');
    const wasm = await readFile(wasmPath);
    await loadWASM(wasm.buffer as ArrayBuffer);
    initialized = true;
  }
}

/**
 * Converts a grammar to JSON format suitable for TextMate editors.
 * 
 * Performs automatic repository management, regex validation using Oniguruma engine,
 * and scope processing. The output JSON is formatted and ready for VS Code or other
 * TextMate-compatible editors.
 * 
 * @param grammar - The grammar to convert
 * @param options - Emission options for error reporting and validation control
 * @param options.errorSourceFilePath - Source file path for better error messages
 * @param options.validate - Whether to validate regex patterns (default: true)
 * @param options.formatOutput - Whether to format the JSON output (default: true)
 * @returns Promise resolving to formatted JSON string
 * 
 * @example
 * ```typescript
 * const grammarJson = await emitJSON(myGrammar, {
 *   errorSourceFilePath: './my-grammar.ts',
 *   validate: true
 * });
 * await writeFile('my-grammar.tmLanguage.json', grammarJson);
 * ```
 */
export async function emitJSON(processedGrammar: Grammar, options: EmitOptions = {}): Promise<StringResult<string>> {
  try {
    await initialize();
    const indent = 2;
    const processed = await processGrammarToTM(processedGrammar.grammar, options);
    const jsonString = JSON.stringify(processed, undefined, indent);
    return ok(jsonString);
  } catch (err) {
    return error(err instanceof Error ? err.message : String(err));
  }
}

/**
 * Converts a grammar to Apple PList XML format.
 * 
 * Produces a .tmLanguage file compatible with TextMate, Sublime Text, and other
 * editors that support the original PList format. Includes the same validation
 * and processing as emitJSON.
 * 
 * @param grammar - The grammar to convert
 * @param options - Emission options for error reporting and validation control
 * @returns Promise resolving to XML PList string
 * 
 * @example
 * ```typescript
 * const grammarPlist = await emitPList(myGrammar);
 * await writeFile('my-grammar.tmLanguage', grammarPlist);
 * ```
 */
export async function emitPList(processedGrammar: Grammar, options: EmitOptions = {}): Promise<StringResult<string>> {
  try {
    await initialize();
    const processed = await processGrammarToTM(processedGrammar.grammar, options);
    const plistString = plist.build(processed as any);
    return ok(plistString);
  } catch (err) {
    return error(err instanceof Error ? err.message : String(err));
  }
}

/**
 * Converts a processed grammar to YAML format.
 */
export async function emitYAML(processedGrammar: Grammar, options: EmitOptions = {}): Promise<StringResult<string>> {
  try {
    await initialize();
    const processed = await processGrammarToTM(processedGrammar.grammar, options);
    const yamlString = yaml.dump(processed, { indent: 2, lineWidth: -1 });
    return ok(yamlString);
  } catch (err) {
    return error(err instanceof Error ? err.message : String(err));
  }
}

/**
 * Convert the grammar from our representation to the tmlanguage schema.
 * Perform validation in the process.
 */
async function processGrammarToTM(grammar: GrammarInput, options: EmitOptions): Promise<TMLanguageGrammar> {
  await initialize();

  const internalRepositoryMap = new Map<string, [Rule, any]>(); // Maps rule key to [originalRule, processedRuleDefinition]
  const grammarNameLower = grammar.name.toLowerCase();

  // 1. Pre-populate and process all rules from repositoryItems
  if (grammar.repositoryItems) {
    for (const rule of grammar.repositoryItems) {
      if ('key' in rule) { // Only rules with keys can be in the repository
        const keyedRule = rule as MatchRule | BeginEndRule | IncludeRule;
        if (!internalRepositoryMap.has(keyedRule.key)) {
          const entry: [Rule, any] = [keyedRule, undefined]; // Placeholder for cyclic dependencies
          internalRepositoryMap.set(keyedRule.key, entry);
          // Process the rule definition itself and store it in entry[1]
          entry[1] = processNode(keyedRule, options, grammarNameLower, internalRepositoryMap, true);
        } else {
          const existingEntry = internalRepositoryMap.get(keyedRule.key);
          if (existingEntry && existingEntry[0] !== keyedRule) {
            const factory = errorFactory.withLocation({ 
              filePath: options.errorSourceFilePath,
              ruleKey: keyedRule.key,
              contextPath: 'repositoryItems'
            });
            throw factory.reference(
              `Duplicate key found in repositoryItems: '${keyedRule.key}'. The same key is used for different rule objects.`,
              keyedRule.key,
              ErrorCodes.DUPLICATE_KEY
            );
          }
        }
      }
    }
  } else {
    // Note: This is an informational message, not an error
    // Repository discovery will be on-the-fly, which might be incomplete for complex grammars
    // It is recommended to list all keyed rules in repositoryItems for reliable repository generation
  }

  // 2. Process the main grammar structure. processNode for the grammar object will handle its top-level fields
  // and its 'patterns' array. The 'repositoryItems' field itself will be skipped during this processing.
  const outputGrammarStructure = processNode(grammar, options, grammarNameLower, internalRepositoryMap, false);

  // 3. Construct the final repository object for the output from our populated internalRepositoryMap
  const finalRepositoryObject: any = {};
  const sortedKeys = Array.from(internalRepositoryMap.keys()).sort(); // For consistent output
  for (const key of sortedKeys) {
    const entry = internalRepositoryMap.get(key);
    if (entry && entry[1] !== undefined) { // entry[1] holds the processed rule definition
      finalRepositoryObject[key] = entry[1];
    }
  }
  outputGrammarStructure.repository = finalRepositoryObject;

  return outputGrammarStructure;
}

// Added internalRepo parameter, and isProcessingRepositoryItem flag
function processNode(
  node: any, 
  options: EmitOptions, 
  grammarName: string, 
  currentRepository: Map<string, [Rule, any]>, 
  isRepositoryItemContext: boolean
): any {
  if (typeof node !== 'object' || node === null) {
    return node;
  }
  if (Array.isArray(node)) {
    return node.map((n) => processNode(n, options, grammarName, currentRepository, isRepositoryItemContext));
  }

  const outputNode: any = {};
  for (const originalKey in node) {
    if (!Object.prototype.hasOwnProperty.call(node, originalKey)) {
      continue;
    }
    const value = node[originalKey];
    let processedValue = value;

    try {
      switch (originalKey) {
        case "key":
          if (!isRepositoryItemContext) {
            outputNode[originalKey] = value;
          }
          break;
        case "repositoryItems":
          break;
        case "scope": {
          const ruleKeyForMeta = node.key || 'unknown';
          outputNode.name = value === meta
            ? `meta.${ruleKeyForMeta}.${grammarName}`
            : String(value);
          break;
        }
        case "begin":
        case "end":
        case "match":
        case "while":
        case "firstLineMatch":
        case "foldingStartMarker":
        case "foldingStopMarker":
          if (value instanceof RegExp) {
            processedValue = value.source;
          }
          validateRegexp(processedValue, node, originalKey, options);
          outputNode[originalKey] = processedValue;
          break;
        case "captures":
        case "beginCaptures":
        case "endCaptures":
        case "whileCaptures":
          // Special handling for capture groups
          outputNode[originalKey] = processNode(value, options, grammarName, currentRepository, true);
          break;
        case "patterns":
          outputNode[originalKey] = processPatterns(value, options, grammarName, currentRepository);
          break;
        default:
          outputNode[originalKey] = processNode(value, options, grammarName, currentRepository, false);
          break;
      }
    } catch (error) {
      // Improve error context
      const newError = new Error(
        `Error processing property '${originalKey}' in rule with key '${node.key || "unknown"}': ${(error as any).message}`
      );
      if (options.errorSourceFilePath) {
        newError.message += ` (source: ${options.errorSourceFilePath})`;
      }
      newError.stack = (error as any).stack;
      throw newError;
    }
  }
  return outputNode;
}

function processPatterns(
  patterns: Pattern[], 
  options: EmitOptions, 
  grammarName: string, 
  currentRepository: Map<string, [Rule, any]>
): any[] {
  const processedPatternsArray: any[] = [];
  for (const pattern of patterns) {
    // Handle BasicIncludePattern (already an include directive)
    if ('include' in pattern && !('key' in pattern)) {
      processedPatternsArray.push(pattern); 
      continue;
    }

    // Handle rule references and rule definitions
    const rule = pattern as Rule;

    // Check if this is a keyed rule
    if ('key' in rule) {
      const keyedRule = rule as MatchRule | BeginEndRule | IncludeRule;

      if (!keyedRule.key) {
        // eslint-disable-next-line no-console
        console.warn('Processing a rule without a key directly in patterns (will be inlined):', rule);
        processedPatternsArray.push(processNode(rule, options, grammarName, currentRepository, false));
        continue;
      }

      // Rule has a key. Check if it's already in the repository
      if (!currentRepository.has(keyedRule.key)) {
        // This rule was referenced but not pre-processed via repositoryItems
        // eslint-disable-next-line no-console
        console.warn(`Discovered and processing new repository item on-the-fly: '${keyedRule.key}'. For best results, pre-declare all keyed rules in top-level 'repositoryItems'.`);
        const entry: [Rule, any] = [keyedRule, undefined]; // Placeholder
        currentRepository.set(keyedRule.key, entry);
        entry[1] = processNode(keyedRule, options, grammarName, currentRepository, true);
      } else {
        const existingEntry = currentRepository.get(keyedRule.key);
        if (existingEntry && existingEntry[0] !== keyedRule) {
           // This is a sanity check. It should ideally be caught by the pre-processing loop.
           throw new Error(`Duplicate key '${keyedRule.key}' detected with a different rule object.`);
        }
      }

      // Now that we know it's in the repo, add an include directive
      processedPatternsArray.push({ include: `#${keyedRule.key}` });

    } else {
      // It's a rule without a key, process it inline.
      processedPatternsArray.push(processNode(rule, options, grammarName, currentRepository, false));
    }
  }
  return processedPatternsArray;
}

/**
 * Validates a regular expression using the Oniguruma engine.
 * Throws a detailed error if the pattern is invalid.
 */
function validateRegexp(regexp: string, node: any, prop: string, options: EmitOptions) {
  if (regexp !== 'string') {
    return;
  }
  try {
    // eslint-disable-next-line no-new
    new OnigRegExp(regexp);
  } catch (error) {
    const errorMessage =
`Invalid regular expression in property '${prop}': /${regexp}/
Rule: ${JSON.stringify(node, null, 2)}
Error: ${(error as any).message || String(error)}`;

    const newError = new Error(errorMessage);
    if (options.errorSourceFilePath) {
      newError.message += ` (source: ${options.errorSourceFilePath})`;
    }
    newError.stack = (error as any).stack || [];
    throw newError;
  }
} 
```

### src/errors.ts

```ts
/**
 * Centralized error handling for grammar validation and processing
 */

import type { 
  GrammarError, 
  ErrorLocation
} from './types.js';
import { GrammarValidationError, createGrammarError, ErrorSeverity, ErrorCategory } from './types.js';

/**
 * Common error codes for consistent error handling
 */
export const ErrorCodes = {
  // Validation errors
  MISSING_SCOPE_NAME: 'E001',
  MISSING_PATTERNS: 'E002',
  INVALID_SCOPE_NAME: 'E003',
  INVALID_FILE_TYPES: 'E004',
  
  // Regex errors
  INVALID_REGEX: 'E101',
  REGEX_COMPILATION_FAILED: 'E102',
  
  // Scope errors
  INVALID_SCOPE: 'E201',
  UNKNOWN_SCOPE: 'E202',
  
  // Reference errors
  MISSING_REFERENCE: 'E301',
  CIRCULAR_REFERENCE: 'E302',
  DUPLICATE_KEY: 'E303',
  
  // Syntax errors
  INVALID_RULE_TYPE: 'E401',
  MISSING_REQUIRED_FIELD: 'E402',
  INVALID_FIELD_TYPE: 'E403',
  
  // Semantic errors
  UNREACHABLE_RULE: 'E501',
  INEFFICIENT_PATTERN: 'E502'
} as const;

/**
 * Error factory for creating standardized grammar errors
 */
export class GrammarErrorFactory {
  constructor(private defaultLocation?: Partial<ErrorLocation>) {}

  /**
   * Create a validation error
   */
  validation(
    message: string,
    code?: string,
    location?: Partial<ErrorLocation>,
    context?: string
  ): GrammarValidationError {
    return createGrammarError(message, {
      severity: ErrorSeverity.ERROR,
      category: ErrorCategory.VALIDATION,
      code,
      location: { ...this.defaultLocation, ...location },
      context
    });
  }

  /**
   * Create a regex error
   */
  regex(
    message: string,
    pattern: string,
    code?: string,
    location?: Partial<ErrorLocation>
  ): GrammarValidationError {
    return createGrammarError(message, {
      severity: ErrorSeverity.ERROR,
      category: ErrorCategory.REGEX,
      code,
      location: { ...this.defaultLocation, ...location },
      context: `Pattern: ${pattern}`
    });
  }

  /**
   * Create a scope error
   */
  scope(
    message: string,
    scope: string,
    code?: string,
    location?: Partial<ErrorLocation>
  ): GrammarValidationError {
    return createGrammarError(message, {
      severity: ErrorSeverity.ERROR,
      category: ErrorCategory.SCOPE,
      code,
      location: { ...this.defaultLocation, ...location },
      context: `Scope: ${scope}`
    });
  }

  /**
   * Create a reference error
   */
  reference(
    message: string,
    reference: string,
    code?: string,
    location?: Partial<ErrorLocation>
  ): GrammarValidationError {
    return createGrammarError(message, {
      severity: ErrorSeverity.ERROR,
      category: ErrorCategory.REFERENCE,
      code,
      location: { ...this.defaultLocation, ...location },
      context: `Reference: ${reference}`
    });
  }

  /**
   * Create a syntax error
   */
  syntax(
    message: string,
    code?: string,
    location?: Partial<ErrorLocation>,
    context?: string
  ): GrammarValidationError {
    return createGrammarError(message, {
      severity: ErrorSeverity.ERROR,
      category: ErrorCategory.SYNTAX,
      code,
      location: { ...this.defaultLocation, ...location },
      context
    });
  }

  /**
   * Create a warning
   */
  warning(
    message: string,
    code?: string,
    location?: Partial<ErrorLocation>,
    context?: string
  ): GrammarValidationError {
    return createGrammarError(message, {
      severity: ErrorSeverity.WARNING,
      category: ErrorCategory.VALIDATION,
      code,
      location: { ...this.defaultLocation, ...location },
      context
    });
  }

  /**
   * Create info message
   */
  info(
    message: string,
    code?: string,
    location?: Partial<ErrorLocation>,
    context?: string
  ): GrammarValidationError {
    return createGrammarError(message, {
      severity: ErrorSeverity.INFO,
      category: ErrorCategory.VALIDATION,
      code,
      location: { ...this.defaultLocation, ...location },
      context
    });
  }

  /**
   * Create a new factory with updated default location
   */
  withLocation(location: Partial<ErrorLocation>): GrammarErrorFactory {
    return new GrammarErrorFactory({ ...this.defaultLocation, ...location });
  }
}

/**
 * Default error factory instance
 */
export const errorFactory = new GrammarErrorFactory();

/**
 * Collection of errors with utilities for management
 */
export class ErrorCollection {
  private errors: GrammarError[] = [];
  private warnings: GrammarError[] = [];
  private infos: GrammarError[] = [];

  /**
   * Add an error to the collection
   */
  add(error: GrammarError | GrammarValidationError): void {
    switch (error.severity) {
      case ErrorSeverity.ERROR:
        this.errors.push(error);
        break;
      case ErrorSeverity.WARNING:
        this.warnings.push(error);
        break;
      case ErrorSeverity.INFO:
        this.infos.push(error);
        break;
    }
  }

  /**
   * Add multiple errors
   */
  addAll(errors: (GrammarError | GrammarValidationError)[]): void {
    errors.forEach(error => this.add(error));
  }

  /**
   * Get all errors
   */
  getErrors(): GrammarError[] {
    return [...this.errors];
  }

  /**
   * Get all warnings
   */
  getWarnings(): GrammarError[] {
    return [...this.warnings];
  }

  /**
   * Get all info messages
   */
  getInfos(): GrammarError[] {
    return [...this.infos];
  }

  /**
   * Get all messages (errors, warnings, infos)
   */
  getAll(): GrammarError[] {
    return [...this.errors, ...this.warnings, ...this.infos];
  }

  /**
   * Check if there are any errors
   */
  hasErrors(): boolean {
    return this.errors.length > 0;
  }

  /**
   * Check if there are any warnings
   */
  hasWarnings(): boolean {
    return this.warnings.length > 0;
  }

  /**
   * Get count of errors
   */
  getErrorCount(): number {
    return this.errors.length;
  }

  /**
   * Get count of warnings
   */
  getWarningCount(): number {
    return this.warnings.length;
  }

  /**
   * Clear all errors
   */
  clear(): void {
    this.errors = [];
    this.warnings = [];
    this.infos = [];
  }

  /**
   * Format all errors for display
   */
  format(): string {
    const all = this.getAll();
    if (all.length === 0) return 'No errors or warnings';

    return all.map(error => {
      const prefix = `[${error.severity.toUpperCase()}${error.code ? ` ${error.code}` : ''}]`;
      if (error instanceof GrammarValidationError) {
        return `${prefix} ${error.getFormattedMessage()}`;
      }
      return `${prefix} ${error.message}`;
    }).join('\n');
  }
}

/**
 * Create a context-aware error factory for a specific rule
 */
export function createRuleErrorFactory(
  ruleKey: string,
  filePath?: string
): GrammarErrorFactory {
  return new GrammarErrorFactory({
    ruleKey,
    filePath
  });
}

/**
 * Create a context-aware error factory for a specific property
 */
export function createPropertyErrorFactory(
  ruleKey: string,
  property: string,
  filePath?: string,
  contextPath?: string
): GrammarErrorFactory {
  return new GrammarErrorFactory({
    ruleKey,
    property,
    filePath,
    contextPath
  });
}

// Re-export from types for convenience
export { GrammarValidationError };
```

### src/factory.ts

```ts
/**
 * Factory functions for creating TextMate grammar rules
 * Clean, type-safe constructors for all rule types
 */

import type {
  GrammarInput,
  Rule,
  RegexValue,
  Grammar
} from './types.js';
import { processGrammar } from './validation/grammar.js';
import type { GrammarResult } from './result.js';

/**
 * Creates a complete TextMate grammar with automatic repository management.
 * 
 * Rules with a `key` property are automatically collected and placed into the 
 * grammar's repository during emission. Use `repositoryItems` for explicit control
 * over which rules are included in the repository.
 * 
 * @param name - Human-readable name for the grammar (e.g., "TypeScript")
 * @param scopeName - Root scope identifier (e.g., "source.typescript")
 * @param fileTypes - File extensions this grammar applies to (e.g., ["ts", "tsx"])
 * @param patterns - Top-level grammar patterns/rules
 * @param options - Optional grammar configuration
 * @param options.variables - Variable definitions for pattern reuse
 * @param options.firstLineMatch - Regex to match first line for grammar detection
 * @param options.foldingStartMarker - Regex marking start of foldable sections
 * @param options.foldingStopMarker - Regex marking end of foldable sections
 * @returns Complete grammar ready for emission to TextMate format
 * 
 * @example
 * ```typescript
 * const grammar = createGrammar(
 *   'My Language',
 *   'source.mylang',
 *   ['mylang', 'ml'],
 *   [keywordRule, stringRule, commentRule],
 *   {
 *     firstLineMatch: /^#!/
 *   }
 * );
 * ```
 */
/**
 * Creates and processes a complete TextMate grammar with automatic repository management.
 * 
 * Returns a Result that forces you to check for validation errors before using the grammar.
 * 
 * @param name - Human-readable name for the grammar
 * @param scopeName - Root scope identifier (e.g., "source.typescript")
 * @param fileTypes - File extensions this grammar applies to
 * @param patterns - Top-level grammar patterns/rules
 * @param options - Optional configuration
 * @returns Result containing processed Grammar or validation errors
 */
export function createGrammar(
  name: string,
  scopeName: string,
  fileTypes: string[],
  patterns: Rule[],
  options?: {
    firstLineMatch?: RegexValue;
    foldingStartMarker?: RegexValue;
    foldingStopMarker?: RegexValue;
    uuid?: string;
    filePath?: string;
  }
): GrammarResult<Grammar> {
  const grammarInput: GrammarInput = {
    name,
    scopeName,
    fileTypes,
    patterns,
    firstLineMatch: options?.firstLineMatch,
    foldingStartMarker: options?.foldingStartMarker,
    foldingStopMarker: options?.foldingStopMarker,
    uuid: options?.uuid,
  };
  
  return processGrammar(grammarInput, options?.filePath);
} 
```

### src/helpers/index.ts

```ts
//@index('./*.ts', f => `export * from '${f.path}.js'`)
export * from './regex.js'
//@endindex

// Export regex functions as a namespace
import * as regexUtils from './regex.js';
export const regex = regexUtils;
```

### src/helpers/regex.ts

```ts
/**
 * Utility functions for creating regular expressions.
 * All functions return a new RegExp object.
 */

import type { RegexValue, RegexValueList } from "#src/types";

/**
 * Extract flags from a RegExp object.
 * @param regex - The RegExp to extract flags from.
 * @returns The flags as a string.
 */
const extractFlags = (regex: RegExp): string => {
  return regex.flags;
};

/**
 * Get the most appropriate flags from a list of RegExp inputs.
 * If all inputs are strings, returns empty string.
 * If there are RegExp inputs, combines their flags.
 * @param inputs - Array of RegExp or string inputs.
 * @returns Combined flags string.
 */
const combineFlags = (inputs: RegexValue[]): string => {
  const allFlags = inputs
    .filter((input): input is RegExp => input instanceof RegExp)
    .map(extractFlags)
    .join('');
  
  // Remove duplicates and sort for consistency
  const uniqueFlags = Array.from(new Set(allFlags)).sort();
  return uniqueFlags.join('');
};

/**
 * Creates a RegExp object from a string, throwing an error if the pattern is invalid.
 * This is an internal helper to ensure all generated regex patterns are valid.
 * 
 * @param pattern - The regex pattern string.
 * @param flags - Optional flags to apply to the RegExp.
 * @returns A new RegExp object.
 * @internal
 */
const createOrThrow = (pattern: string, flags?: string): RegExp => {
  try {
    return new RegExp(pattern, flags);
  } catch (e) {
    throw new Error(`Invalid regex pattern: /${pattern}/${flags || ''}\n${(e as any).message || String(e)}`);
  }
};

/**
 * Converts a string or RegExp to its string pattern.
 * If the input is a string, it's returned as is.
 * If it's a RegExp, its `source` is returned.
 * 
 * @param input - The regex value (string or RegExp).
 * @returns The string pattern of the regex.
 */
const toPattern = (input: RegexValue): string =>
  typeof input === 'string' ? input : input.source;

/**
 * Wrap text with word boundaries.
 * @example bounded('function') // "\\bfunction\\b"
 * @example bounded(/function/) // "\\bfunction\\b"
 * @param text - The pattern to wrap with word boundaries.
 * @returns The pattern string with word boundaries.
 */
export const bounded = (text: RegexValue): RegExp => {
  const pattern = `\\b${toPattern(text)}\\b`;
  const flags = text instanceof RegExp ? extractFlags(text) : '';
  return createOrThrow(pattern, flags);
};

/**
 * Wraps the given content with the specified wrapper pattern on both sides.
 * @example wrap('foo', '"') // "\\"foo\\""
 * @example wrap(/foo/, /"/) // "\\"foo\\""
 * @param content - The content to wrap.
 * @param wrapper - The wrapper to use on both sides.
 * @returns The wrapped pattern string.
 */
export const wrap = (content: RegexValue, wrapper: RegexValue): RegExp => {
  const pattern = `${toPattern(wrapper)}${toPattern(content)}${toPattern(wrapper)}`;
  const flags = combineFlags([content, wrapper]);
  return createOrThrow(pattern, flags);
};

/**
 * Create a positive lookahead `(?=...)` pattern.
 * @example before('\\(') // "(?=\\()"
 * @example before(/\(/) // "(?=\\()"
 * @param pattern - The pattern for the lookahead.
 * @returns The lookahead pattern string.
 */
export const before = (pattern: RegexValue): RegExp => {
  const result = `(?=${toPattern(pattern)})`;
  const flags = pattern instanceof RegExp ? extractFlags(pattern) : '';
  return createOrThrow(result, flags);
};

/**
 * Create a negative lookahead `(?!...)` pattern.
 * @example notBefore('\\)') // "(?!\\))"
 * @example notBefore(/\)/) // "(?!\\))"
 * @param pattern - The pattern for the negative lookahead.
 * @returns The negative lookahead pattern string.
 */
export const notBefore = (pattern: RegexValue): RegExp => {
  const result = `(?!${toPattern(pattern)})`;
  const flags = pattern instanceof RegExp ? extractFlags(pattern) : '';
  return createOrThrow(result, flags);
};

/**
 * Create a positive lookbehind `(?<=...)` pattern.
 * @example after('=') // "(?<=\=)"
 * @example after(/=/) // "(?<=\=)"
 * @param pattern - The pattern for the lookbehind.
 * @returns The lookbehind pattern string.
 */
export const after = (pattern: RegexValue): RegExp => {
  const result = `(?<=${toPattern(pattern)})`;
  const flags = pattern instanceof RegExp ? extractFlags(pattern) : '';
  return createOrThrow(result, flags);
};

/**
 * Create a negative lookbehind `(?<!...)` pattern.
 * @example notAfter('\\\\') // "(?<!\\\\)"
 * @example notAfter(/\\/) // "(?<!\\\\)"
 * @param pattern - The pattern for the negative lookbehind.
 * @returns The negative lookbehind pattern string.
 */
export const notAfter = (pattern: RegexValue): RegExp => {
  const result = `(?<!${toPattern(pattern)})`;
  const flags = pattern instanceof RegExp ? extractFlags(pattern) : '';
  return createOrThrow(result, flags);
};

/**
 * Create alternation pattern from array of strings or RegExp.
 * @example oneOf(['if', 'else', 'while']) // "(if|else|while)"
 * @example oneOf('if', 'else', 'while') // "(if|else|while)"
 * @example oneOf(/if/, /else/) // "(if|else)"
 * @param options - The patterns to alternate. Can be a single array or multiple arguments.
 * @returns The alternation pattern string.
 */
export const oneOf = (...options: RegexValueList): RegExp => {
  const flatOptions = options.flat();
  const patterns = flatOptions.map(toPattern);
  const pattern = `(${patterns.join('|')})`;
  const flags = combineFlags(flatOptions);
  return createOrThrow(pattern, flags);
};

/**
 * Create word-bounded alternation pattern from array of strings or RegExp.
 * @example keywords(['if', 'else']) // "\\b(if|else)\\b"
 * @example keywords('if', 'else') // "\\b(if|else)\\b"
 * @param words - The keywords to alternate. Can be a single array or multiple arguments.
 * @returns The word-bounded alternation pattern string.
 */
export const keywords = (...words: RegexValueList): RegExp => {
  const flatWords = words.flat();
  const alternation = oneOf(...flatWords).source;
  const pattern = `\\b${alternation}\\b`;
  const flags = combineFlags(flatWords);
  return createOrThrow(pattern, flags);
};

/**
 * Escape special regex characters in a string.
 * @example escape('test.file') // "test\\.file"
 * @param text - The string to escape.
 * @returns The escaped string.
 */
// biome-ignore lint/suspicious/noShadowRestrictedNames: this is only a concern in old browsers
export const escape = (text: string): string => {
  return text.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
};

/**
 * Make a pattern optional (zero or one time) `...?`.
 * Note: Appends '?' which might need grouping `(?:...)?` for sequences.
 * @example optional('s') // "s?"
 * @example optional(/s/) // "s?"
 * @param pattern - The pattern to make optional.
 * @returns The optional pattern string.
 */
export const optional = (pattern: RegexValue): RegExp => {
  const p = toPattern(pattern);
  const result = p.length > 1 ? `(?:${p})?` : `${p}?`;
  const flags = pattern instanceof RegExp ? extractFlags(pattern) : '';
  return createOrThrow(result, flags);
};

/**
 * Create zero or more pattern `...*`.
 * Note: Appends '*' which might need grouping `(?:...)*` for sequences.
 * @example zeroOrMore('\\w') // "\\w*"
 * @example zeroOrMore(/\\w/) // "\\w*"
 * @param pattern - The pattern to repeat zero or more times.
 * @returns The zero or more pattern string.
 */
export const zeroOrMore = (pattern: RegexValue): RegExp => {
  const p = toPattern(pattern);
  const result = p.length > 1 ? `(?:${p})*` : `${p}*`;
  const flags = pattern instanceof RegExp ? extractFlags(pattern) : '';
  return createOrThrow(result, flags);
};

/**
 * Create one or more pattern `...+`.
 * Note: Appends '+' which might need grouping `(?:...)+` for sequences.
 * @example oneOrMore('\\d') // "(?:\\d)+"
 * @example oneOrMore(/\\d/) // "(?:\\d)+"
 * @param pattern - The pattern to repeat one or more times.
 * @returns The one or more pattern string.
 */
export const oneOrMore = (pattern: RegexValue): RegExp => {
  const p = toPattern(pattern);
  const result = p.length > 1 ? `(?:${p})+` : `(?:${p})+`;
  const flags = pattern instanceof RegExp ? extractFlags(pattern) : '';
  return createOrThrow(result, flags);
};

/**
 * Create a capturing group `(...)`.
 * @example capture('\\w+') // "(\\w+)"
 * @example capture('\\w+', '\\s*') // "(\\w+\\s*)"
 * @param patterns - The patterns to include in the group.
 * @returns The capturing group pattern string.
 */
export const capture = (...patterns: RegexValueList): RegExp => {
  const flatPatterns = patterns.flat();
  const pattern = `(${flatPatterns.map(toPattern).join('')})`;
  const flags = combineFlags(flatPatterns);
  return createOrThrow(pattern, flags);
};

/**
 * Create a non-capturing group `(?:...)`.
 * @example group('\\w+') // "(?:\\w+)"
 * @example group('\\w+', '\\s*') // "(?:\\w+\\s*)"
 * @param patterns - The patterns to include in the group.
 * @returns The non-capturing group pattern string.
 */
export const group = (...patterns: RegexValueList): RegExp => {
  const flatPatterns = patterns.flat();
  const pattern = `(?:${flatPatterns.map(toPattern).join('')})`;
  const flags = combineFlags(flatPatterns);
  return createOrThrow(pattern, flags);
};

/**
 * Concatenate multiple regex values (RegExp or string) and return a new RegExp.
 * The result is wrapped in a non-capturing group `(?:...)` for atomicity.
 * This is useful for combining multiple fragments into a single logical unit.
 * 
 * @example concat('a', /b/, 'c') // "(?:abc)"
 * @param patterns - The patterns to concatenate.
 * @returns The concatenated RegExp.
 */
export const concat = (...patterns: RegexValueList): RegExp => {
  const flatPatterns = patterns.flat();
  const pattern = `(${flatPatterns.map(toPattern).join('')})`;
  const flags = combineFlags(flatPatterns);
  return createOrThrow(pattern, flags);
};

/**
 * Alias for `concat` function.
 */
export const r = concat;
```

### src/index.ts

```ts
//@index('./*/index.ts', f => `export * from '${f.path}.js'`)
export * from './helpers/index.js'
export * from './scopes/index.js'
export * from './terminals/index.js'
export * from './testing/index.js'
export * from './validation/index.js'
//@endindex

//@index(['./*.ts', '!cli.ts', '!*.d.ts'], f => `export * from '${f.path}.js'`)
export * from './emit.js'
export * from './errors.js'
export * from './factory.js'
export * from './result.js'
export * from './types.js'
//@endindex
```

### src/result.ts

```ts
/**
 * Result pattern implementation for type-safe error handling
 * Inspired by Effect and neverthrow libraries but lightweight and focused
 */

import type { GrammarError, GrammarValidationError } from './types.js';

// Core Result types
export interface Ok<T> {
  readonly _tag: 'Ok';
  readonly value: T;
}

export interface Error<E> {
  readonly _tag: 'Error';
  readonly error: E;
}

export type ResultType<T, E = unknown> = Ok<T> | Error<E>;

// Construction functions
export function ok<T>(value: T): Ok<T> {
  return { _tag: 'Ok', value };
}

export function error<E>(error: E): Error<E> {
  return { _tag: 'Error', error };
}

// Type guards that force error checking
export function isOk<T, E>(result: ResultType<T, E>): result is Ok<T> {
  return result._tag === 'Ok';
}

export function isError<T, E>(result: ResultType<T, E>): result is Error<E> {
  return result._tag === 'Error';
}

// Utility class for chaining operations
export class ResultUtils<T, E> {
  constructor(private result: ResultType<T, E>) {}

  /**
   * Transform the Ok value, leave Error unchanged
   */
  map<U>(fn: (value: T) => U): ResultUtils<U, E> {
    if (isOk(this.result)) {
      return new ResultUtils(ok(fn(this.result.value)));
    }
    return new ResultUtils(this.result as Error<E>);
  }

  /**
   * Transform the Error value, leave Ok unchanged
   */
  mapError<F>(fn: (error: E) => F): ResultUtils<T, F> {
    if (isError(this.result)) {
      return new ResultUtils(error(fn(this.result.error)));
    }
    return new ResultUtils(this.result as Ok<T>);
  }

  /**
   * Chain operations that return Results (flatMap/bind)
   */
  flatMap<U, F>(fn: (value: T) => ResultType<U, F>): ResultUtils<U, E | F> {
    if (isOk(this.result)) {
      return new ResultUtils(fn(this.result.value));
    }
    return new ResultUtils(this.result as Error<E>);
  }

  /**
   * Execute a side effect on Ok values
   */
  tap(fn: (value: T) => void): ResultUtils<T, E> {
    if (isOk(this.result)) {
      fn(this.result.value);
    }
    return this;
  }

  /**
   * Execute a side effect on Error values
   */
  tapError(fn: (error: E) => void): ResultUtils<T, E> {
    if (isError(this.result)) {
      fn(this.result.error);
    }
    return this;
  }

  /**
   * Extract the value, throwing on Error
   */
  unwrap(): T {
    if (isOk(this.result)) {
      return this.result.value;
    }
    throw this.result.error;
  }

  /**
   * Extract the value or return a default
   */
  unwrapOr(defaultValue: T): T {
    if (isOk(this.result)) {
      return this.result.value;
    }
    return defaultValue;
  }

  /**
   * Extract the value or compute a default
   */
  unwrapOrElse(fn: (error: E) => T): T {
    if (isOk(this.result)) {
      return this.result.value;
    }
    return fn(this.result.error);
  }

  /**
   * Pattern matching for both Ok and Error cases
   */
  match<U>(onOk: (value: T) => U, onError: (error: E) => U): U {
    if (isOk(this.result)) {
      return onOk(this.result.value);
    }
    return onError(this.result.error);
  }

  /**
   * Convert to Promise
   */
  toPromise(): Promise<T> {
    if (isOk(this.result)) {
      return Promise.resolve(this.result.value);
    }
    return Promise.reject(this.result.error);
  }

  /**
   * Get the underlying Result
   */
  get(): ResultType<T, E> {
    return this.result;
  }
}

// Functional composition helper
export function pipe<T, E>(result: ResultType<T, E>): ResultUtils<T, E> {
  return new ResultUtils(result);
}

// Promise integration
export async function fromPromise<T>(
  promise: Promise<T>
): Promise<ResultType<T, unknown>> {
  try {
    const value = await promise;
    return ok(value);
  } catch (err) {
    return error(err);
  }
}

export function toPromise<T, E>(result: ResultType<T, E>): Promise<T> {
  if (isOk(result)) {
    return Promise.resolve(result.value);
  }
  return Promise.reject(result.error);
}

// Convert throwing functions to Results
export function fromThrowable<T, Args extends readonly unknown[]>(
  fn: (...args: Args) => T
) {
  return (...args: Args): ResultType<T, unknown> => {
    try {
      return ok(fn(...args));
    } catch (err) {
      return error(err);
    }
  };
}

export async function fromThrowableAsync<T, Args extends readonly unknown[]>(
  fn: (...args: Args) => Promise<T>
) {
  return async (...args: Args): Promise<ResultType<T, unknown>> => {
    try {
      const value = await fn(...args);
      return ok(value);
    } catch (err) {
      return error(err);
    }
  };
}

// Combine multiple Results
export function all<T, E>(
  results: readonly ResultType<T, E>[]
): ResultType<T[], E> {
  const values: T[] = [];
  for (const result of results) {
    if (isError(result)) {
      return result;
    }
    values.push(result.value);
  }
  return ok(values);
}

export function allSettled<T, E>(
  results: readonly ResultType<T, E>[]
): ResultType<T[], E[]> {
  const values: T[] = [];
  const errors: E[] = [];
  
  for (const result of results) {
    if (isOk(result)) {
      values.push(result.value);
    } else {
      errors.push(result.error);
    }
  }
  
  if (errors.length > 0) {
    return error(errors);
  }
  return ok(values);
}

// Utility namespace
export const Result = {
  ok,
  error,
  isOk,
  isError,
  pipe,
  fromPromise,
  toPromise,
  fromThrowable,
  fromThrowableAsync,
  all,
  allSettled
} as const;

// Type aliases for common use cases in this project
export type ValidationResult<T> = ResultType<T, GrammarValidationError>;
export type GrammarResult<T> = ResultType<T, GrammarError>;
export type StringResult<T> = ResultType<T, string>;
```

### src/scopes/index.ts

```ts

import { WELL_KNOWN_SCOPES } from './well-known/index.js';
import { buildScopes } from './lib/internal.js';
import type { ScopeTree } from './types.js';

/**
 * Predefined TextMate scopes for use in grammars.
 * 
 * Includes all standard TextMate scope categories with full hierarchical support.
 * These scopes are **not callable** to prevent creation of non-standard top-level scopes.
 * 
 * Use `scopesFor({ allowScopeExtension: true })` if you need callable scopes for 
 * language-specific extensions.
 * 
 * Supports multiple naming conventions for kebab-case scopes:
 * - Kebab-case: `scopes.comment.line['double-slash']`
 * - CamelCase: `scopes.comment.line.doubleSlash`
 * - Snake_case: `scopes.comment.line.double_slash` (converts underscores to dashes)
 *
 * @example
 * Basic usage (strings only):
 * ```typescript
 * const conditionalScope = scopes.keyword.control.conditional; // "keyword.control.conditional"
 * ```
 * 
 * @example
 * Template literal usage:
 * ```typescript
 * const rule = `${scopes.string.quoted.double}.myLang`; // "string.quoted.double.myLang"
 * ```
 * 
 * @example
 * Multiple naming conventions:
 * ```typescript
 * scopes.comment.line['double-slash']  // "comment.line.double-slash" (kebab-case)
 * scopes.comment.line.doubleSlash      // "comment.line.double-slash" (camelCase)
 * scopes.comment.line.double_slash     // "comment.line.double-slash" (snake_case)
 * scopes.entity.name.class.forward_decl // "entity.name.class.forward-decl" (snake_case)
 * ```
 * 
 * @example
 * For callable scopes with language extensions:
 * ```typescript
 * const callableScopes = scopesFor({ allowScopeExtension: true });
 * callableScopes.keyword.control.conditional("js"); // "keyword.control.conditional.js"
 * ```
 */
export const scopes: ScopeTree<typeof WELL_KNOWN_SCOPES, "", "", true> = buildScopes({ allowScopeExtension: true }, WELL_KNOWN_SCOPES);

export type TextMateScopes = typeof scopes;

// Export types and functions for external use
export type { BuildScopeOptions } from './types.js';

export { scopesFor } from './scopesFor.js';


```

### src/scopes/lib/internal.ts

```ts
/**
 * Internal scope building functions
 */

import type { BuildScopeOptions, ScopeTree, Scope } from '../types.js';

/**
 * Creates a callable scope function with the given path
 */
function createScope(path: string): Scope {
  const scopeFunction = (extension: string) => {
    return extension ? `${path}.${extension}` : path;
  };
  
  scopeFunction.toString = () => path;
  scopeFunction[Symbol.toPrimitive] = (hint: 'string' | 'default' | 'number') => {
    return hint === 'number' ? null : path;
  };
  
  return scopeFunction as Scope;
}

/**
 * Recursively builds scope objects from definitions
 */
function buildScopeObject(
  definitions: any,
  options: BuildScopeOptions,
  currentPath: string = ''
): any {
  const result: any = {};
  
  for (const [key, value] of Object.entries(definitions)) {
    const fullPath = currentPath ? `${currentPath}.${key}` : key;
    const finalPath = options.prefix 
      ? `${options.prefix}.${fullPath}${options.suffix ? `.${options.suffix}` : ''}`
      : `${fullPath}${options.suffix ? `.${options.suffix}` : ''}`;
    
    if (value === null || (typeof value === 'object' && Object.keys(value).length === 0)) {
      // Leaf node
      if (options.allowScopeExtension) {
        result[key] = createScope(finalPath);
      } else {
        result[key] = finalPath;
      }
    } else if (typeof value === 'object') {
      // Branch node
      const childObject = buildScopeObject(value, options, fullPath);
      
      if (options.allowScopeExtension) {
        const scopeFunc = createScope(finalPath);
        // Assign child properties to the function, avoiding read-only properties
        for (const [childKey, childValue] of Object.entries(childObject)) {
          try {
            (scopeFunc as any)[childKey] = childValue;
          } catch (e) {
            // Skip read-only properties
          }
        }
        result[key] = scopeFunc;
      } else {
        // Create a string object that has properties
        const pathString = new String(finalPath) as any;
        Object.assign(pathString, childObject);
        result[key] = pathString;
      }
    }
  }
  
  return result;
}

/**
 * Builds a scope tree from definitions with the given options
 */
export function buildScopes(options: BuildScopeOptions, definitions: any): any {
  return buildScopeObject(definitions, {
    prefix: '',
    suffix: '',
    allowScopeExtension: false,
    ...options
  });
}

/**
 * Merges scope definitions
 */
export function mergeDefinitions(base: any, custom: any): any {
  const result = { ...base };
  
  for (const [key, value] of Object.entries(custom)) {
    if (key in result && typeof result[key] === 'object' && typeof value === 'object') {
      result[key] = mergeDefinitions(result[key], value);
    } else {
      result[key] = value;
    }
  }
  
  return result;
}
```

### src/scopes/scopesFor.ts

```ts
import type { Simplify } from 'type-fest';
import { mergeDefinitions, buildScopes } from './lib/internal';
import type { BuildScopeOptions, MergeScopes, ScopeTree } from './types';
import { WELL_KNOWN_SCOPES } from './well-known';

/**
 * Creates scopes with configuration options and optional custom scope definitions.
 * This is the main function for creating type-safe, customizable scope objects.
 *
 * @param options Configuration for scope generation (prefix, suffix, extension mode)
 * @param customScopes Optional custom scope definitions to merge with base scopes
 * @returns A fully typed scope tree with the specified configuration
 *
 * @example
 * Static scopes (recommended for performance):
 * ```typescript
 * const rclScopes = scopesFor({ suffix: 'rcl', allowScopeExtension: false });
 * rclScopes.keyword.control.conditional // "keyword.control.conditional.rcl" (not callable)
 * ```
 *
 * @example
 * Callable scopes:
 * ```typescript
 * const jsScopes = scopesFor({ suffix: 'js', allowScopeExtension: true });
 * jsScopes.keyword.control.conditional('async') // "keyword.control.conditional.js.async"
 * ```
 *
 * @example
 * Custom scope definitions:
 * ```typescript
 * const customScopes = scopesFor({ suffix: 'rcl' }, {
 *   meta: {
 *     section: {
 *       agent: null,
 *       messages: null
 *     }
 *   }
 * });
 * customScopes.meta.section.agent // "meta.section.agent.rcl"
 * ```
 */

export function scopesFor<
  const TOptions extends BuildScopeOptions,
  const TCustom extends Record<string, any> = {}
>(
  options: TOptions,
  customScopes?: TCustom
): Simplify<
  ScopeTree<
    TCustom extends Record<string, any>
      ? MergeScopes<typeof WELL_KNOWN_SCOPES, TCustom>
      : typeof WELL_KNOWN_SCOPES,
    TOptions['prefix'] extends string
        ? TOptions['prefix']
        : '',
    TOptions['suffix'] extends string
      ? TOptions['suffix']
      : '',
    TOptions['allowScopeExtension'] extends boolean
      ? TOptions['allowScopeExtension']
      : false
  >
> {
  const definitions = customScopes
    ? mergeDefinitions(WELL_KNOWN_SCOPES, customScopes)
    : WELL_KNOWN_SCOPES;

  return buildScopes({
    prefix: '',
    suffix: '',
    allowScopeExtension: false,
    ...options
  }, definitions);
}
const simpleTest = scopesFor({
  suffix: 'rcl',
  allowScopeExtension: false
}, {
  meta: {
    section: null,
  }
});

simpleTest.meta.section;


```

### src/scopes/types.ts

```ts
import type { Join } from 'type-fest';

/**
 * Configuration options for building scope objects
 */
export interface BuildScopeOptions {
  /** The prefix to prepend to all scope names */
  prefix?: string;
  /** The suffix to append to all scope names (typically language name) */
  suffix?: string;
  /** Controls which scopes can be called with additional suffixes */
  allowScopeExtension?: boolean;
}

type Filter<T extends readonly any[], U = null | undefined | ""> = T extends []
  ? []
  : T extends readonly [infer F, ...infer R]
  ? F extends U
    ? Filter<R, U>
    : [F, ...Filter<R, U>]
  : T;

export type ScopePath<
  P extends string,
  K extends string,
  S extends string,
> = Join<Filter<[P, K, S]>, '.'>;


/**
 * Base interface for a callable scope.
 * It provides a call signature to extend the scope path and a primitive converter for string coercion.
 */
export interface Scope<
P extends string,
K extends string,
S extends string> {
  /**
   * Extends this scope with the given suffix.
   * @param extension The string to append to the scope path.
   * @returns A new string with the extended scope path.
   */
  <const E extends string>(extension: E): ScopePath<ScopePath<P, K, "">, E, S>;
  /**
   * Returns the string representation of the scope path.
   */
  toString(): string;
  /**
   * Allows for implicit string conversion.
   */
  [Symbol.toPrimitive](hint: 'string' | 'default' | 'number'): ScopePath<P, K, S> | null;
}

/**
 * Recursively builds a tree of scopes from a definition object.
 * 
 * @template Tree The scope definition object.
 * @template P The prefix to prepend to all scopes.
 * @template S The suffix to apply to all scopes.
 * @template E The extension mode, controlling which scopes are callable.
 */
export type ScopeTree<
  Tree, 
  P extends string = "",
  S extends string = "",
  E extends boolean = false
> = Tree extends Record<string, any> ? {
  // prettier-ignore
  [K in keyof Tree]: K extends string
    ? Tree[K] extends null | undefined
      ? E extends true
        ? Scope<P, K, S>
        : ScopePath<P, K, S>
      : Tree[K] extends Record<string, any>
        ? E extends true
          ? Scope<P, K, S> & ScopeTree<Tree[K], ScopePath<P, K, "">, S, E>
          : ScopePath<P, K, S> & ScopeTree<Tree[K], ScopePath<P, K, "">, S, E>
        : never
    : never;
} : never;

/**
 * Simple merge type for combining custom scopes with base scopes.
 */
export type MergeScopes<TBase, TCustom> = TBase & TCustom;

/**
 * Type for scopes bound to a specific language suffix using the basic scopesFor(langSuffix) overload.
 * Preserves the full structure while making all scopes language-bound.
 */
export type TypeSafeScopes<Lang extends string, TScopes> = TScopes;

/**
 * Type for non-callable scopes when allowScopeExtension is false.
 * These scopes show exact path types without function call capabilities.
 * Should be applied to raw scope definitions, not built scope trees.
 */
export type NonCallableScopes<TScopeDefinitions, TSuffix extends string = ""> = ScopeTree<TScopeDefinitions, "", TSuffix, false>;

/**
 * Debug utility types for inspecting resolved types during development.
 * These help verify that complex conditional types are working correctly.
 */
export namespace Debug {
  /**
   * Forces TypeScript to expand and display a type fully.
   * Useful for seeing the complete resolved structure of complex types.
   * 
   * @example
   * ```typescript
   * type MyComplexType = ScopeTree<{ custom: { token: null } }>;
   * type Expanded = Debug.Expand<MyComplexType>; // Hover to see full expansion
   * ```
   */
  export type Expand<T> = T extends (...args: any[]) => any
    ? T
    : T extends Record<string, any>
    ? { [K in keyof T]: Expand<T[K]> }
    : T;

  /**
   * Shows what ScopeTree resolves to for a given input.
   * 
   * @example
   * ```typescript
   * type CallableResult = Debug.ScopeTreeResult<{ custom: { token: null } }, "", "", true>;
   * type WithPrefix = Debug.ScopeTreeResult<{ custom: { token: null } }, "meta", "rcl", true>;
   * type NonCallableResult = Debug.ScopeTreeResult<{ custom: { token: null } }, "", "", false>;
   * ```
   */
  export type ScopeTreeResult<
    T, 
    P extends string = "",
    S extends string = "",
    E extends boolean = false
  > = ScopeTree<T, P, S, E>;

  /**
   * Type-level test helper that only compiles if T extends Expected.
   * Use for compile-time type testing.
   * 
   * @example
   * ```typescript
   * const test: Debug.AssertExtends<string, string> = true; // ✅ compiles
   * const test2: Debug.AssertExtends<number, string> = true; // ❌ error
   * ```
   */
  export type AssertExtends<T, Expected> = T extends Expected ? true : false;

  /**
   * Type-level test helper that only compiles if T is exactly Expected.
   * 
   * @example
   * ```typescript
   * const test: Debug.AssertEqual<'test', 'test'> = true; // ✅ compiles
   * const test2: Debug.AssertEqual<'test', string> = true; // ❌ error
   * ```
   */
  export type AssertEqual<T, Expected> = T extends Expected
    ? Expected extends T
      ? true
      : false
    : false;

  /**
   * Shows the keys of a type for inspection.
   * 
   * @example
   * ```typescript
   * type Keys = Debug.Keys<{ a: string; b: number }>; // "a" | "b"
   * ```
   */
  export type Keys<T> = keyof T;

  /**
   * Shows whether a type is callable (function) or not.
   * 
   * @example
   * ```typescript
   * type IsCallable = Debug.IsCallable<string & (() => string)>; // true
   * ```
   */
  export type IsCallable<T> = T extends (...args: any[]) => any ? true : false;
}
```

### src/scopes/well-known/comment.ts

```ts
/**
 * Comment scopes with full type safety and hierarchical structure.
 * 
 * @example
 * ```typescript
 * // Basic usage
 * scopes.comment.line.double_slash // "comment.line.double-slash"
 * scopes.comment.block.documentation("js") // "comment.block.documentation.js"
 * ```
 */
export const COMMENT_SCOPE = {
    /**
     * Represents the `comment.line` scope.
     * Line comment constructs.
     * Full path: `comment.line`
     */
    line: {
      /**
       * Used for // style comments.
       * Full path: `comment.line.double-slash`
       */
      double_slash: null,
      /**
       * Used for -- style comments.
       * Full path: `comment.line.double-dash`
       */
      double_dash: null,
      /**
       * Used for # style comments.
       * Full path: `comment.line.number-sign`
       */
      number_sign: null,
      /**
       * Used for % style comments.
       * Full path: `comment.line.percentage`
       */
      percentage: null,
    },
    /**
     * Use for the entire block comment construct.
     * Full path: `comment.block`
     */
    block: {
      /**
       * Used for actual documentation part of a comment block.
       * Full path: `comment.block.documentation`
       */
      documentation: null,
    },
  };

export default COMMENT_SCOPE;
```

### src/scopes/well-known/constant.ts

```ts
/**
 * Root scope for `constant`.
 * Fixed values including literals, language constants, and escape sequences.
 * Distinguish between user-defined constants (`entity.name.constant`) and literal values.
 * Full path: `constant`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
 * 
 * @example
 * ```typescript
 * scopes.constant.numeric.integer.decimal // "constant.numeric.integer.decimal"
 * scopes.constant.character.escape("js") // "constant.character.escape.js"
 * scopes.constant.language // "constant.language"
 * ```
 */
export const CONSTANT_SCOPE = {
    /**
     * Represents the `constant.numeric` scope.
     * All numeric literals.
     * Full path: `constant.numeric`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
     */
    numeric: {
      /**
       * Represents the `constant.numeric.integer` scope.
       * Integer values.
       * Full path: `constant.numeric.integer`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
       */
      integer: {
        /**
         * Represents the `constant.numeric.integer.binary` scope.
         * Binary integers (`0b1010`).
         * Full path: `constant.numeric.integer.binary`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        binary: null,
        /**
         * Represents the `constant.numeric.integer.octal` scope.
         * Octal integers (`0o777`).
         * Full path: `constant.numeric.integer.octal`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        octal: null,
        /**
         * Represents the `constant.numeric.integer.decimal` scope.
         * Decimal integers (`42`).
         * Full path: `constant.numeric.integer.decimal`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        decimal: null,
        /**
         * Represents the `constant.numeric.integer.hexadecimal` scope.
         * Hex integers (`0xFF`).
         * Full path: `constant.numeric.integer.hexadecimal`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        hexadecimal: null,
        /**
         * Represents the `constant.numeric.integer.other` scope.
         * Other integer formats.
         * Full path: `constant.numeric.integer.other`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        other: null,
      },
      /**
       * Represents the `constant.numeric.float` scope.
       * Floating-point values.
       * Full path: `constant.numeric.float`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
       */
      float: {
        /**
         * Represents the `constant.numeric.float.binary` scope.
         * Binary floats.
         * Full path: `constant.numeric.float.binary`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        binary: null,
        /**
         * Represents the `constant.numeric.float.octal` scope.
         * Octal floats.
         * Full path: `constant.numeric.float.octal`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        octal: null,
        /**
         * Represents the `constant.numeric.float.decimal` scope.
         * Decimal floats (`3.14`).
         * Full path: `constant.numeric.float.decimal`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        decimal: null,
        /**
         * Represents the `constant.numeric.float.hexadecimal` scope.
         * Hex floats (`0x1.5p3`).
         * Full path: `constant.numeric.float.hexadecimal`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        hexadecimal: null,
        /**
         * Represents the `constant.numeric.float.other` scope.
         * Other float formats.
         * Full path: `constant.numeric.float.other`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        other: null,
      },
      /**
       * Represents the `constant.numeric.complex` scope.
       * Complex numbers.
       * Full path: `constant.numeric.complex`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
       */
      complex: {
        /**
         * Represents the `constant.numeric.complex.real` scope.
         * Real part of complex numbers.
         * Full path: `constant.numeric.complex.real`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        real: null,
        /**
         * Represents the `constant.numeric.complex.imaginary` scope.
         * Imaginary part of complex numbers.
         * Full path: `constant.numeric.complex.imaginary`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
         */
        imaginary: null,
      },
      /**
       * Represents the `constant.numeric.other` scope.
       * Other numeric values.
       * Full path: `constant.numeric.other`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
       */
      other: null,
    },
    /**
     * Represents the `constant.character` scope.
     * Character-related constants.
     * Full path: `constant.character`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
     */
    character: {
      /**
       * Represents the `constant.character.escape` scope.
       * Escape sequences (`\n`, `\t`, `\u0041`).
       * Full path: `constant.character.escape`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
       */
      escape: null,
    },
    /**
     * Represents the `constant.language` scope.
     * Built-in constants (`true`, `false`, `nil`, `undefined`).
     * Full path: `constant.language`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
     */
    language: null,
    /**
     * Represents the `constant.other` scope.
     * Other constants (CSS colors, symbols).
     * Full path: `constant.other`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
     */
    other: {
      /**
       * Represents the `constant.other.placeholder` scope.
       * Format placeholders (`%s`, `{0}`).
       * Full path: `constant.other.placeholder`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#constant)
       */
      placeholder: null,
    },
  };

export default CONSTANT_SCOPE;
```

### src/scopes/well-known/entity.ts

```ts
/**
 * Root scope for `entity`.
 * Names of data structures, types, and uniquely-identifiable constructs.
 * The entity scopes target the **names** only, not entire constructs (use `meta.*` for that).
 * Full path: `entity`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
 * 
 * @example
 * ```typescript
 * scopes.entity.name.class // "entity.name.class"
 * scopes.entity.name.function.constructor("js") // "entity.name.function.constructor.js"
 * scopes.entity.other.inherited_class // "entity.other.inherited-class"
 * ```
 */
export const ENTITY_SCOPE = {
    /**
     * Represents the `entity.name` scope.
     * Names of various language constructs.
     * Full path: `entity.name`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
     */
    name: {
      /**
       * Represents the `entity.name.class` scope.
       * Class names.
       * Full path: `entity.name.class`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      class: {
        /**
         * Represents the `entity.name.class.forward-decl` scope.
         * Forward-declaration of a class.
         * Full path: `entity.name.class.forward-decl`
         */
        forward_decl: null,
      },
      /**
       * Represents the `entity.name.struct` scope.
       * Struct names.
       * Full path: `entity.name.struct`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      struct: null,
      /**
       * Represents the `entity.name.enum` scope.
       * Enumeration names.
       * Full path: `entity.name.enum`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      enum: null,
      /**
       * Represents the `entity.name.union` scope.
       * Union names.
       * Full path: `entity.name.union`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      union: null,
      /**
       * Represents the `entity.name.trait` scope.
       * Trait names.
       * Full path: `entity.name.trait`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      trait: null,
      /**
       * Represents the `entity.name.interface` scope.
       * Interface names.
       * Full path: `entity.name.interface`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      interface: null,
      /**
       * Represents the `entity.name.impl` scope.
       * Implementation names.
       * Full path: `entity.name.impl`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      impl: null,
      /**
       * Represents the `entity.name.type` scope.
       * Generic type names.
       * Full path: `entity.name.type`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      type: null,
      /**
       * Represents the `entity.name.function` scope.
       * Function names (when defined).
       * Full path: `entity.name.function`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      function: {
        /**
         * Represents the `entity.name.function.constructor` scope.
         * Constructor names.
         * Full path: `entity.name.function.constructor`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
         */
        constructor: null,
        /**
         * Represents the `entity.name.function.destructor` scope.
         * Destructor names.
         * Full path: `entity.name.function.destructor`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
         */
        destructor: null,
      },
      /**
       * Represents the `entity.name.namespace` scope.
       * Namespace/module/package names.
       * Full path: `entity.name.namespace`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      namespace: null,
      /**
       * Represents the `entity.name.constant` scope.
       * Named constants (vs `variable.other.constant`).
       * Full path: `entity.name.constant`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      constant: null,
      /**
       * Represents the `entity.name.label` scope.
       * Labels for goto statements.
       * Full path: `entity.name.label`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      label: null,
      /**
       * Represents the `entity.name.section` scope.
       * Section/heading names in markup.
       * Full path: `entity.name.section`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      section: null,
      /**
       * Represents the `entity.name.tag` scope.
       * HTML/XML tag names (only `entity.name` scope applied to repeated constructs).
       * Full path: `entity.name.tag`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      tag: null,
    },
  
    /**
     * Represents the `entity.other` scope.
     * Other entity-related constructs.
     * Full path: `entity.other`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
     */
    other: {
      /**
       * Represents the `entity.other.inherited-class` scope.
       * Superclass/baseclass names.
       * Full path: `entity.other.inherited-class`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      inherited_class: null,
      /**
       * Represents the `entity.other.attribute-name` scope.
       * HTML/XML attribute names.
       * Full path: `entity.other.attribute-name`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#entity)
       */
      attribute_name: null,
    }
  };

export default ENTITY_SCOPE;
```

### src/scopes/well-known/index.ts

```ts

//@index(['./*.ts', '!types.ts'], (f, _) => `import { ${f.name.toUpperCase()}_SCOPE } from '${f.path}.js'`)
import { COMMENT_SCOPE } from './comment.js'
import { CONSTANT_SCOPE } from './constant.js'
import { ENTITY_SCOPE } from './entity.js'
import { INVALID_SCOPE } from './invalid.js'
import { KEYWORD_SCOPE } from './keyword.js'
import { MARKUP_SCOPE } from './markup.js'
import { META_SCOPE } from './meta.js'
import { PUNCTUATION_SCOPE } from './punctuation.js'
import { STORAGE_SCOPE } from './storage.js'
import { STRING_SCOPE } from './string.js'
import { SUPPORT_SCOPE } from './support.js'
import { VARIABLE_SCOPE } from './variable.js'
//@endindex

//@index(['./*.ts', '!types.ts'], (f, _) => `export { ${f.name.toUpperCase()}_SCOPE } from '${f.path}.js'`)
export { COMMENT_SCOPE } from './comment.js'
export { CONSTANT_SCOPE } from './constant.js'
export { ENTITY_SCOPE } from './entity.js'
export { INVALID_SCOPE } from './invalid.js'
export { KEYWORD_SCOPE } from './keyword.js'
export { MARKUP_SCOPE } from './markup.js'
export { META_SCOPE } from './meta.js'
export { PUNCTUATION_SCOPE } from './punctuation.js'
export { STORAGE_SCOPE } from './storage.js'
export { STRING_SCOPE } from './string.js'
export { SUPPORT_SCOPE } from './support.js'
export { VARIABLE_SCOPE } from './variable.js'
//@endindex

/**
 * Raw scope definitions for all standard TextMate scope categories.
 * Used for merging with custom scope definitions in scopesFor().
 */
export const WELL_KNOWN_SCOPES = {
//@index(['./*.ts', '!types.ts'], (f, _) => `  ${f.name}: ${f.name.toUpperCase()}_SCOPE,`)
  comment: COMMENT_SCOPE,
  constant: CONSTANT_SCOPE,
  entity: ENTITY_SCOPE,
  invalid: INVALID_SCOPE,
  keyword: KEYWORD_SCOPE,
  markup: MARKUP_SCOPE,
  meta: META_SCOPE,
  punctuation: PUNCTUATION_SCOPE,
  storage: STORAGE_SCOPE,
  string: STRING_SCOPE,
  support: SUPPORT_SCOPE,
  variable: VARIABLE_SCOPE,
//@endindex
}

```

### src/scopes/well-known/invalid.ts

```ts
/**
 * Root scope for `invalid`.
 * Invalid or deprecated code. Use sparingly to avoid unpleasant highlighting.
 * Full path: `invalid`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#invalid)
 * 
 * @example
 * ```typescript
 * scopes.invalid.illegal // "invalid.illegal"
 * scopes.invalid.deprecated("js") // "invalid.deprecated.js"
 * ```
 */
export const INVALID_SCOPE = {
    /**
     * Represents the `invalid.illegal` scope.
     * Syntax errors, illegal characters.
     * Full path: `invalid.illegal`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#invalid)
     */
    illegal: null,
    /**
     * Represents the `invalid.deprecated` scope.
     * Deprecated features (use very rarely).
     * Full path: `invalid.deprecated`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#invalid)
     */
    deprecated: null,
  };
```

### src/scopes/well-known/keyword.ts

```ts
/**
 * Root scope for `keyword`.
 * Defines scopes for reserved words and operators that have special meaning in a language.
 * Full path: `keyword`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
 * 
 * @example
 * ```typescript
 * scopes.keyword.control.conditional // "keyword.control.conditional"
 * scopes.keyword.operator.assignment("js") // "keyword.operator.assignment.js"
 * scopes.keyword.declaration.function // "keyword.declaration.function"
 * scopes.keyword.other("python") // "keyword.other.python"
 * ```
 */
export const KEYWORD_SCOPE = {
    /**
     * Represents the `keyword.control` scope.
     * Defines scopes for control flow keywords.
     * Full path: `keyword.control`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
     */
    control: {
      /**
       * Represents the `keyword.control.other` scope.
       * Defines the scope for other control flow keywords.
       * Full path: `keyword.control.other`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      other: null,
      /**
       * Represents the `keyword.control.flow` scope.
       * Defines the scope for flow control keywords.
       * Full path: `keyword.control.flow`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      flow: null,
      /**
       * Represents the `keyword.control.conditional` scope.
       * Defines the scope for conditional keywords (e.g., `if`, `else`).
       * Full path: `keyword.control.conditional`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      conditional: null,
      /**
       * Represents the `keyword.control.import` scope.
       * Defines the scope for import/include keywords.
       * Full path: `keyword.control.import`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      import: null,
    },

    /**
     * Represents the `keyword.operator` scope.
     * Defines the scope for language operators (e.g., assignment, arithmetic, logical).
     * Full path: `keyword.operator`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
     */
    operator: {
      /**
       * Represents the `keyword.operator.assignment` scope.
       * Defines the scope for assignment operators.
       * Full path: `keyword.operator.assignment`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      assignment: null,
      /**
       * Represents the `keyword.operator.arithmetic` scope.
       * Defines the scope for math operators.
       * Full path: `keyword.operator.arithmetic`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      arithmetic: null,
      /**
       * Represents the `keyword.operator.bitwise` scope.
       * Defines the scope for bitwise operators.
       * Full path: `keyword.operator.bitwise`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      bitwise: null,
      /**
       * Represents the `keyword.operator.logical` scope.
       * Defines the scope for logical operators.
       * Full path: `keyword.operator.logical`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      logical: null,
      /**
       * Represents the `keyword.operator.word` scope.
       * Defines the scope for word operators (e.g., `and`, `or`, `not`).
       * Full path: `keyword.operator.word`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      word: null,
    },

    /**
     * Represents the `keyword.declaration` scope.
     * Defines scopes for declaration keywords (see `storage` section for combined usage).
     * Full path: `keyword.declaration`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
     */
    declaration: {
      /**
       * Represents the `keyword.declaration.function` scope.
       * Defines the scope for function declaration keywords.
       * Full path: `keyword.declaration.function`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      function: null,
      /**
       * Represents the `keyword.declaration.class` scope.
       * Defines the scope for class declaration keywords.
       * Full path: `keyword.declaration.class`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      class: null,
      /**
       * Represents the `keyword.declaration.struct` scope.
       * Defines the scope for struct declaration keywords.
       * Full path: `keyword.declaration.struct`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      struct: null,
      /**
       * Represents the `keyword.declaration.enum` scope.
       * Defines the scope for enum declaration keywords.
       * Full path: `keyword.declaration.enum`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      enum: null,
      /**
       * Represents the `keyword.declaration.union` scope.
       * Defines the scope for union declaration keywords.
       * Full path: `keyword.declaration.union`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      union: null,
      /**
       * Represents the `keyword.declaration.trait` scope.
       * Defines the scope for trait declaration keywords.
       * Full path: `keyword.declaration.trait`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      trait: null,
      /**
       * Represents the `keyword.declaration.interface` scope.
       * Defines the scope for interface declaration keywords.
       * Full path: `keyword.declaration.interface`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      interface: null,
      /**
       * Represents the `keyword.declaration.impl` scope.
       * Defines the scope for implementation declaration keywords.
       * Full path: `keyword.declaration.impl`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      impl: null,
      /**
       * Represents the `keyword.declaration.type` scope.
       * Defines the scope for type declaration keywords.
       * Full path: `keyword.declaration.type`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
       */
      type: null,
    },

    /**
     * Represents the `keyword.other` scope.
     * Defines the scope for other keywords that don't fit into control, operator, or declaration categories.
     * Full path: `keyword.other`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#keyword)
     */
    other: null,
  };
```

### src/scopes/well-known/markup.ts

```ts
/**
 * Root scope for `markup`.
 * Content markup in documentation and markup languages. Use for content formatting, not code syntax.
 * Full path: `markup`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
 * 
 * @example
 * ```typescript
 * scopes.markup.heading // "markup.heading"
 * scopes.markup.list.unnumbered("md") // "markup.list.unnumbered.md"
 * scopes.markup.raw.block // "markup.raw.block"
 * ```
 */
export const MARKUP_SCOPE = {
    /**
     * Represents the `markup.heading` scope.
     * Section headings.
     * Full path: `markup.heading`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
     */
    heading: null,
    /**
     * Represents the `markup.list` scope.
     * Lists and list items.
     * Full path: `markup.list`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
     */
    list: {
      /**
       * Represents the `markup.list.unnumbered` scope.
       * Bullet lists.
       * Full path: `markup.list.unnumbered`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
       */
      unnumbered: null,
      /**
       * Represents the `markup.list.numbered` scope.
       * Numbered lists.
       * Full path: `markup.list.numbered`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
       */
      numbered: null,
    },
    /**
     * Represents the `markup.bold` scope.
     * Bold text.
     * Full path: `markup.bold`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
     */
    bold: null,
    /**
     * Represents the `markup.italic` scope.
     * Italic text.
     * Full path: `markup.italic`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
     */
    italic: null,
    /**
     * Represents the `markup.underline` scope.
     * Underlined text.
     * Full path: `markup.underline`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
     */
    underline: {
      /**
       * Represents the `markup.underline.link` scope.
       * Links (inherits underline styling).
       * Full path: `markup.underline.link`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
       */
      link: null,
    },
    /**
     * Represents the `markup.inserted` scope.
     * Inserted content (diff).
     * Full path: `markup.inserted`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
     */
    inserted: null,
    /**
     * Represents the `markup.deleted` scope.
     * Deleted content (diff).
     * Full path: `markup.deleted`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
     */
    deleted: null,
    /**
     * Represents the `markup.quote` scope.
     * Blockquotes.
     * Full path: `markup.quote`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
     */
    quote: null,
    /**
     * Represents the `markup.raw` scope.
     * Raw code content.
     * Full path: `markup.raw`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
     */
    raw: {
      /**
       * Represents the `markup.raw.inline` scope.
       * Inline code.
       * Full path: `markup.raw.inline`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
       */
      inline: null,
      /**
       * Represents the `markup.raw.block` scope.
       * Code blocks (disables spell checking).
       * Full path: `markup.raw.block`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
       */
      block: null,
    },
    /**
     * Represents the `markup.other` scope.
     * Other markup constructs.
     * Full path: `markup.other`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#markup)
     */
    other: null,
  };

```

### src/scopes/well-known/meta.ts

```ts
/**
 * Root scope for `meta`.
 * Structural sections for larger code constructs. **Not intended for styling** - used by preferences and plugins for contextual behavior.
 * **Critical:** Never stack meta scopes of the same type. For example, `meta.function.php meta.function.parameters.php` should never occur - alternate between different meta scopes.
 * Full path: `meta`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
 * 
 * @example
 * ```typescript
 * scopes.meta.class // "meta.class"
 * scopes.meta.function.parameters("js") // "meta.function.parameters.js"
 * scopes.meta.annotation.identifier // "meta.annotation.identifier"
 * ```
 */
export const META_SCOPE = {
    /**
     * Represents the `meta.class` scope.
     * Complete class definitions.
     * Full path: `meta.class`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    class: null,
    /**
     * Represents the `meta.struct` scope.
     * Complete struct definitions.
     * Full path: `meta.struct`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    struct: null,
    /**
     * Represents the `meta.enum` scope.
     * Complete enum definitions.
     * Full path: `meta.enum`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    enum: null,
    /**
     * Represents the `meta.union` scope.
     * Complete union definitions.
     * Full path: `meta.union`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    union: null,
    /**
     * Represents the `meta.trait` scope.
     * Complete trait definitions.
     * Full path: `meta.trait`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    trait: null,
    /**
     * Represents the `meta.interface` scope.
     * Complete interface definitions.
     * Full path: `meta.interface`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    interface: null,
    /**
     * Represents the `meta.impl` scope.
     * Complete implementation definitions.
     * Full path: `meta.impl`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    impl: null,
    /**
     * Represents the `meta.type` scope.
     * Complete type definitions.
     * Full path: `meta.type`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    type: null,
    /**
     * Represents the `meta.function` scope.
     * Complete function definitions.
     * Full path: `meta.function`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    function: {
      /**
       * Represents the `meta.function.parameters` scope.
       * Parameter lists.
       * Full path: `meta.function.parameters`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
       */
      parameters: null,
      /**
       * Represents the `meta.function.return-type` scope.
       * Return type annotations.
       * Full path: `meta.function.return-type`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
       */
      return_type: null,
    },
    /**
     * Represents the `meta.namespace` scope.
     * Namespace/module definitions.
     * Full path: `meta.namespace`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    namespace: null,
    /**
     * Represents the `meta.preprocessor` scope.
     * Preprocessor statements.
     * Full path: `meta.preprocessor`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    preprocessor: null,
    /**
     * Represents the `meta.annotation` scope.
     * Annotations/decorators.
     * Full path: `meta.annotation`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    annotation: {
      /**
       * Represents the `meta.annotation.identifier` scope.
       * Annotation names.
       * Full path: `meta.annotation.identifier`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
       */
      identifier: null,
      /**
       * Represents the `meta.annotation.parameters` scope.
       * Annotation parameters.
       * Full path: `meta.annotation.parameters`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
       */
      parameters: null,
    },
    /**
     * Represents the `meta.path` scope.
     * Qualified identifiers.
     * Full path: `meta.path`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    path: null,
    /**
     * Represents the `meta.function-call` scope.
     * Function invocations.
     * Full path: `meta.function-call`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    function_call: null,
    /**
     * Represents the `meta.block` scope.
     * Code blocks `{}`.
     * Full path: `meta.block`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    block: null,
    /**
     * Represents the `meta.braces` scope.
     * Alternative for curly braces.
     * Full path: `meta.braces`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    braces: null,
    /**
     * Represents the `meta.group` scope.
     * Grouped expressions `()`.
     * Full path: `meta.group`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    group: null,
    /**
     * Represents the `meta.parens` scope.
     * Alternative for parentheses.
     * Full path: `meta.parens`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    parens: null,
    /**
     * Represents the `meta.brackets` scope.
     * Bracket expressions `[]`.
     * Full path: `meta.brackets`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    brackets: null,
    /**
     * Represents the `meta.generic` scope.
     * Generic type parameters `<>`.
     * Full path: `meta.generic`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    generic: null,
    /**
     * Represents the `meta.tag` scope.
     * Complete HTML/XML tags.
     * Full path: `meta.tag`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    tag: null,
    /**
     * Represents the `meta.paragraph` scope.
     * Paragraphs in markup.
     * Full path: `meta.paragraph`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    paragraph: null,
    /**
     * Represents the `meta.string` scope.
     * Complete string literals.
     * Full path: `meta.string`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    string: null,
    /**
     * Represents the `meta.interpolation` scope.
     * String interpolation.
     * Full path: `meta.interpolation`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    interpolation: null,
    /**
     * Represents the `meta.toc-list` scope.
     * Table of contents entries.
     * Full path: `meta.toc-list`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#meta)
     */
    toc_list: null,
  };

```

### src/scopes/well-known/punctuation.ts

```ts
/**
 * Root scope for `punctuation`.
 * Structural and syntactic punctuation. Use specific subtypes for precise editor behavior.
 * Full path: `punctuation`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
 * 
 * @example
 * ```typescript
 * scopes.punctuation.separator // "punctuation.separator"
 * scopes.punctuation.definition.string.begin("js") // "punctuation.definition.string.begin.js"
 * scopes.punctuation.section.block.begin // "punctuation.section.block.begin"
 * ```
 */
export const PUNCTUATION_SCOPE = {
    /**
     * Represents the `punctuation.separator` scope.
     * Commas, colons.
     * Full path: `punctuation.separator`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
     */
    separator: {
      /**
       * Represents the `punctuation.separator.continuation` scope.
       * Line continuation characters.
       * Full path: `punctuation.separator.continuation`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      continuation: null,
      /**
       * Represents the `punctuation.separator.comma` scope.
       * Comma separators.
       * Full path: `punctuation.separator.comma`
       */
      comma: null,
    },
    /**
     * Represents the `punctuation.terminator` scope.
     * Semicolons, statement terminators.
     * Full path: `punctuation.terminator`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
     */
    terminator: null,
    /**
     * Represents the `punctuation.accessor` scope.
     * Member access (`.`, `->`, `::`).
     * Full path: `punctuation.accessor`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
     */
    accessor: null,
    /**
     * Represents the `punctuation.definition` scope.
     * Punctuation that defines other scopes.
     * Full path: `punctuation.definition`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
     */
    definition: {
      /**
       * Represents the `punctuation.definition.comment` scope.
       * Comment delimiters.
       * Full path: `punctuation.definition.comment`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      comment: null,
      /**
       * Represents the `punctuation.definition.string` scope.
       * String quote punctuation.
       * Full path: `punctuation.definition.string`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      string: {
        /**
         * Represents the `punctuation.definition.string.begin` scope.
         * String opening quotes.
         * Full path: `punctuation.definition.string.begin`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        begin: null,
        /**
         * Represents the `punctuation.definition.string.end` scope.
         * String closing quotes.
         * Full path: `punctuation.definition.string.end`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        end: null,
      },
      /**
       * Represents the `punctuation.definition.keyword` scope.
       * Keyword punctuation.
       * Full path: `punctuation.definition.keyword`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      keyword: null,
      /**
       * Represents the `punctuation.definition.variable` scope.
       * Variable symbols (`$` in PHP).
       * Full path: `punctuation.definition.variable`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      variable: null,
      /**
       * Represents the `punctuation.definition.annotation` scope.
       * Annotation symbols.
       * Full path: `punctuation.definition.annotation`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      annotation: null,
      /**
       * Represents the `punctuation.definition.generic` scope.
       * Generic type punctuation.
       * Full path: `punctuation.definition.generic`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      generic: {
        /**
         * Represents the `punctuation.definition.generic.begin` scope.
         * Generic opening delimiters `<`.
         * Full path: `punctuation.definition.generic.begin`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        begin: null,
        /**
         * Represents the `punctuation.definition.generic.end` scope.
         * Generic closing delimiters `>`.
         * Full path: `punctuation.definition.generic.end`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        end: null,
      },
      /**
       * Represents the `punctuation.definition.template-string` scope.
       * Template string delimiters (backticks).
       * Full path: `punctuation.definition.template-string`
       */
      'template-string': {
        /**
         * Represents the `punctuation.definition.template-string.begin` scope.
         * Template string opening delimiters `` ` ``.
         * Full path: `punctuation.definition.template-string.begin`
         */
        begin: null,
        /**
         * Represents the `punctuation.definition.template-string.end` scope.
         * Template string closing delimiters `` ` ``.
         * Full path: `punctuation.definition.template-string.end`
         */
        end: null,
      },
      /**
       * Represents the `punctuation.definition.template-expression` scope.
       * Template expression delimiters.
       * Full path: `punctuation.definition.template-expression`
       */
      'template-expression': {
        /**
         * Represents the `punctuation.definition.template-expression.begin` scope.
         * Template expression opening delimiters `${`.
         * Full path: `punctuation.definition.template-expression.begin`
         */
        begin: null,
        /**
         * Represents the `punctuation.definition.template-expression.end` scope.
         * Template expression closing delimiters `}`.
         * Full path: `punctuation.definition.template-expression.end`
         */
        end: null,
      },
    },
    /**
     * Represents the `punctuation.section` scope.
     * Section delimiters.
     * Full path: `punctuation.section`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
     */
    section: {
      /**
       * Represents the `punctuation.section.block` scope.
       * Block delimiters `{}`.
       * Full path: `punctuation.section.block`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      block: {
        /**
         * Represents the `punctuation.section.block.begin` scope.
         * Block opening delimiters `{`.
         * Full path: `punctuation.section.block.begin`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        begin: null,
        /**
         * Represents the `punctuation.section.block.end` scope.
         * Block closing delimiters `}`.
         * Full path: `punctuation.section.block.end`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        end: null,
      },
      /**
       * Represents the `punctuation.section.group` scope.
       * Group delimiters `()`.
       * Full path: `punctuation.section.group`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      group: {
        /**
         * Represents the `punctuation.section.group.begin` scope.
         * Group opening delimiters `(`.
         * Full path: `punctuation.section.group.begin`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        begin: null,
        /**
         * Represents the `punctuation.section.group.end` scope.
         * Group closing delimiters `)`.
         * Full path: `punctuation.section.group.end`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        end: null,
      },
      /**
       * Represents the `punctuation.section.parens` scope.
       * Alternative for parentheses.
       * Full path: `punctuation.section.parens`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      parens: {
        /**
         * Represents the `punctuation.section.parens.begin` scope.
         * Parentheses opening delimiters.
         * Full path: `punctuation.section.parens.begin`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        begin: null,
        /**
         * Represents the `punctuation.section.parens.end` scope.
         * Parentheses closing delimiters.
         * Full path: `punctuation.section.parens.end`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        end: null,
      },
      /**
       * Represents the `punctuation.section.brackets` scope.
       * Bracket delimiters `[]`.
       * Full path: `punctuation.section.brackets`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      brackets: {
        /**
         * Represents the `punctuation.section.brackets.begin` scope.
         * Bracket opening delimiters `[`.
         * Full path: `punctuation.section.brackets.begin`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        begin: null,
        /**
         * Represents the `punctuation.section.brackets.end` scope.
         * Bracket closing delimiters `]`.
         * Full path: `punctuation.section.brackets.end`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        end: null,
      },
      /**
       * Represents the `punctuation.section.braces` scope.
       * Alternative for curly braces.
       * Full path: `punctuation.section.braces`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      braces: {
        /**
         * Represents the `punctuation.section.braces.begin` scope.
         * Braces opening delimiters.
         * Full path: `punctuation.section.braces.begin`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        begin: null,
        /**
         * Represents the `punctuation.section.braces.end` scope.
         * Braces closing delimiters.
         * Full path: `punctuation.section.braces.end`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        end: null,
      },
      /**
       * Represents the `punctuation.section.interpolation` scope.
       * Interpolation delimiters.
       * Full path: `punctuation.section.interpolation`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
       */
      interpolation: {
        /**
         * Represents the `punctuation.section.interpolation.begin` scope.
         * Interpolation opening delimiters.
         * Full path: `punctuation.section.interpolation.begin`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        begin: null,
        /**
         * Represents the `punctuation.section.interpolation.end` scope.
         * Interpolation closing delimiters.
         * Full path: `punctuation.section.interpolation.end`
         * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#punctuation)
         */
        end: null,
      },
    },
  };
```

### src/scopes/well-known/storage.ts

```ts
/**
 * Root scope for `storage`.
 * Keywords affecting how variables, functions, or data structures are stored or accessed.
 * Full path: `storage`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
 * 
 * @example
 * ```typescript
 * scopes.storage.type.function // "storage.type.function"
 * scopes.storage.modifier("js") // "storage.modifier.js"
 * scopes.storage.type.class // "storage.type.class"
 * ```
 */
export const STORAGE_SCOPE = {
    /**
     * Represents the `storage.type` scope.
     * Type keywords (`int`, `bool`, `char`).
     * Full path: `storage.type`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
     */
    type: {
      /**
       * Represents the `storage.type.function` scope.
       * Function keywords (`def`, `function`) + `keyword.declaration.function`.
       * Full path: `storage.type.function`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      function: null,
      /**
       * Represents the `storage.type.class` scope.
       * Class keywords (`class`) + `keyword.declaration.class`.
       * Full path: `storage.type.class`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      class: null,
      /**
       * Represents the `storage.type.struct` scope.
       * Struct keywords + `keyword.declaration.struct`.
       * Full path: `storage.type.struct`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      struct: null,
      /**
       * Represents the `storage.type.enum` scope.
       * Enum keywords + `keyword.declaration.enum`.
       * Full path: `storage.type.enum`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      enum: null,
      /**
       * Represents the `storage.type.union` scope.
       * Union keywords + `keyword.declaration.union`.
       * Full path: `storage.type.union`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      union: null,
      /**
       * Represents the `storage.type.trait` scope.
       * Trait keywords + `keyword.declaration.trait`.
       * Full path: `storage.type.trait`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      trait: null,
      /**
       * Represents the `storage.type.interface` scope.
       * Interface keywords + `keyword.declaration.interface`.
       * Full path: `storage.type.interface`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      interface: null,
      /**
       * Represents the `storage.type.impl` scope.
       * Implementation keywords + `keyword.declaration.impl`.
       * Full path: `storage.type.impl`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      impl: null,
      /**
       * Represents the `storage.type.type` scope.
       * Type keywords (`int`, `bool`, `char`).
       * Full path: `storage.type.type`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      type: null,
      /**
       * Represents the `storage.type.annotation` scope.
       * Annotation keywords + `keyword.declaration.annotation`.
       * Full path: `storage.type.annotation`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      annotation: null,
      /**
       * Represents the `storage.type.primitive` scope.
       * Primitive keywords + `keyword.declaration.primitive`.
       * Full path: `storage.type.primitive`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
       */
      primitive: null,
    },

    /**
     * Represents the `storage.modifier` scope.
     * Storage modifiers (`static`, `const`, `public`, `private`).
     * Full path: `storage.modifier`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#storage)
     */
    modifier: null,
  };
```

### src/scopes/well-known/string.ts

```ts
/**
 * Root scope for `string`.
 * String literals and related constructs. Use `meta.string` for entire strings including punctuation.
 * Full path: `string`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#string)
 * 
 * @example
 * ```typescript
 * scopes.string.quoted.single // "string.quoted.single"
 * scopes.string.quoted.double("js") // "string.quoted.double.js"
 * scopes.string.regexp // "string.regexp"
 * ```
 */
export const STRING_SCOPE = {
    /**
     * Represents the `string.quoted` scope.
     * Quoted strings with various quote styles.
     * Full path: `string.quoted`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#string)
     */
    quoted: {
      /**
       * Represents the `string.quoted.single` scope.
       * Single-quoted strings.
       * Full path: `string.quoted.single`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#string)
       */
      single: null,
      /**
       * Represents the `string.quoted.double` scope.
       * Double-quoted strings.
       * Full path: `string.quoted.double`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#string)
       */
      double: null,
      /**
       * Represents the `string.quoted.triple` scope.
       * Triple-quoted strings.
       * Full path: `string.quoted.triple`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#string)
       */
      triple: null,
      /**
       * Represents the `string.quoted.other` scope.
       * Other quoting styles.
       * Full path: `string.quoted.other`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#string)
       */
      other: null,
    },

    /**
     * Represents the `string.unquoted` scope.
     * Unquoted strings (`shell`, `batch`).
     * Full path: `string.unquoted`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#string)
     */
    unquoted: null,

    /**
     * Represents the `string.regexp` scope.
     * Regular expression literals.
     * Full path: `string.regexp`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#string)
     */
    regexp: null,
  };
```

### src/scopes/well-known/support.ts

```ts
/**
 * Root scope for `support`.
 * Elements provided by frameworks, libraries, and language runtimes (as opposed to user-defined elements).
 * Many syntaxes also apply these to unrecognized user constructs, effectively scoping all user-defined elements.
 * Full path: `support`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#support)
 * 
 * @example
 * ```typescript
 * scopes.support.function // "support.function"
 * scopes.support.class("js") // "support.class.js"
 * scopes.support.constant // "support.constant"
 * ```
 */
export const SUPPORT_SCOPE = {
    /**
     * Represents the `support.function` scope.
     * Library functions (`console.log`, `NSLog`).
     * Full path: `support.function`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#support)
     */
    function: {
      /**
       * Represents the `support.function.builtin` scope.
       * Built-in functions provided by the language.
       * Full path: `support.function.builtin`
       */
      builtin: null,
    },

    /**
     * Represents the `support.class` scope.
     * Library classes.
     * Full path: `support.class`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#support)
     */
    class: null,

    /**
     * Represents the `support.type` scope.
     * Library types.
     * Full path: `support.type`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#support)
     */
    type: null,

    /**
     * Represents the `support.constant` scope.
     * Library constants.
     * Full path: `support.constant`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#support)
     */
    constant: null,

    /**
     * Represents the `support.variable` scope.
     * Library variables.
     * Full path: `support.variable`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#support)
     */
    variable: null,

    /**
     * Represents the `support.module` scope.
     * Library modules.
     * Full path: `support.module`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#support)
     */
    module: null,
  };
```

### src/scopes/well-known/variable.ts

```ts
/**
 * Root scope for `variable`.
 * Variable names and identifiers representing mutable data.
 * Apply `punctuation.definition.variable` to variable prefixes like `$` in PHP.
 * Full path: `variable`
 * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#variable)
 * 
 * @example
 * ```typescript
 * scopes.variable.other.readwrite // "variable.other.readwrite"
 * scopes.variable.language("js") // "variable.language.js"
 * scopes.variable.parameter // "variable.parameter"
 * ```
 */
export const VARIABLE_SCOPE = {
    /**
     * Represents the `variable.other` scope.
     * Generic variables.
     * Full path: `variable.other`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#variable)
     */
    other: {
      /**
       * Represents the `variable.other.readwrite` scope.
       * Mutable variables.
       * Full path: `variable.other.readwrite`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#variable)
       */
      readwrite: null,
      /**
       * Represents the `variable.other.constant` scope.
       * Immutable variables.
       * Full path: `variable.other.constant`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#variable)
       */
      constant: null,
      /**
       * Represents the `variable.other.member` scope.
       * Object properties/fields.
       * Full path: `variable.other.member`
       * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#variable)
       */
      member: null,
    },

    /**
     * Represents the `variable.language` scope.
     * Language-reserved variables (`this`, `self`, `super`).
     * Full path: `variable.language`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#variable)
     */
    language: null,

    /**
     * Represents the `variable.parameter` scope.
     * Function parameters.
     * Full path: `variable.parameter`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#variable)
     */
    parameter: null,

    /**
     * Represents the `variable.function` scope.
     * Function names (when called, not defined).
     * Full path: `variable.function`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#variable)
     */
    function: null,

    /**
     * Represents the `variable.annotation` scope.
     * Annotation identifiers.
     * Full path: `variable.annotation`
     * From: [textmate-scopes.md](packages/tmgrammar-toolkit/docs/textmate-scopes.md#variable)
     */
    annotation: null,
  };

```

### src/terminals/chars.ts

```ts
export const DOT = /\\./;
```

### src/terminals/comments.ts

```ts
/**
 * Comment pattern terminals for TextMate grammars  
 * Common comment delimiter patterns across languages
 */

/**
 * Comment delimiter patterns
 */
export const COMMENT = {  
  /** Double slash comment */
  SLASHES: /\/\//,
  
  /** Block comment start */
  BLOCK: {
    START: /\/\*/,
    END: /\*\//,
  },
} as const;

```

### src/terminals/identifiers.ts

```ts
/**
 * Identifier pattern terminals for TextMate grammars
 * Common patterns for various identifier naming conventions
 */

/** Standard programming identifier */
export const ID = /[a-zA-Z_][a-zA-Z0-9_]*/;

/** Camel case identifier */
export const CAMEL_CASE_ID = /[a-z][a-zA-Z0-9]*/;

/** Pascal case identifier */
export const PASCAL_CASE_ID = /[A-Z][a-zA-Z0-9]*/;

/** Snake case identifier */
export const SNAKE_CASE_ID = /[a-z][a-z0-9_]*/;

/** Constant identifier (all caps) */
export const CONSTANT_ID = /[A-Z][A-Z0-9_]*/;

/** Kebab case identifier */
export const KEBAB_CASE_ID = /[a-z][a-z0-9-]*/; 
```

### src/terminals/index.ts

```ts
//@index('./*.ts', f => `export * from '${f.path}.js'`)
export * from './chars.js'
export * from './comments.js'
export * from './identifiers.js'
export * from './markers.js'
export * from './numbers.js'
export * from './operators.js'
export * from './strings.js'
export * from './whitespace.js'
//@endindex
```

### src/terminals/markers.ts

```ts
/**
 * Language-specific pattern terminals for TextMate grammars
 * Common patterns that appear across many programming languages
 */

/** Word boundary pattern */
export const WB = /\b/;

/** End of line */
export const EOL = /$/;

/** Start of line */
export const BOL = /^/; 
```

### src/terminals/numbers.ts

```ts
/**
 * Number pattern terminals for TextMate grammars
 * Common regex patterns for various number formats
 */

/**
 * Number patterns for different numeric formats
 */
export const NUM = {
  /** Decimal numbers with optional scientific notation */
  DEC: /(?<!\$)(?:(?:\b[0-9][0-9_]*(\.[0-9][0-9_]*)?|\b\.[0-9][0-9_]*)([eE][+-]?[0-9][0-9_]*)?(n)?|\b[0-9][0-9_]*n)\b(?!\$)/,
  
  /** Hexadecimal numbers */
  HEX: /\b(?<!\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\b(?!\$)/,
  
  /** Binary numbers */
  BIN: /\b(?<!\$)0(?:b|B)[01][01_]*(n)?\b(?!\$)/,
  
  /** Octal numbers */
  OCT: /\b(?<!\$)0(?:o|O)?[0-7][0-7_]*(n)?\b(?!\$)/,
  
  /** Simple integer */
  INT: /\b-?\d+\b(?!\.)/,
  
  /** Simple float */
  FLOAT: /\b-?\d+\.\d+([eE][+-]?\d+)?\b/,
} as const;
```

### src/terminals/operators.ts

```ts
/**
 * Operator pattern terminals for TextMate grammars
 * Common operator patterns across programming languages
 */

/**
 * Operator patterns for different operator types
 */
export const OP = {
  /** Assignment operators */
  ANY_ASSIGNMENT: /=|\+=|-=|\*=|\/=|%=/,
  
  /** Comparison operators */
  ANY_COMPARISON: /==|!=|<=|>=|<|>/,
  
  /** Logical operators */
  ANY_LOGICAL: /&&|\|\||!/,
  
  /** Arithmetic operators */
  ARITHMETIC: /\+|-|\*|\/|%/,
  
  /** Arrow operator */
  ARROW: /->/,
  
  /** Fat arrow */
  FAT_ARROW: /=>/,
} as const;

```

### src/terminals/strings.ts

```ts
/**
 * String pattern terminals for TextMate grammars
 * Patterns for string delimiters and escape sequences
 */

/** Common escape sequences */
export const COMMON_ESCAPE = /\\(x[0-9A-Fa-f]{2}|u[0-9A-Fa-f]{4}|u\{[0-9A-Fa-f]+\}|[0-2][0-7]{0,2}|3[0-6][0-7]?|37[0-7]?|[4-7][0-7]?|.|$)/;

/** Simple escape sequences */
export const SIMPLE_ESCAPE = /\\./;

/** Unicode escape sequences only */
export const UNICODE_ESCAPE = /\\u[0-9A-Fa-f]{4}|\\u\{[0-9A-Fa-f]+\}/;

/** Hex escape sequences */
export const HEX_ESCAPE = /\\x[0-9A-Fa-f]{2}/;

/**
 * Quote patterns
 */
export const QUOTES = {
  ANY: /['"]/,
  ANY_TRIPLET: /'''|"""/,
} as const;
```

### src/terminals/whitespace.ts

```ts
/**
 * Whitespace pattern terminals for TextMate grammars
 * Common patterns for various whitespace matching needs
 */

/** Required spaces */
export const REQ_SPACES = /[ ]+/;

/** Optional spaces */
export const OPT_SPACES = /[ ]*/;

/** Tabs and spaces */
export const TABS_AND_SPACES = /[ \t]+/;

/** Newlines */
export const NEWLINES = /[\r\n]+/;

/** Any whitespace */
export const ANY_WHITESPACE = /\s+/; 
```

### src/testing/helpers.ts

```ts
import { execSync } from 'node:child_process';
import type { DeclarativeTestOptions, SnapshotTestOptions } from './types.js';

/**
 * Create a programmatic tester for the given grammar
 * Uses our existing scope.test.ts utilities for detailed token-by-token testing
 */
export const test = (grammarPath: string, scopeName: string) => {
  const { createTesterFromFile } = require('./programmatic.js');
  return createTesterFromFile(grammarPath, scopeName);
};

/**
 * Run declarative tests using vscode-tmgrammar-test CLI
 * Supports the .test.lang file format with embedded scope assertions
 */
export function declarativeTest(testFiles: string, options: DeclarativeTestOptions = {}) {
  const args = [testFiles];

  if (options.compact) {
    args.push('-c');
  }

  if (options.grammar) {
    args.push('-g', options.grammar);
  }

  if (options.config) {
    args.push('--config', options.config);
  }

  const command = `vscode-tmgrammar-test ${args.join(' ')}`;

  try {
    const result = execSync(command, {
      encoding: 'utf-8',
      stdio: ['inherit', 'pipe', 'pipe']
    });
    return {
      success: true,
      output: result,
      command
    };
  } catch (error: any) {
    return {
      success: false,
      output: error.stdout || '',
      error: error.stderr || '',
      command,
      exitCode: error.status
    };
  }
}

/**
 * Run snapshot tests using vscode-tmgrammar-test
 * Generates and compares snapshots of tokenization output
 */
export function snapshot(testFiles: string, options: SnapshotTestOptions = {}) {
  const args = [testFiles];

  if (options.updateSnapshots) {
    args.push('-u');
  }

  if (options.grammar) {
    args.push('-g', options.grammar);
  }

  if (options.config) {
    args.push('--config', options.config);
  }

  if (options.printNotModified) {
    args.push('--printNotModified');
  }

  if (options.expandDiff) {
    args.push('--expandDiff');
  }

  const command = `vscode-tmgrammar-snap ${args.join(' ')}`;

  try {
    const result = execSync(command, {
      encoding: 'utf-8',
      stdio: ['inherit', 'pipe', 'pipe']
    });
    return {
      success: true,
      output: result,
      command
    };
  } catch (error: any) {
    return {
      success: false,
      output: error.stdout || '',
      error: error.stderr || '',
      command,
      exitCode: error.status
    };
  }
}

```

### src/testing/index.ts

```ts
/**
 * Testing utilities for TextMate grammars
 * 
 * This module provides both programmatic and declarative testing capabilities
 * for TextMate grammars, acting as a facade over vscode-tmgrammar-test.
 */

// Programmatic testing API
export {
  ProgrammaticTester,
  createTesterFromFile,
  createTesterFromContent,
  tokenizeWithGrammar,
} from './programmatic.js';

// Declarative testing helpers  
export {
  test,
  declarativeTest,
  snapshot,
} from './helpers.js';

// Types
export type {
  TokenInfo,
  GrammarInitOptions,
  DeclarativeTestOptions,
  SnapshotTestOptions,
  TestResult,
} from './types.js'; 
```

### src/testing/programmatic.ts

```ts
/**
 * Programmatic testing utilities - Wrapper around existing scope.test.ts functionality
 * 
 * This module provides a programmatic API for testing grammars by wrapping
 * the existing tokenization and scope validation utilities from scope.test.ts.
 */

import * as fs from 'node:fs';
import * as path from 'node:path';
import { createRequire } from 'node:module';
import type { GrammarInitOptions, TokenInfo } from './types.js';
import type { IGrammar, StateStack } from 'vscode-textmate';
import type { GrammarInput } from '#src';
import { OnigScanner, OnigString, loadWASM } from 'onigasm';

const createRequireFn = createRequire(__filename);

const { Registry } = createRequireFn('vscode-textmate');

/**
 * Programmatic tester for validating TextMate grammar tokenization.
 * 
 * Provides methods to tokenize code and verify that tokens receive the expected
 * scopes. Uses the same VS Code TextMate engine for accurate testing.
 * 
 * @example
 * ```typescript
 * const tester = new ProgrammaticTester({
 *   grammarPath: './my-grammar.json',
 *   scopeName: 'source.mylang'
 * });
 * 
 * await tester.initialize();
 * const tokens = await tester.tokenize('if (condition) {}');
 * tester.expectTokenScope(tokens, 'if', 'keyword.control.mylang');
 * ```
 */
export class ProgrammaticTester {
  private grammar: IGrammar | null = null;
  private initialized = false;

  /**
   * Creates a new programmatic tester instance.
   * 
   * @param options - Configuration for grammar loading and testing
   */
  constructor(private options: GrammarInitOptions) {}

  /**
   * Initializes the testing environment by loading the Oniguruma WASM engine
   * and parsing the grammar file. Must be called before using other methods.
   * 
   * @throws {Error} If grammar file is not found or invalid
   */
  async initialize(): Promise<void> {
    if (this.initialized) return;

    try {
      // Load WASM for Oniguruma
      const onigasmPath = require.resolve("onigasm");
      const wasmPath = path.resolve(path.dirname(onigasmPath), "onigasm.wasm");
      const wasmBin = await fs.promises.readFile(wasmPath);
      await loadWASM(wasmBin.buffer as any);

      // Load grammar content
      let grammarContent: GrammarInput;
      if (this.options.grammar) {
        grammarContent = this.options.grammar;
      } else if (this.options.grammarPath) {
        if (!fs.existsSync(this.options.grammarPath)) {
          throw new Error(`Grammar file not found at ${this.options.grammarPath}`);
        }
        grammarContent = JSON.parse(fs.readFileSync(this.options.grammarPath, 'utf-8'));
      } else {
        throw new Error('Either grammarPath or grammarContent must be provided');
      }

      // Create registry with grammar
      const registry = new Registry({
        onigLib: Promise.resolve({
          createOnigScanner: (patterns: string[]) => new OnigScanner(patterns),
          createOnigString: (str: string) => new OnigString(str)
        }),
        loadGrammar: async (scopeName: string) => {
          if (scopeName === this.options.scopeName) {
            return grammarContent;
          }
          
          // Check for embedded grammars
          if (this.options.embeddedGrammars?.[scopeName]) {
            return this.options.embeddedGrammars[scopeName];
          }
          
          // Provide placeholder grammars for common embedded languages
          if (scopeName === 'source.js') {
            return {
              scopeName: 'source.js',
              patterns: [{ "match": ".*", "name": "source.js.embedded" }]
            };
          }
          if (scopeName === 'source.ts') {
            return {
              scopeName: 'source.ts', 
              patterns: [{ "match": ".*", "name": "source.ts.embedded" }]
            };
          }
          
          return null;
        },
      });

      this.grammar = await registry.loadGrammar(this.options.scopeName);
      this.initialized = true;
    } catch (error) {
      console.error('Failed to initialize grammar:', error);
      throw error;
    }
  }

  /**
   * Tokenize code and extract tokens with scope information (copied from scope.test.ts)
   */
  async tokenize(code: string): Promise<TokenInfo[]> {
    if (!this.initialized) {
      await this.initialize();
    }

    if (!this.grammar) {
      throw new Error('Grammar not initialized');
    }

    const lines = code.split('\n');
    const results: TokenInfo[] = [];
    let ruleStack: StateStack | null = null;

    for (let i = 0; i < lines.length; i++) {
      const line = lines[i];
      const result = this.grammar.tokenizeLine(line, ruleStack);
      
      for (const token of result.tokens) {
        const tokenText = line.substring(token.startIndex, token.endIndex);
        if (tokenText.trim()) { // Only include non-whitespace tokens
          results.push({
            text: tokenText,
            scopes: token.scopes,
            startIndex: token.startIndex,
            endIndex: token.endIndex,
            line: i
          });
        }
      }
      
      ruleStack = result.ruleStack;
    }

    return results;
  }

  /**
   * Check if a token has the expected scope (copied from scope.test.ts)
   */
  hasExpectedScope(token: TokenInfo, expectedScope: string): boolean {
    return token.scopes.some(scope => 
      scope === expectedScope || 
      scope.includes(expectedScope) ||
      expectedScope.includes(scope)
    );
  }

  /**
   * Find tokens by text
   */
  findTokens(tokens: TokenInfo[], text: string): TokenInfo[] {
    return tokens.filter(token => token.text === text);
  }

  /**
   * Find first token by text
   */
  findToken(tokens: TokenInfo[], text: string): TokenInfo | undefined {
    return tokens.find(token => token.text === text);
  }

  /**
   * Assert that a token has the expected scope
   */
  expectTokenScope(tokens: TokenInfo[], tokenText: string, expectedScope: string): boolean {
    const token = this.findToken(tokens, tokenText);
    if (!token) {
      throw new Error(`Token "${tokenText}" not found`);
    }
    
    const hasScope = this.hasExpectedScope(token, expectedScope);
    if (!hasScope) {
      throw new Error(
        `Token "${tokenText}" does not have expected scope "${expectedScope}". ` +
        `Actual scopes: ${token.scopes.join(', ')}`
      );
    }
    
    return true;
  }
}

/**
 * Create a programmatic tester from a grammar file
 */
export function createTesterFromFile(grammarPath: string, scopeName: string): ProgrammaticTester {
  return new ProgrammaticTester({ grammarPath, scopeName });
}

/**
 * Create a programmatic tester from grammar content
 */
export function createTesterFromContent(grammarContent: any, scopeName: string): ProgrammaticTester {
  return new ProgrammaticTester({ grammar: grammarContent, scopeName });
}

/**
 * Convenience function to tokenize code with a grammar file
 */
export async function tokenizeWithGrammar(
  code: string, 
  grammarPath: string, 
  scopeName: string
): Promise<TokenInfo[]> {
  const tester = createTesterFromFile(grammarPath, scopeName);
  return await tester.tokenize(code);
} 
```

### src/testing/types.ts

```ts
/**
 * Options for declarative testing with vscode-tmgrammar-test
 */

import type { GrammarInput } from "#src/types";

export interface DeclarativeTestOptions {
  /** Display output in compact format for VSCode problem matchers */
  compact?: boolean;
  /** Path to grammar file */
  grammar?: string;
  /** Path to language configuration (package.json) */
  config?: string;
}
/**
 * Options for snapshot testing with vscode-tmgrammar-snap
 */

export interface SnapshotTestOptions {
  /** Update snapshot files with new changes */
  updateSnapshots?: boolean;
  /** Path to grammar file */
  grammar?: string;
  /** Path to language configuration (package.json) */
  config?: string;
  /** Include not modified scopes in output */
  printNotModified?: boolean;
  /** Produce each diff on two lines prefixed with "++" and "--" */
  expandDiff?: boolean;
}
/**
 * Result of running a test command
 */

export interface TestResult {
  success: boolean;
  output: string;
  error?: string;
  command: string;
  exitCode?: number;
}

/**
 * Token information extracted from grammar tokenization
 */
export interface TokenInfo {
  text: string;
  scopes: string[];
  startIndex: number;
  endIndex: number;
  line: number;
}

/**
 * Options for initializing a grammar for testing
 */
export interface GrammarInitOptions {
  /** Path to the grammar file (.tmLanguage.json) */
  grammarPath?: string;
  /** Grammar content as object (alternative to grammarPath) */
  grammar?: GrammarInput;
  /** Grammar scope name (e.g., 'source.rcl') */
  scopeName: string;
  /** Additional grammars for embedded languages */
  embeddedGrammars?: Record<string, any>;
}

```

### src/types.ts

```ts
/**
 * Core types for TextMate grammar definitions
 * Direct mapping to tmlanguage schema with strong type safety
 */

import type { Scope } from './scopes/types.js';

/**
 * The URL to the TMLanguage JSON schema, used for validation and tooling.
 *
 * We vendor this schema from `martinring/tmlanguage` to ensure stability and
 * avoid external dependencies at runtime. The original schema can be found at:
 * https://github.com/martinring/tmlanguage
 *
 * @credits martinring
 */
export const schema = "https://raw.githubusercontent.com/svallory/tmgrammar-toolkit/main/vendor/schemas/tmlanguage.json";

/**
 * Special scope that indicates a larger construct that doesn't get a single color.
 * Expanded to meta.<key>.<grammar name> during emit.
 */
export const meta: unique symbol = Symbol("meta");

/**
 * Valid scope value - can be a string, result from scopes API, or meta symbol
 */
export type ScopeValue = string | Scope<string, string, string> | typeof meta;


/**
 * Base interface for all rules that must have a unique key for repository management
 */
export interface RuleKey {
  /** Rule's unique key through which identifies the rule in the repository. */
  key: string;
}

/**
 * A type representing a regular expression, either as a string or a RegExp object.
 */
export type RegexValue = string | RegExp;
export type RegexValueList = Array<RegexValue | RegexValue[]>;

/**
 * Scope assignment for a rule - can be a string, our scopes API, or meta symbol
 */
export interface RuleScope {
  /**
   * The TextMate scope that gets assigned to a match and colored by a theme.
   * Can be a string, result from scopes API, or meta symbol.
   * See https://macromates.com/manual/en/language_grammars#naming_conventions
   */
  scope: ScopeValue;
}

/**
 * Rules that can contain nested patterns
 */
export interface RulePatterns {
  patterns: Pattern[];
}

/**
 * Pattern can be a full rule definition, a rule reference, or a basic include pattern
 */
export type Pattern = Rule | RuleReference | BasicIncludePattern;

/**
 * Reference to a rule that will be converted to an include statement
 * Must be a rule with a key that exists in the repository
 */
export type RuleReference = MatchRule | BeginEndRule | IncludeRule;

/**
 * Capture group definitions for regex matches
 */
export type Captures = Record<
  string,
  RuleScope | RulePatterns
>;

/**
 * Union type for all possible rule types
 */
export type Rule =
  | MatchRule
  | BeginEndRule
  | IncludeRule
  | BasicIncludePattern;

/**
 * Simple pattern matching rule
 */
export interface MatchRule extends RuleScope, RuleKey {
  match: RegexValue;
  captures?: Captures;
}

/**
 * Begin/end block rule for multi-line constructs
 */
export interface BeginEndRule
  extends RuleKey,
    RuleScope,
    Partial<RulePatterns> {
  begin: RegexValue;
  end: RegexValue;
  beginCaptures?: Captures;
  endCaptures?: Captures;
  /** Optional content scope for text between begin/end */
  contentName?: string;
  /** Optional while pattern as alternative to end */
  while?: RegexValue;
}

/**
 * Include rule that references other patterns
 */
export interface IncludeRule extends RuleKey, RulePatterns {}

/**
 * For simple include directives like { include: '#repositoryKey' }
 */
export interface BasicIncludePattern {
  include: string;
}

/**
 * Type for a repository object
 */
export type Repository = Record<string, Rule>;

/**
 * Complete grammar definition
 */
export interface GrammarInput {
  name: string;
  scopeName: string;
  fileTypes: string[];
  patterns: Rule[];
  repositoryItems?: Rule[];
  firstLineMatch?: RegexValue;
  foldingStartMarker?: RegexValue;
  foldingStopMarker?: RegexValue;
  uuid?: string;
}

/**
 * Complete grammar definition with validation results
 */
export interface Grammar {
  isValid: boolean;
  grammar: GrammarInput;
  repository: Record<string, Rule>;
  errors: GrammarError[];
}

/**
 * Options for emitting grammars
 */
export interface EmitOptions {
  errorSourceFilePath?: string;
}

/**
 * Location information for errors
 */
export interface ErrorLocation {
  /** Source file path */
  filePath?: string;
  /** Rule key or identifier where error occurred */
  ruleKey?: string;
  /** Property name where error occurred */
  property?: string;
  /** Line number in source file */
  line?: number;
  /** Column number in source file */
  column?: number;
  /** Context path (e.g., "patterns[0].match") */
  contextPath?: string;
}

/**
 * Severity levels for errors and warnings
 */
export enum ErrorSeverity {
  ERROR = 'error',
  WARNING = 'warning',
  INFO = 'info'
}

/**
 * Error categories for better classification
 */
export enum ErrorCategory {
  VALIDATION = 'validation',
  REGEX = 'regex',
  SCOPE = 'scope',
  REFERENCE = 'reference',
  SYNTAX = 'syntax',
  SEMANTIC = 'semantic'
}

/**
 * Base grammar error interface
 */
export interface GrammarError {
  /** Error message */
  message: string;
  /** Error severity level */
  severity: ErrorSeverity;
  /** Error category */
  category: ErrorCategory;
  /** Location information */
  location?: ErrorLocation;
  /** Error code for programmatic handling */
  code?: string;
  /** Additional context or suggestions */
  context?: string;
  /** Nested errors (for complex validation) */
  innerErrors?: GrammarError[];
}

/**
 * Grammar validation error class
 */
export class GrammarValidationError extends Error implements GrammarError {
  public readonly severity: ErrorSeverity;
  public readonly category: ErrorCategory;
  public readonly location?: ErrorLocation;
  public readonly code?: string;
  public readonly context?: string;
  public readonly innerErrors?: GrammarError[];

  constructor(
    message: string,
    options: {
      severity?: ErrorSeverity;
      category?: ErrorCategory;
      location?: ErrorLocation;
      code?: string;
      context?: string;
      innerErrors?: GrammarError[];
    } = {}
  ) {
    super(message);
    this.name = 'GrammarValidationError';
    this.severity = options.severity ?? ErrorSeverity.ERROR;
    this.category = options.category ?? ErrorCategory.VALIDATION;
    this.location = options.location;
    this.code = options.code;
    this.context = options.context;
    this.innerErrors = options.innerErrors;
  }

  /**
   * Create a formatted error message with location information
   */
  public getFormattedMessage(): string {
    let formatted = this.message;
    
    if (this.location) {
      const parts: string[] = [];
      
      if (this.location.filePath) {
        parts.push(`File: ${this.location.filePath}`);
      }
      
      if (this.location.line !== undefined) {
        const lineCol = this.location.column !== undefined 
          ? `${this.location.line}:${this.location.column}`
          : `${this.location.line}`;
        parts.push(`Line: ${lineCol}`);
      }
      
      if (this.location.ruleKey) {
        parts.push(`Rule: ${this.location.ruleKey}`);
      }
      
      if (this.location.contextPath) {
        parts.push(`Context: ${this.location.contextPath}`);
      }
      
      if (parts.length > 0) {
        formatted += ` (${parts.join(', ')})`;
      }
    }
    
    if (this.context) {
      formatted += `\n${this.context}`;
    }
    
    return formatted;
  }

  /**
   * Convert to a plain object for serialization
   */
  public toJSON(): GrammarError {
    return {
      message: this.message,
      severity: this.severity,
      category: this.category,
      location: this.location,
      code: this.code,
      context: this.context,
      innerErrors: this.innerErrors
    };
  }
}

/**
 * Helper function to create grammar errors with location context
 */
export function createGrammarError(
  message: string,
  options: {
    severity?: ErrorSeverity;
    category?: ErrorCategory;
    location?: Partial<ErrorLocation>;
    code?: string;
    context?: string;
    innerErrors?: GrammarError[];
  } = {}
): GrammarValidationError {
  return new GrammarValidationError(message, {
    ...options,
    location: options.location ? {
      filePath: options.location.filePath,
      ruleKey: options.location.ruleKey,
      property: options.location.property,
      line: options.location.line,
      column: options.location.column,
      contextPath: options.location.contextPath
    } : undefined
  });
}

/**
 * Output grammar that matches the tmlanguage schema root definition
 */
export interface TMLanguageGrammar {
  name?: string;
  scopeName: string;
  fileTypes?: string[];
  patterns: any[];
  repository?: Record<string, any>;
  firstLineMatch?: string;
  foldingStartMarker?: string;
  foldingStopMarker?: string;
  uuid?: string;
}

 
```

### src/utils/file.ts

```ts
/**
   * Check if a file exists
   */
export const fileExists = async (filePath: string): Promise<boolean> => {
  try {
    const fs = await import('node:fs/promises');
    await fs.access(filePath);
    return true;
  } catch {
    return false;
  }
};

/**
 * Read a JSON file and parse it
 */
export const readJson = async (filePath: string): Promise<any> => {
  const fs = await import('node:fs/promises');
  const content = await fs.readFile(filePath, 'utf-8');
  return JSON.parse(content);
};

/**
 * Write an object to a JSON file
 */
export const writeJson = async (filePath: string, data: any, indent = 2): Promise<void> => {
  const fs = await import('node:fs/promises');
  const content = JSON.stringify(data, null, indent);
  await fs.writeFile(filePath, content, 'utf-8');
};
```

### src/validation/grammar.ts

```ts
import type {
  GrammarInput,
  Grammar,
  Rule,
  Pattern,
  RuleReference,
  BasicIncludePattern,
} from '../types.js';
import { ErrorCollection, errorFactory, ErrorCodes } from '../errors.js';
import { ok, error, type GrammarResult } from '../result.js';

/**
 * Processes and validates a grammar input, discovering repository rules and validating structure.
 * 
 * @param grammar - The grammar input to process
 * @param filePath - Optional file path for error reporting
 * @returns Result containing processed Grammar or validation error
 */
export function processGrammar(grammar: GrammarInput, filePath?: string): GrammarResult<Grammar> {
  const repository = new Map<string, Rule>();
  const errorCollection = new ErrorCollection();
  const discoveredKeys = new Set<string>();
  const factory = errorFactory.withLocation({ filePath });

  function discoverRules(patterns: Pattern[], contextPath = 'patterns') {
    for (let i = 0; i < patterns.length; i++) {
      const pattern = patterns[i];
      const currentContextPath = `${contextPath}[${i}]`;
      
      // It's a rule with a key, so it could be a repository item
      if ('key' in pattern && typeof (pattern as RuleReference).key === 'string') {
        const rule = pattern as RuleReference;
        const ruleFactory = factory.withLocation({ 
          ruleKey: rule.key,
          contextPath: currentContextPath
        });
        
        if (discoveredKeys.has(rule.key)) {
          // If we've seen this key before, check if it's the same object.
          // If not, it's a duplicate key error.
          const existingRule = repository.get(rule.key);
          if (existingRule && existingRule !== rule) {
            errorCollection.add(ruleFactory.reference(
              `Duplicate key found: '${rule.key}'. The same key is used for different rule objects.`,
              rule.key,
              ErrorCodes.DUPLICATE_KEY
            ));
          }
        } else {
          // First time seeing this key, add it to our repo and mark as discovered.
          repository.set(rule.key, rule);
          discoveredKeys.add(rule.key);
        }
      }

      // Recursively process nested patterns
      if ('patterns' in pattern && Array.isArray((pattern as { patterns: Pattern[] }).patterns)) {
        discoverRules((pattern as { patterns: Pattern[] }).patterns, `${currentContextPath}.patterns`);
      }

      // Process captures, which can also contain patterns
      const captureTypes = ['captures', 'beginCaptures', 'endCaptures'] as const;
      for (const captureType of captureTypes) {
        if (captureType in pattern && (pattern as any)[captureType]) {
          const captures = (pattern as any)[captureType] as Record<string, { patterns?: Pattern[] }>;
          for (const [captureIndex, capture] of Object.entries(captures)) {
            if (capture.patterns) {
              discoverRules(capture.patterns, `${currentContextPath}.${captureType}[${captureIndex}].patterns`);
            }
          }
        }
      }
    }
  }

  // Kick off the discovery process with the grammar's top-level patterns
  discoverRules(grammar.patterns, 'grammar.patterns');
  
  // Validate that all `include` directives point to a valid repository item.
  function validateIncludes(patterns: Pattern[], contextPath = 'patterns') {
    for (let i = 0; i < patterns.length; i++) {
      const pattern = patterns[i];
      const currentContextPath = `${contextPath}[${i}]`;
      
      if ('include' in pattern) {
        const include = (pattern as BasicIncludePattern).include;
        if (include.startsWith('#')) {
          const key = include.substring(1);
          if (!repository.has(key)) {
            errorCollection.add(factory.reference(
              `Broken include: rule with key '${key}' not found in the repository.`,
              key,
              ErrorCodes.MISSING_REFERENCE,
              { contextPath: `${currentContextPath}.include` }
            ));
          }
        }
      }
      
      if ('patterns' in pattern && Array.isArray((pattern as { patterns: Pattern[] }).patterns)) {
        validateIncludes((pattern as { patterns: Pattern[] }).patterns, `${currentContextPath}.patterns`);
      }
    }
  }
  
  validateIncludes(grammar.patterns, 'grammar.patterns');

  const result: Grammar = {
    isValid: !errorCollection.hasErrors(),
    grammar,
    repository: Object.fromEntries(repository),
    errors: errorCollection.getAll(),
  };

  if (errorCollection.hasErrors()) {
    return error(errorCollection.getErrors()[0]);
  }

  return ok(result);
}
```

### src/validation/index.ts

```ts
//@index('./*', f => `export * from '${f.path}.js'`)
export * from './grammar.js'
export * from './regex.js'
export * from './scope.js'
//@endindex
```

### src/validation/regex.ts

```ts
/**
 * Result of regex validation
 */
export interface RegexValidationResult {
  valid: boolean;
  pattern: string;
  error?: string;
}

/**
 * Result of validating multiple regex patterns
 */
export interface RegexValidationResults {
  valid: boolean;
  results: Array<{ pattern: string; valid: boolean; error?: string }>;
  errors: Array<{ pattern: string; valid: boolean; error?: string }>;
  totalPatterns: number;
  validPatterns: number;
}

/**
 * Basic regex validation using onigasm
 * This is a minimal wrapper - more comprehensive validation would be in v2.0
 */
export async function validateRegex(pattern: string): Promise<RegexValidationResult> {
  try {
    const { createRequire } = await import('node:module');
    const createRequireFn = createRequire(__filename);
    const { OnigRegExp } = createRequireFn('onigasm');

    // Try to create a scanner with the pattern
    new OnigRegExp(pattern);

    return {
      valid: true,
      pattern
    };
  } catch (error: any) {
    return {
      valid: false,
      pattern,
      error: error.message || 'Invalid regex pattern'
    };
  }
}

/**
 * Validate multiple regex patterns at once
 */
export async function validateRegexPatterns(patterns: string[]): Promise<RegexValidationResults> {
  
  const results = await Promise.all(
    patterns.map(async (pattern) => {
      const result = await validateRegex(pattern);
      return { pattern, valid: result.valid, error: result.error };
    })
  );

  const valid = results.every(r => r.valid);
  const errors = results.filter(r => !r.valid);

  return {
    valid,
    results,
    errors,
    totalPatterns: patterns.length,
    validPatterns: results.filter(r => r.valid).length
  };
}
```

### src/validation/scope.ts

```ts
/**
 * Result of scope name validation
 */
export interface ScopeValidationResult {
  valid: boolean;
  scopeName: string;
  errors: string[];
  warnings: string[];
}

/**
 * Result of validating multiple scope names
 */
export interface ScopeValidationResults {
  valid: boolean;
  results: ScopeValidationResult[];
  errors: ScopeValidationResult[];
  totalScopes: number;
  validScopes: number;
} 

/**
 * Validate scope names according to TextMate conventions
 */
export function validateScopeName(scopeName: string): ScopeValidationResult {
  const errors: string[] = [];
  const warnings: string[] = [];

  // Basic format validation
  if (!scopeName) {
    errors.push('Scope name cannot be empty');
    return { valid: false, scopeName, errors, warnings };
  }

  if (typeof scopeName !== 'string') {
    errors.push('Scope name must be a string');
    return { valid: false, scopeName, errors, warnings };
  }

  // Check for valid characters (letters, numbers, dots, hyphens)
  if (!/^[a-zA-Z0-9.-]+$/.test(scopeName)) {
    errors.push('Scope name contains invalid characters. Only letters, numbers, dots, and hyphens are allowed');
  }

  // Check structure
  const parts = scopeName.split('.');

  if (parts.length < 2) {
    warnings.push('Scope name should have at least two parts separated by dots');
  }

  // Check for common root scopes
  const validRoots = ['source', 'text', 'meta', 'keyword', 'entity', 'variable', 'constant', 'string', 'comment', 'markup'];
  if (!validRoots.includes(parts[0])) {
    warnings.push(`Scope name should start with a common root scope like: ${validRoots.join(', ')}`);
  }

  // Check for empty parts
  if (parts.some(part => part.length === 0)) {
    errors.push('Scope name cannot have empty parts (consecutive dots)');
  }

  // Check for reserved patterns
  if (scopeName.includes('..')) {
    errors.push('Scope name cannot contain consecutive dots');
  }

  if (scopeName.startsWith('.') || scopeName.endsWith('.')) {
    errors.push('Scope name cannot start or end with a dot');
  }

  return {
    valid: errors.length === 0,
    scopeName,
    errors,
    warnings
  };
}

/**
 * Validate multiple scope names
 */
export function validateScopeNames(scopeNames: string[]): ScopeValidationResults {
  const results = scopeNames.map(validateScopeName);
  const valid = results.every(r => r.valid);
  const errors = results.filter(r => !r.valid);

  return {
    valid,
    results,
    errors,
    totalScopes: scopeNames.length,
    validScopes: results.filter(r => r.valid).length
  };
}
```


## Examples

### examples/README.md

```md
# TMGrammar Toolkit Examples

This directory contains comprehensive examples demonstrating how to use the `tmgrammar-toolkit` to create TextMate grammars with best practices.

## 📁 Core Examples

### 🎯 `simple-example.ts` (60 lines)
**Purpose**: Quick introduction to tmgrammar-toolkit fundamentals  
**Features Demonstrated**:
- Type-safe scopes with `scopesFor`
- Pre-built terminal patterns (`COMMENT`, `NUM`, `ID`)
- Regex helpers (`regex.keywords`, `regex.concat`)
- Basic rule types (`MatchRule`, `BeginEndRule`)
- Clean grammar creation with `createGrammar`

**Best for**: First-time users who want to understand the core concepts quickly

### 🏗️ `comprehensive-example.ts` (320+ lines)
**Purpose**: Advanced patterns and production best practices  
**Features Demonstrated**:
- Complex begin/end rules with captures
- Function and class declarations with parameters
- Template literals with interpolation
- Pattern grouping and organization
- Complete grammar with repository management
- Testing and generation utilities
- Multiple string types and escape sequences

**Best for**: Learning advanced patterns and understanding how to structure complex grammars

### 🏭 `tmgrammar-toolkit/`

#### `bicep.ts`
**Purpose**: Real-world language implementation  
**Language**: Bicep (Azure Resource Manager DSL)  
**Features Demonstrated**:
- Complex language with multiple constructs
- Custom scope definitions
- String interpolation with `${}` syntax
- Object and array literals
- Lambda expressions and decorators
- Directive handling
- Advanced regex patterns with helpers

#### `typespec.ts`  
**Purpose**: Complete language grammar definition  
**Language**: TypeSpec (API definition language)  
**Features Demonstrated**:
- Complex recursive patterns
- Doc comments with TSDoc tags
- Type annotations and generics
- Template expressions in strings
- Multiple punctuation types
- Namespace and import statements
- Model definitions and interfaces
- Operation declarations
- Comprehensive TypeScript integration

**Best for**: Understanding how to implement complete, production-ready language grammars

## 🧪 Demo and Test Files

### `_demo-scope-features.ts`
**Purpose**: Comprehensive demonstration of the scope system features  
**Features Demonstrated**:
- Static vs callable scopes
- Custom scope definitions
- Extension modes (`on-leafs`)
- Performance comparisons
- Type safety examples

**Best for**: Understanding the scope system internals and different usage patterns

## 📖 Learning Path

### For Beginners
1. **Start with `simple-example.ts`** (15 min) - Learn the fundamentals
   - Type-safe scopes
   - Terminal patterns
   - Basic rule structure
   - Grammar creation
2. **Study the code comments** - Understand the "why" behind each pattern
3. **Run the example** - See the generated grammar JSON
4. **Experiment** - Modify keywords, add new patterns

### For Practical Implementation
1. **Study `comprehensive-example.ts`** (30 min) - See advanced patterns
   - Complex rules with captures
   - Function declarations
   - Pattern organization
   - Repository management
2. **Compare with real-world examples**:
   - `bicep.ts` - String interpolation, directives
   - `typespec.ts` - Complex language features
3. **Use as templates** - Copy patterns for your own language

### For Production Grammars
1. **Master the real-world examples**:
   - `bicep.ts` - See how a real DSL is structured
   - `typespec.ts` - Complex language with extensive features
2. **Study performance patterns** - Static scopes, terminal reuse
3. **Explore `_demo-scope-features.ts`** - Understand scope system internals

## 🚀 Quick Start

### Try the Simple Example

```bash
# Run the simple example to see basic features
bun run examples/simple-example.ts

# Expected output:
# Keywords: keyword.control.simple
# Strings: string.quoted.double.simple
# Numbers: constant.numeric.simple
# etc.
```

### Explore Advanced Features

```bash
# Run the comprehensive example
bun run examples/comprehensive-example.ts

# See real-world implementations
bun run examples/tmgrammar-toolkit/bicep.ts
bun run examples/tmgrammar-toolkit/typespec.ts
```

## 🔄 Migration from Other Libraries

The examples show how to use modern TextMate grammar patterns:

### Key Patterns in tmgrammar-toolkit

1. **Static Scopes** (Recommended):
   ```typescript
   // Modern tmgrammar-toolkit approach
   const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });
   scope: scopes.keyword.control.declaration  // "keyword.control.declaration.mylang"
   ```

2. **Grammar Creation**:
   ```typescript
   // Unified API
   export const grammar = createGrammar(
     'MyLanguage',
     'source.mylang', 
     ['.mylang'],
     [expression],
     { repositoryItems: allRules }
   );
   ```

3. **Type-Safe Rules**:
   ```typescript
   // Full TypeScript support
   const keywordRule: MatchRule = {
     key: 'keywords',
     match: regex.keywords(['if', 'else', 'while']),
     scope: scopes.keyword.control
   };
   ```

## 🚀 Running Examples

### Build and Test
```bash
# Build all examples
bun run build

# Run a specific example
bun run examples/simple-example.ts
bun run examples/comprehensive-example.ts

# Generate grammar from an example
bun run examples/tmgrammar-toolkit/bicep.ts
```

### Testing Your Changes
```bash
# Run tests on examples
bun test examples/

# Validate generated grammars
bun run validate examples/output/*.json
```

## ✨ Best Practices Demonstrated

### Performance Optimizations
- ✅ **Static scopes** for production grammars
- ✅ **Terminal pattern reuse** to avoid regex duplication
- ✅ **Proper pattern ordering** (specific to general)
- ✅ **Efficient rule grouping** to minimize backtracking

### Code Organization
- ✅ **Logical rule grouping** (comments, literals, expressions)
- ✅ **Clear naming conventions** for keys and scopes
- ✅ **Comprehensive exports** for testing and reuse
- ✅ **Proper TypeScript typing** throughout

### Grammar Structure
- ✅ **Repository management** via `repositoryItems`
- ✅ **Circular reference handling** with forward declarations
- ✅ **Custom scope definitions** for language-specific needs
- ✅ **Error handling** with source file paths for debugging

## 📚 Additional Resources

- **[Getting Started Guide](../docs/getting-started.md)** - Step-by-step tutorial
- **[API Reference](../docs/api-reference.md)** - Complete function documentation
- **[Using Scopes](../docs/using-scopes.md)** - Scope system deep dive
- **[Troubleshooting](../docs/troubleshooting.md)** - Common issues and solutions

## 🤝 Contributing Examples

Found a pattern that should be included? Want to add an example for your language?

1. **Follow the established structure** - Use the `simple-example.ts` as a template for basics
2. **Include comprehensive comments** - Explain the "why" not just the "what"
3. **Add proper exports** - Make testing and reuse easy
4. **Update this README** - Document your example's purpose and features

The goal is to make TextMate grammar creation accessible and maintainable for everyone! 🎉 
```

### examples/comprehensive-example.ts

```ts
/**
 * Comprehensive Language Grammar - TMGrammar Toolkit Example
 * 
 * This example demonstrates advanced patterns and best practices:
 * • Complex begin/end rules with captures
 * • Function declarations with parameters
 * • Template literals with interpolation
 * • Pattern grouping and organization
 * • Complete grammar with repository management
 * • Testing and generation utilities
 */

import {
  createGrammar,
  emitJSON,
  scopesFor,
  regex,
  type MatchRule,
  type BeginEndRule,
  type IncludeRule,
  type Grammar,
  type Rule,
} from '#src';
import { COMMENT, NUM, ID } from '#src/terminals';

// 1. Create static scopes for the language (recommended for production)
const scopes = scopesFor(
  { suffix: 'comprehensive', allowScopeExtension: false },
  { custom: { annotation: null } }
);

// 2. Define keywords for the language
const KEYWORDS = [
  'if', 'else', 'while', 'for', 'function', 'return', 
  'var', 'let', 'const', 'true', 'false', 'null', 'class', 'extends'
];

// 3. Basic token patterns using terminal helpers

// Comments using pre-built terminal patterns
const lineComment: MatchRule = {
  key: 'line-comment',
  scope: scopes.comment.line.double_slash,
  match: regex.concat(COMMENT.SLASHES, /.*$/)
};

const blockComment: BeginEndRule = {
  key: 'block-comment',
  scope: scopes.comment.block,
  begin: COMMENT.BLOCK.START,
  end: COMMENT.BLOCK.END
};

// Numbers using terminal patterns (multiple formats)
const numericLiteral: MatchRule = {
  key: 'numeric-literal',
  scope: scopes.constant.numeric,
  match: regex.oneOf([
    NUM.DEC,    // Decimal: 123, 123.45, 1.23e-4
    NUM.HEX,    // Hexadecimal: 0xFF, 0xABCD
    NUM.BIN,    // Binary: 0b1010
    NUM.OCT     // Octal: 0o777
  ])
};

// Boolean literals
const booleanLiteral: MatchRule = {
  key: 'boolean-literal',
  scope: scopes.constant.language,
  match: regex.keywords(['true', 'false', 'null'])
};

// String escape sequences
const escapeSequence: MatchRule = {
  key: 'escape-sequence',
  scope: scopes.constant.character.escape,
  match: /\\[\\'"nrt0]/
};

// Custom annotation pattern
const annotation = {
  key: 'annotation',
  scope: scopes.custom.annotation,
  match: /@[A-Za-z_][A-Za-z0-9_]*/
};

// 4. Complex patterns using begin/end rules

// Single-quoted strings
const singleQuotedString: BeginEndRule = {
  key: 'string-single',
  scope: scopes.string.quoted.single,
  begin: /'/,
  end: /'/,
  patterns: [escapeSequence]
};

// Double-quoted strings with more features
const doubleQuotedString: BeginEndRule = {
  key: 'string-double',
  scope: scopes.string.quoted.double,
  begin: /"/,
  end: /"/,
  patterns: [
    escapeSequence,
    {
      key: 'string-placeholder',
      scope: scopes.constant.other.placeholder,
      match: /%[sd%]/
    }
  ]
};

// Template literals (ES6-style) with interpolation
const templateLiteral: BeginEndRule = {
  key: 'template-literal',
  scope: scopes.string.quoted.other,
  begin: /`/,
  end: /`/,
  patterns: [
    escapeSequence,
    {
      key: 'template-expression',
      scope: scopes.meta.interpolation,
      begin: /\$\{/,
      end: /\}/,
      patterns: [
        // Include expressions here - simplified for this example
        { include: '#keywords' },
        { include: '#identifiers' }
      ]
    }
  ]
};

// Keywords with word boundaries
const keywords: MatchRule = {
  key: 'keywords',
  scope: scopes.keyword.control,
  match: regex.keywords(KEYWORDS)
};

// Function declarations with complex captures
const functionDeclaration: BeginEndRule = {
  key: 'function-declaration',
  scope: scopes.meta.function,
  begin: regex.concat(
    /\b(function)\s+/,  // function keyword
    regex.capture(ID),   // function name
    /\s*(\()/           // opening parenthesis
  ),
  beginCaptures: {
    '1': { scope: scopes.keyword.declaration.function },
    '2': { scope: scopes.entity.name.function },
    '3': { scope: scopes.punctuation.section.parens.begin }
  },
  end: /\)/,
  endCaptures: {
    '0': { scope: scopes.punctuation.section.parens.end }
  },
  patterns: [
    {
      key: 'parameter',
      scope: scopes.variable.parameter,
      match: ID
    },
    {
      key: 'parameter-separator',
      scope: scopes.punctuation.separator.comma,
      match: /,/
    }
  ]
};

// Class declarations
const classDeclaration: BeginEndRule = {
  key: 'class-declaration',
  scope: scopes.meta.class,
  begin: regex.concat(
    /\b(class)\s+/,      // class keyword
    regex.capture(ID),   // class name
    regex.optional(regex.concat(/\s+(extends)\s+/, regex.capture(ID))), // optional extends
    /\s*(\{)/           // opening brace
  ),
  beginCaptures: {
    '1': { scope: scopes.keyword.declaration.class },
    '2': { scope: scopes.entity.name.class },
    '3': { scope: scopes.keyword.control.inheritance },
    '4': { scope: scopes.entity.other.inherited_class },
    '5': { scope: scopes.punctuation.section.block.begin }
  },
  end: /\}/,
  endCaptures: {
    '0': { scope: scopes.punctuation.section.block.end }
  },
  patterns: [
    { include: '#function-declaration' },
    { include: '#identifiers' }
  ]
};

// Identifiers (variables, function names when used)
const identifiers: MatchRule = {
  key: 'identifiers',
  scope: scopes.variable.other.readwrite,
  match: ID
};

// Function calls
const functionCall: MatchRule = {
  key: 'function-call',
  scope: scopes.entity.name.function,
  match: regex.concat(ID, regex.before(/\s*\(/))
};

// 5. Group related patterns

// All comment patterns
const comments: IncludeRule = {
  key: 'comments',
  patterns: [lineComment, blockComment]
};

// All string patterns
const strings: IncludeRule = {
  key: 'strings',
  patterns: [
    templateLiteral,        // Check template literals first
    doubleQuotedString,
    singleQuotedString
  ]
};

// All literal values
const literals: IncludeRule = {
  key: 'literals',
  patterns: [
    strings,
    numericLiteral,
    booleanLiteral
  ]
};

// All expression patterns
const expressions: IncludeRule = {
  key: 'expressions',
  patterns: [
    literals,
    functionCall,    // Check function calls before identifiers
    identifiers
  ]
};

// 6. Collect all rules for the repository
const allRules: Rule[] = [
  // Comments
  lineComment,
  blockComment,
  comments,
  annotation,
  
  // Literals
  numericLiteral,
  booleanLiteral,
  escapeSequence,
  
  // Strings
  singleQuotedString,
  doubleQuotedString,
  templateLiteral,
  strings,
  
  // Keywords and identifiers
  keywords,
  identifiers,
  functionCall,
  functionDeclaration,
  classDeclaration,
  
  // Grouped patterns
  literals,
  expressions
];

// 7. Create the complete grammar
export const comprehensiveGrammar: Grammar = createGrammar(
  'Comprehensive Language',      // Display name
  'source.comprehensive',        // Scope name (source.* for programming languages)
  ['comp', 'comprehensive'],     // File extensions
  [                              // Top-level patterns (order matters!)
    comments,                    // Comments can appear anywhere
    annotation,
    classDeclaration,            // Class declarations
    functionDeclaration,         // Function declarations are statements
    keywords,                    // Keywords
    expressions                  // Other expressions
  ],
  {
    repositoryItems: allRules     // All rules for the repository
  }
);

// 8. Utility function to generate the grammar JSON
export async function generateGrammar(): Promise<string> {
  return await emitJSON(comprehensiveGrammar, {
    errorSourceFilePath: import.meta.url  // Better error messages
  });
}

// 9. Export individual patterns for testing and reuse
export {
  // Comment patterns
  lineComment,
  blockComment,
  comments,
  
  // Literal patterns
  numericLiteral,
  booleanLiteral,
  
  // String patterns
  singleQuotedString,
  doubleQuotedString,
  templateLiteral,
  strings,
  
  // Keywords and identifiers
  keywords,
  identifiers,
  functionCall,
  functionDeclaration,
  classDeclaration,
  
  // Grouped patterns
  literals,
  expressions,
  
  // Scopes for testing
  scopes
};

// Example usage and testing
if (import.meta.url === `file://${process.argv[1]}`) {
  console.log('🚀 Comprehensive Language Grammar Example\n');
  
  // Generate and display the grammar
  generateGrammar()
    .then(json => {
      console.log('✅ Generated grammar successfully!');
      console.log('\n📄 Grammar JSON (first 500 chars):');
      console.log(json.substring(0, 500) + '...');
      
      // Show some example scopes
      console.log('\n🎨 Example scopes:');
      console.log(`  Keywords: ${scopes.keyword.control}`);
      console.log(`  Strings: ${scopes.string.quoted.double}`);
      console.log(`  Numbers: ${scopes.constant.numeric}`);
      console.log(`  Comments: ${scopes.comment.line.double_slash}`);
      console.log(`  Functions: ${scopes.entity.name.function}`);
      console.log(`  Classes: ${scopes.entity.name.class}`);
    })
    .catch(error => {
      console.error('❌ Error generating grammar:', error);
      process.exit(1);
    });
}

export default comprehensiveGrammar; 
```

### examples/programmatic-use.ts

```ts
import path from 'node:path';
import fs from 'node:fs/promises';
import { fileURLToPath } from 'node:url';

import type { Grammar } from 'tmgrammar-toolkit';
import { schema, emitJSON } from 'tmgrammar-toolkit';


const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

// 1. Import your grammar rules and patterns
import { allRules, mainPatterns } from '../src/my-grammar';
const LANG_ID = 'my-lang';


export const MyGrammar: Grammar = {
    $schema: schema,
    name: LANG_ID,
    scopeName: `source.${LANG_ID}`,
    fileTypes: [LANG_ID],
    patterns: mainPatterns,
    repositoryItems: allRules,
}; 

async function main() {
  const outputPath = path.join(__dirname, `../src/${LANG_ID}.tmLanguage.json`);
  const grammarAsJson = await emitJSON(MyGrammar, {
    errorSourceFilePath: outputPath
  });
  await fs.writeFile(outputPath, grammarAsJson);
  console.log(`[${new Date().toLocaleTimeString()}] ✅ ${LANG_ID} tmLanguage generated at ${outputPath}`);
}

main().catch(err => {
  console.error(err);
  process.exit(1);
}); 
```

### examples/result-usage.ts

```ts
/**
 * Example usage of the Result pattern in the grammar toolkit
 */

import { 
  Result, 
  ok, 
  error, 
  isOk, 
  isError, 
  pipe,
  type ValidationResult, 
  type StringResult 
} from '../src/result.js';
import { GrammarValidationError } from '../src/types.js';

// Example 1: Basic usage with type guards
function parseNumber(input: string): StringResult<number> {
  const num = parseInt(input, 10);
  if (isNaN(num)) {
    return error(`Invalid number: ${input}`);
  }
  return ok(num);
}

// Example 2: Validation function that returns ValidationResult
function validateGrammarName(name: string): ValidationResult<string> {
  if (!name || name.trim().length === 0) {
    return error(new GrammarValidationError('Grammar name cannot be empty'));
  }
  
  if (!/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(name)) {
    return error(new GrammarValidationError('Grammar name must start with a letter and contain only letters, numbers, hyphens, and underscores'));
  }
  
  return ok(name.trim());
}

// Example 3: Chain operations with map and flatMap
function processUserInput(input: string): StringResult<string> {
  return Result.map(parseNumber(input), num => num * 2)
    .flatMap(doubled => {
      if (doubled > 100) {
        return error('Result too large');
      }
      return ok(`Processed: ${doubled}`);
    });
}

// Example 4: Using the pipe function for functional composition
function processInputWithPipe(input: string): string {
  return pipe(parseNumber(input))
    .map(num => num * 2)
    .flatMap(doubled => doubled > 100 ? error('Too large') : ok(doubled))
    .map(doubled => `Result: ${doubled}`)
    .unwrapOr('Invalid input');
}

// Example 5: Combining multiple Results
function combineResults(inputs: string[]): StringResult<number[]> {
  const results = inputs.map(parseNumber);
  return Result.all(results);
}

// Example 6: Error handling with match
function handleResult(input: string): string {
  const result = parseNumber(input);
  
  return Result.match(result, {
    ok: (num) => `Successfully parsed: ${num}`,
    error: (err) => `Failed to parse: ${err}`
  });
}

// Example 7: Using tap for side effects (like logging)
function parseWithLogging(input: string): StringResult<number> {
  return pipe(parseNumber(input))
    .tap(num => console.log(`Parsed number: ${num}`))
    .tapError(err => console.error(`Parse error: ${err}`))
    .value;
}

// Example 8: Converting from Promise
async function parseFromAPI(url: string): Promise<StringResult<any>> {
  try {
    const response = await fetch(url);
    if (!response.ok) {
      return error(`HTTP ${response.status}: ${response.statusText}`);
    }
    const data = await response.json();
    return ok(data);
  } catch (err) {
    return error(`Network error: ${err}`);
  }
}

// Example 9: Using unwrapOr for default values
function getConfigValue(key: string, config: Record<string, any>): string {
  const result = key in config ? ok(config[key]) : error('Key not found');
  return Result.unwrapOr(result, 'default-value');
}

// Example 10: Complex validation chain
function validateAndProcessGrammar(name: string, content: string): ValidationResult<{name: string, processedContent: string}> {
  return pipe(validateGrammarName(name))
    .flatMap(validName => {
      if (content.length === 0) {
        return error(new GrammarValidationError('Grammar content cannot be empty'));
      }
      return ok({ name: validName, content });
    })
    .map(({ name, content }) => ({
      name,
      processedContent: content.trim()
    }))
    .value;
}

// Example usage demonstrations
console.log('=== Basic parsing ===');
console.log(handleResult('42'));      // "Successfully parsed: 42"
console.log(handleResult('invalid')); // "Failed to parse: Invalid number: invalid"

console.log('\n=== Functional composition ===');
console.log(processInputWithPipe('21'));    // "Result: 42"
console.log(processInputWithPipe('60'));    // "Invalid input" (120 > 100)
console.log(processInputWithPipe('abc'));   // "Invalid input"

console.log('\n=== Combining results ===');
const combineSuccess = combineResults(['1', '2', '3']);
if (isOk(combineSuccess)) {
  console.log('Combined successfully:', combineSuccess.value); // [1, 2, 3]
} else {
  console.log('Combine failed:', combineSuccess.error);
}

const combineFailure = combineResults(['1', 'invalid', '3']);
if (isError(combineFailure)) {
  console.log('Combine failed:', combineFailure.error); // "Invalid number: invalid"
}

console.log('\n=== Grammar validation ===');
const validGrammar = validateAndProcessGrammar('MyGrammar', '  some content  ');
if (isOk(validGrammar)) {
  console.log('Valid grammar:', validGrammar.value);
} else {
  console.log('Invalid grammar:', validGrammar.error.message);
}

const invalidGrammar = validateAndProcessGrammar('123Invalid', 'content');
if (isError(invalidGrammar)) {
  console.log('Invalid grammar:', invalidGrammar.error.message);
}

console.log('\n=== Default values ===');
const config = { theme: 'dark', maxItems: 10 };
console.log('Theme:', getConfigValue('theme', config));      // "dark"
console.log('Missing:', getConfigValue('missing', config));  // "default-value"
```

### examples/simple-example.ts

```ts
/**
 * Simple Language Grammar - TMGrammar Toolkit Example
 * 
 * This example demonstrates the core features of tmgrammar-toolkit:
 * • Type-safe scopes with scopesFor
 * • Pre-built terminal patterns
 * • Regex helpers for readable patterns
 * • Clean grammar creation
 */

import { createGrammar, scopesFor, regex, type Grammar } from '#src';
import { COMMENT, NUM, ID } from '#src/terminals';

// 1. Create type-safe scopes for your language
const scopes = scopesFor(
  { suffix: 'simple', allowScopeExtension: false },
  { custom: { emphasis: null } }
);

// 2. Define patterns using helpers and terminals

// Keywords using regex helper
const keywords = {
  key: 'keywords',
  scope: scopes.keyword.control,
  match: regex.keywords(['if', 'else', 'while', 'for', 'function', 'return'])
};

// Line comments using terminal pattern
const lineComment = {
  key: 'line-comment',
  scope: scopes.comment.line.double_slash,
  match: regex.concat(COMMENT.SLASHES, /.*$/)
};

// Numbers using terminal pattern
const numbers = {
  key: 'numbers',
  scope: scopes.constant.numeric,
  match: NUM.DEC  // Handles: 123, 123.45, 1.23e-4
};

// Strings with escape sequences
const strings = {
  key: 'strings',
  scope: scopes.string.quoted.double,
  begin: /"/,
  end: /"/,
  patterns: [
    {
      key: 'string-escape',
      scope: scopes.constant.character.escape,
      match: /\\./
    }
  ]
};

// Identifiers using terminal pattern
const identifiers = {
  key: 'identifiers',
  scope: scopes.variable.other.readwrite,
  match: ID  // Standard [a-zA-Z_][a-zA-Z0-9_]* pattern
};

// Custom emphasis pattern
const emphasis = {
  key: 'emphasis',
  scope: scopes.custom.emphasis,
  match: /!+/ 
};

// 3. Create the complete grammar
export const simpleGrammar: Grammar = createGrammar(
  'Simple Language',
  'source.simple',
  ['simple'],
  [
    lineComment,
    keywords,
    strings,
    numbers,
    emphasis,
    identifiers
  ]
);

export default simpleGrammar; 
```

### examples/tmgrammar-toolkit/bicep.ts

```ts
/**
 * Bicep TextMate Grammar using tmgrammar-toolkit
 * Converted from bicep.tmlanguage.json
 */

import {
  createGrammar,
  regex,
  scopesFor,
  meta,
  type Grammar,
  type MatchRule,
  type BeginEndRule,
  type IncludeRule,
  type Rule,
  concat as r,
  notBefore,
  before,
  bounded,
} from '#src';
import { COMMENT } from '#src/terminals';

const scopes = scopesFor(
  {
    // will be appended to all scopes
    suffix: 'bicep',
    // prevent creating new scopes from the base scopes
    // by calling the scope object as a function
    allowScopeExtension: false
  }, {
  string: {
    quoted: {
      // The value here does not matter, it will be ignored
      multi: true,
    }
  },
  keyword: {
    control: {
      // The value here does not matter, it will be ignored
      declaration: true,
    }
  },
  variable: {
    other: {
      property: true,
    }
  }
});

// Expression rule (include all expression patterns)
const expression: IncludeRule = {
  key: 'expression',
  patterns: [
    // Patterns will be added at the end of the file
  ]
};

// Line comment rule
const lineComment: MatchRule = {
  key: 'line-comment',
  scope: scopes.comment.line.double_slash,
  match: `${COMMENT.SLASHES}.*(?=$)`
};

// Block comment rule
const blockComment: BeginEndRule = {
  key: 'block-comment',
  scope: scopes.comment.block,
  begin: /\/\*/,
  end: /\*\//
};

// Comments include rule - demonstrates direct rule references in patterns
// Instead of { include: '#line-comment' }, we can now use the rule directly
const comments: IncludeRule = {
  key: 'comments',
  patterns: [
    lineComment,
    blockComment
  ]
};

// Numeric literal rule
const numericLiteral: MatchRule = {
  key: 'numeric-literal',
  scope: scopes.constant.numeric,
  match: /[0-9]+/
};


// Named literal rule (true, false, null)
const namedLiteral: MatchRule = {
  key: 'named-literal',
  scope: scopes.constant.language,
  match: regex.keywords('true', 'false', 'null')
};

// Escape character rule for strings
const escapeCharacter: MatchRule = {
  key: 'escape-character',
  scope: scopes.constant.character.escape,
  match: /\\(u\{[0-9A-Fa-f]+\}|n|r|t|\\|'|\$\{)/
};

// String interpolation rule
const stringLiteralSubst: BeginEndRule = {
  key: 'string-literal-subst',
  scope: meta,
  begin: /(?<!\\)(\$\{)/,
  beginCaptures: {
    '1': { scope: scopes.punctuation.definition['template-expression'].begin }
  },
  end: /(\})/,
  endCaptures: {
    '1': { scope: scopes.punctuation.definition['template-expression'].end }
  },
  patterns: [
    expression,
    comments
  ]
};

// String literal rule
const stringLiteral: BeginEndRule = {
  key: 'string-literal',
  scope: scopes.string.quoted.single,
  begin: r(/'/, notBefore(/''/)),
  end: /'/,
  patterns: [
    escapeCharacter,
    stringLiteralSubst
  ]
};


// String verbatim rule
const stringVerbatim: BeginEndRule = {
  key: 'string-verbatim',
  scope: scopes.string.quoted.multi,
  begin: /'''/,
  end: r(/'''/, notBefore(/'/)),
  patterns: []
};

// Keyword rule
const keyword: MatchRule = {
  key: 'keyword',
  scope: scopes.keyword.control.declaration,
  match: regex.keywords([
    'metadata', 'targetScope', 'resource', 'module', 'param', 'var', 'output', 
    'for', 'in', 'if', 'existing', 'import', 'as', 'type', 'with', 'using', 
    'extends', 'func', 'assert', 'extension'
  ])
};

// Identifier rule
const identifier: MatchRule = {
  key: 'identifier',
  scope: scopes.variable.other.readwrite,
  match: regex.concat(
    /\b[_$[:alpha:]][_$[:alnum:]]*\b/,
    regex.notBefore(/(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*\(/)
  )
};

// Directive variable rule
const directiveVariable: MatchRule = {
  key: 'directive-variable',
  scope: scopes.keyword.control.declaration,
  match: /\b[_a-zA-Z-0-9]+\b/
};

// Directive rule
const directive: BeginEndRule = {
  key: 'directive',
  scope: meta,
  begin: r(/#/, bounded(/[_a-zA-Z-0-9]+/)),
  end: /$/,
  patterns: [
    directiveVariable,
    comments
  ]
};

// Object property key rule
const objectPropertyKey: MatchRule = {
  key: 'object-property-key',
  scope: scopes.variable.other.property,
  match: r(
    /\b[_$[:alpha:]][_$[:alnum:]]*\b/,
    before(/(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*:/)
  )
};

// Object literal rule
const objectLiteral: BeginEndRule = {
  key: 'object-literal',
  scope: meta,
  begin: /\{/,
  end: /\}/,
  patterns: [
    objectPropertyKey,
    expression,
    comments
  ]
};

// Array literal rule
const arrayLiteral: BeginEndRule = {
  key: 'array-literal',
  scope: meta,
  begin: /\[(?!(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*\bfor\b)/,
  end: /]/,
  patterns: [
    expression,
    comments
  ]
};

// Function call rule
const functionCall: BeginEndRule = {
  key: 'function-call',
  scope: meta,
  begin: /(\b[_$[:alpha:]][_$[:alnum:]]*\b)(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*\(/,
  beginCaptures: {
    '1': { scope: scopes.entity.name.function }
  },
  end: /\)/,
  patterns: [
    expression,
    comments
  ]
};

// Lambda start rule
const lambdaStart: BeginEndRule = {
  key: 'lambda-start',
  scope: meta,
  begin: /(\((?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*\b[_$[:alpha:]][_$[:alnum:]]*\b(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*(,(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*\b[_$[:alpha:]][_$[:alnum:]]*\b(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*)*\)|\((?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*\)|(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*\b[_$[:alpha:]][_$[:alnum:]]*\b(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*)(?=(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*=>)/,
  beginCaptures: {
    '1': {
      scope: meta,
      patterns: [
        identifier,
        comments
      ]
    }
  },
  end: /(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*=>/
};

// Decorator rule
const decorator: BeginEndRule = {
  key: 'decorator',
  scope: meta,
  begin: /@(?:[ \t\r\n]|\/\*(?:\*(?!\/)|[^*])*\*\/)*(?=\b[_$[:alpha:]][_$[:alnum:]]*\b)/,
  end: '',
  patterns: [
    expression,
    comments
  ]
};

const allBicepRules: Rule[] = [
  lineComment,
  blockComment,
  comments,
  numericLiteral,
  namedLiteral,
  escapeCharacter,
  stringLiteralSubst,
  stringLiteral,
  stringVerbatim,
  keyword,
  identifier,
  directiveVariable,
  directive,
  objectPropertyKey,
  objectLiteral,
  arrayLiteral,
  functionCall,
  lambdaStart,
  decorator,
  expression
];

// Create the complete Bicep grammar
export const grammar: Grammar = createGrammar(
  'Bicep',
  'source.bicep',
  ['.bicep', '.bicepparam'],
  [
    expression, // Main patterns are still the top-level rules
    comments
  ],
  {
    repositoryItems: allBicepRules // Provide all defined rules for the repository
  }
);

expression.patterns.concat([
  arrayLiteral,
  decorator,
  directive,
  functionCall,
  identifier,
  keyword,
  lambdaStart,
  namedLiteral,
  numericLiteral,
  objectLiteral,
  stringLiteral,
  stringVerbatim,
]);

// Export all rules for testing and reuse if needed by other modules
export {
  arrayLiteral,
  blockComment,
  comments,
  decorator,
  directive,
  directiveVariable,
  escapeCharacter,
  expression,
  functionCall,
  identifier,
  keyword,
  lambdaStart,
  lineComment,
  namedLiteral,
  numericLiteral,
  objectLiteral,
  objectPropertyKey,
  stringLiteral,
  stringLiteralSubst,
  stringVerbatim,
};
```

### examples/tmgrammar-toolkit/typespec.ts

```ts
/**
 * TypeSpec TextMate Grammar using tmgrammar-toolkit
 * Converted from the original tmlanguage-generator version
 */

import {
  createGrammar,
  regex,
  scopesFor,
  meta,
  type Grammar,
  type MatchRule,
  type BeginEndRule,
  type IncludeRule,
  type Rule,
} from '#src';
import { COMMENT, NUM } from '#src/terminals';

// Create static scopes for TypeSpec (recommended pattern)
const scopes = scopesFor(
  { 
    suffix: 'tsp', 
    allowScopeExtension: false 
  },
  {
    // Custom TypeSpec-specific scopes
    keyword: {
      directive: {
        name: null
      },
      tag: {
        tspdoc: null
      },
      operator: {
        'type.annotation': null,
        optional: null,
        selector: null,
        spread: null
      }
    },
    punctuation: {
      definition: {
        typeparameters: {
          begin: null,
          end: null
        },
        'template-expression': {
          begin: null,
          end: null
        }
      },
      squarebracket: {
        open: null,
        close: null
      },
      curlybrace: {
        open: null,
        close: null
      },
      parenthesis: {
        open: null,
        close: null
      },
      hashcurlybrace: {
        open: null
      },
      hashsquarebracket: {
        open: null
      },
      comma: null
    },
    variable: {
      name: null
    }
  }
);

// Pattern constants for TypeSpec
const identifierStart = "[_$[:alpha:]]";
const identifierContinue = "[_$[:alnum:]]";
const beforeIdentifier = `(?=(${identifierStart}|\`))`;
const escapedIdentifier = "`(?:[^`\\\\]|\\\\.)*`";
const simpleIdentifier = `\\b${identifierStart}${identifierContinue}*\\b`;
const identifier = `${simpleIdentifier}|${escapedIdentifier}`;
const qualifiedIdentifier = `\\b${identifierStart}(?:${identifierContinue}|\\.${identifierStart})*\\b`;
const stringPattern = '\\"(?:[^\\"\\\\]|\\\\.)*\\"';
const modifierKeyword = `\\b(?:extern)\\b`;
const statementKeyword = `\\b(?:namespace|model|op|using|import|enum|alias|union|interface|dec|fn)\\b`;
const universalEnd = `(?=,|;|@|\\)|\\}|${modifierKeyword}|${statementKeyword})`;
const universalEndExceptComma = `(?=;|@|\\)|\\}|${modifierKeyword}|${statementKeyword})`;
const expressionEnd = `(?=,|;|@|\\)|\\}|=|${statementKeyword})`;

// Complex number pattern for TypeSpec
const hexNumber = "\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$)";
const binaryNumber = "\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$)";
const decimalNumber =
  "(?<!\\$)(?:" +
  "(?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|" + // 1.1E+3
  "(?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|" + // 1.E+3
  "(?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|" + // .1E+3
  "(?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|" + // 1E+3
  "(?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|" + // 1.1
  "(?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|" + // 1.
  "(?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|" + // .1
  "(?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))" + // 1
  ")(?!\\$)";
const anyNumber = `(?:${hexNumber}|${binaryNumber}|${decimalNumber})`;

// Forward declarations for circular references
const expression: IncludeRule = {
  key: "expression",
  patterns: [] // Will be populated later
};

const statement: IncludeRule = {
  key: "statement", 
  patterns: [] // Will be populated later
};

// Comments
const lineComment: MatchRule = {
  key: "line-comment",
  scope: scopes.comment.line.double_slash,
  match: "//.*$"
};

const blockComment: BeginEndRule = {
  key: "block-comment",
  scope: scopes.comment.block,
  begin: /\/\*/,
  end: /\*\//
};

const docCommentParam: MatchRule = {
  key: "doc-comment-param-tag",
  scope: scopes.comment.block,
  match: new RegExp(`((@)(?:param|template|prop))\\s+(${identifier})\\b`),
  captures: {
    "1": { scope: scopes.keyword.tag.tspdoc },
    "2": { scope: scopes.keyword.tag.tspdoc },
    "3": { scope: scopes.variable.name }
  }
};

const docCommentReturn: MatchRule = {
  key: "doc-comment-return-tag",
  scope: scopes.comment.block,
  match: /((@)(?:returns))\b/,
  captures: {
    "1": { scope: scopes.keyword.tag.tspdoc },
    "2": { scope: scopes.keyword.tag.tspdoc }
  }
};

const docCommentUnknownTag: MatchRule = {
  key: "doc-comment-unknown-tag",
  scope: scopes.comment.block,
  match: new RegExp(`((@)(?:${identifier}))\\b`),
  captures: {
    "1": { scope: scopes.entity.name.tag },
    "2": { scope: scopes.entity.name.tag }
  }
};

const docCommentBlock: IncludeRule = {
  key: "doc-comment-block",
  patterns: [docCommentParam, docCommentReturn, docCommentUnknownTag]
};

const docComment: BeginEndRule = {
  key: "doc-comment",
  scope: scopes.comment.block,
  begin: /\/\*\*/,
  beginCaptures: {
    "0": { scope: scopes.comment.block }
  },
  end: /\*\//,
  endCaptures: {
    "0": { scope: scopes.comment.block }
  },
  patterns: [docCommentBlock]
};

// Literals
const booleanLiteral: MatchRule = {
  key: "boolean-literal",
  scope: scopes.constant.language,
  match: /\b(true|false)\b/
};

const escapeCharacter: MatchRule = {
  key: "escape-character",
  scope: scopes.constant.character.escape,
  match: /\\./
};

const numericLiteral: MatchRule = {
  key: "numeric-literal",
  scope: scopes.constant.numeric,
  match: new RegExp(anyNumber)
};

// Template expressions
const templateExpression: BeginEndRule = {
  key: "template-expression",
  scope: meta,
  begin: /\$\{/,
  beginCaptures: {
    "0": { scope: scopes.punctuation.definition['template-expression'].begin }
  },
  end: /\}/,
  endCaptures: {
    "0": { scope: scopes.punctuation.definition['template-expression'].end }
  },
  patterns: [expression]
};

// Strings
const stringLiteral: BeginEndRule = {
  key: "string-literal",
  scope: scopes.string.quoted.double,
  begin: /"/,
  end: /"|$/,
  patterns: [templateExpression, escapeCharacter]
};

const tripleQuotedStringLiteral: BeginEndRule = {
  key: "triple-quoted-string-literal",
  scope: scopes.string.quoted.triple,
  begin: /"""/,
  end: /"""/,
  patterns: [templateExpression, escapeCharacter]
};

// Punctuation
const punctuationComma: MatchRule = {
  key: "punctuation-comma",
  scope: scopes.punctuation.comma,
  match: /,/
};

const punctuationAccessor: MatchRule = {
  key: "punctuation-accessor",
  scope: scopes.punctuation.accessor,
  match: /\./
};

const punctuationSemicolon: MatchRule = {
  key: "punctuation-semicolon",
  scope: scopes.punctuation.terminator.statement,
  match: /;/
};

// Operators
const operatorAssignment: MatchRule = {
  key: "operator-assignment",
  scope: scopes.keyword.operator.assignment,
  match: /=/
};

// Identifiers
const identifierExpression: MatchRule = {
  key: "identifier-expression",
  scope: scopes.entity.name.type,
  match: new RegExp(identifier)
};

// Tokens (basic literals and comments)
const token: IncludeRule = {
  key: "token",
  patterns: [
    docComment,
    lineComment,
    blockComment,
    tripleQuotedStringLiteral,
    stringLiteral,
    booleanLiteral,
    numericLiteral
  ]
};

// Expressions
const parenthesizedExpression: BeginEndRule = {
  key: "parenthesized-expression",
  scope: meta,
  begin: /\(/,
  beginCaptures: {
    "0": { scope: scopes.punctuation.parenthesis.open }
  },
  end: /\)/,
  endCaptures: {
    "0": { scope: scopes.punctuation.parenthesis.close }
  },
  patterns: [expression, punctuationComma]
};

const callExpression: BeginEndRule = {
  key: "call-expression",
  scope: meta,
  begin: new RegExp(`(${qualifiedIdentifier})\\s*(\\()`),
  beginCaptures: {
    "1": { scope: scopes.entity.name.function },
    "2": { scope: scopes.punctuation.parenthesis.open }
  },
  end: /\)/,
  endCaptures: {
    "0": { scope: scopes.punctuation.parenthesis.close }
  },
  patterns: [token, expression, punctuationComma]
};

// Directives
const directive: BeginEndRule = {
  key: "directive",
  scope: meta,
  begin: new RegExp(`\\s*(#${simpleIdentifier})`),
  beginCaptures: {
    "1": { scope: scopes.keyword.directive.name }
  },
  end: new RegExp(`$|${universalEnd}`),
  patterns: [stringLiteral, identifierExpression]
};

// Decorators
const decorator: BeginEndRule = {
  key: "decorator",
  scope: meta,
  begin: new RegExp(`((@)${qualifiedIdentifier})`),
  beginCaptures: {
    "1": { scope: scopes.entity.name.tag },
    "2": { scope: scopes.entity.name.tag }
  },
  end: new RegExp(`${beforeIdentifier}|${universalEnd}`),
  patterns: [token, parenthesizedExpression]
};

const augmentDecoratorStatement: BeginEndRule = {
  key: "augment-decorator-statement",
  scope: meta,
  begin: new RegExp(`((@@)${qualifiedIdentifier})`),
  beginCaptures: {
    "1": { scope: scopes.entity.name.tag },
    "2": { scope: scopes.entity.name.tag }
  },
  end: new RegExp(`${beforeIdentifier}|${universalEnd}`),
  patterns: [token, parenthesizedExpression]
};

// Type arguments and parameters
const typeArguments: BeginEndRule = {
  key: "type-arguments",
  scope: meta,
  begin: /</,
  beginCaptures: {
    "0": { scope: scopes.punctuation.definition.typeparameters.begin }
  },
  end: />/,
  endCaptures: {
    "0": { scope: scopes.punctuation.definition.typeparameters.end }
  },
  patterns: [expression, punctuationComma]
};

const typeParameters: BeginEndRule = {
  key: "type-parameters",
  scope: meta,
  begin: /</,
  beginCaptures: {
    "0": { scope: scopes.punctuation.definition.typeparameters.begin }
  },
  end: />/,
  endCaptures: {
    "0": { scope: scopes.punctuation.definition.typeparameters.end }
  },
  patterns: [punctuationComma] // Simplified for this example
};

// Model expressions
const modelExpression: BeginEndRule = {
  key: "model-expression",
  scope: meta,
  begin: /\{/,
  beginCaptures: {
    "0": { scope: scopes.punctuation.curlybrace.open }
  },
  end: /\}/,
  endCaptures: {
    "0": { scope: scopes.punctuation.curlybrace.close }
  },
  patterns: [token, directive, decorator, punctuationSemicolon]
};

// Object literals
const objectLiteral: BeginEndRule = {
  key: "object-literal",
  scope: meta,
  begin: /#\{/,
  beginCaptures: {
    "0": { scope: scopes.punctuation.hashcurlybrace.open }
  },
  end: /\}/,
  endCaptures: {
    "0": { scope: scopes.punctuation.curlybrace.close }
  },
  patterns: [token, directive, punctuationComma]
};

// Tuple expressions
const tupleLiteral: BeginEndRule = {
  key: "tuple-literal",
  scope: meta,
  begin: /#\[/,
  beginCaptures: {
    "0": { scope: scopes.punctuation.hashsquarebracket.open }
  },
  end: /\]/,
  endCaptures: {
    "0": { scope: scopes.punctuation.squarebracket.close }
  },
  patterns: [expression, punctuationComma]
};

const tupleExpression: BeginEndRule = {
  key: "tuple-expression",
  scope: meta,
  begin: /\[/,
  beginCaptures: {
    "0": { scope: scopes.punctuation.squarebracket.open }
  },
  end: /\]/,
  endCaptures: {
    "0": { scope: scopes.punctuation.squarebracket.close }
  },
  patterns: [expression]
};

// Statements (simplified for this example)
const namespaceStatement: BeginEndRule = {
  key: "namespace-statement",
  scope: meta,
  begin: /\b(namespace)\b/,
  beginCaptures: {
    "1": { scope: scopes.keyword.other }
  },
  end: new RegExp(`((?<=\\})|${universalEnd})`),
  patterns: [token, identifierExpression, modelExpression]
};

const modelStatement: BeginEndRule = {
  key: "model-statement",
  scope: meta,
  begin: /\b(model)\b/,
  beginCaptures: {
    "1": { scope: scopes.keyword.other }
  },
  end: new RegExp(`(?<=\\})|${universalEnd}`),
  patterns: [token, typeParameters, modelExpression, expression]
};

const operationStatement: BeginEndRule = {
  key: "operation-statement",
  scope: meta,
  begin: new RegExp(`\\b(op)\\b\\s+(${identifier})`),
  beginCaptures: {
    "1": { scope: scopes.keyword.other },
    "2": { scope: scopes.entity.name.function }
  },
  end: new RegExp(universalEnd),
  patterns: [token, typeParameters, parenthesizedExpression]
};

const importStatement: BeginEndRule = {
  key: "import-statement",
  scope: meta,
  begin: /\b(import)\b/,
  beginCaptures: {
    "1": { scope: scopes.keyword.other }
  },
  end: new RegExp(universalEnd),
  patterns: [token]
};

const usingStatement: BeginEndRule = {
  key: "using-statement",
  scope: meta,
  begin: /\b(using)\b/,
  beginCaptures: {
    "1": { scope: scopes.keyword.other }
  },
  end: new RegExp(universalEnd),
  patterns: [token, identifierExpression, punctuationAccessor]
};

// Collect all rules
const allTypeSpecRules: Rule[] = [
  // Comments
  lineComment,
  blockComment,
  docCommentParam,
  docCommentReturn,
  docCommentUnknownTag,
  docCommentBlock,
  docComment,
  // Literals
  booleanLiteral,
  escapeCharacter,
  numericLiteral,
  // Template expressions
  templateExpression,
  // Strings
  stringLiteral,
  tripleQuotedStringLiteral,
  // Punctuation
  punctuationComma,
  punctuationAccessor,
  punctuationSemicolon,
  // Operators
  operatorAssignment,
  // Identifiers
  identifierExpression,
  // Tokens
  token,
  // Expressions
  parenthesizedExpression,
  callExpression,
  // Directives
  directive,
  // Decorators
  decorator,
  augmentDecoratorStatement,
  // Type arguments and parameters
  typeArguments,
  typeParameters,
  // Model expressions
  modelExpression,
  // Object literals
  objectLiteral,
  // Tuple expressions
  tupleLiteral,
  tupleExpression,
  // Statements
  namespaceStatement,
  modelStatement,
  operationStatement,
  importStatement,
  usingStatement,
  // Include rules
  expression,
  statement
];

// Populate expression patterns
expression.patterns.push(
  token,
  directive,
  parenthesizedExpression,
  typeArguments,
  objectLiteral,
  tupleLiteral,
  tupleExpression,
  modelExpression,
  callExpression,
  identifierExpression
);

// Populate statement patterns  
statement.patterns.push(
  token,
  directive,
  augmentDecoratorStatement,
  decorator,
  modelStatement,
  namespaceStatement,
  operationStatement,
  importStatement,
  usingStatement,
  punctuationSemicolon
);

// Create the complete TypeSpec grammar
export const grammar: Grammar = createGrammar(
  'TypeSpec',
  'source.tsp',
  ['tsp'],
  [statement],
  {
    repositoryItems: allTypeSpecRules
  }
);

// Export rules for testing and reuse
export {
  // Comments
  lineComment,
  blockComment,
  docComment,
  // Literals
  booleanLiteral,
  numericLiteral,
  // Strings
  stringLiteral,
  tripleQuotedStringLiteral,
  // Expressions
  expression,
  statement,
  // Complex constructs
  modelExpression,
  callExpression,
  typeArguments,
  typeParameters
};

export default grammar;
```

### examples/tmlanguage-generator/bicep.ts

```ts
// Copyright (c) Microsoft Corporation.
// Licensed under the MIT License.

import * as tm from "./tmlanguage-generator.js";

type Rule = tm.Rule<BicepScope>;
type IncludeRule = tm.IncludeRule<BicepScope>;
type BeginEndRule = tm.BeginEndRule<BicepScope>;
type MatchRule = tm.MatchRule<BicepScope>;
type Grammar = tm.Grammar<BicepScope>;

export type BicepScope =
  | "comment.block.bicep"
  | "comment.line.double-slash.bicep"
  | "constant.character.escape.bicep"
  | "constant.numeric.bicep"
  | "constant.language.bicep"
  | "entity.name.function.bicep"
  | "keyword.control.declaration.bicep"
  | "string.quoted.single.bicep"
  | "string.quoted.multi.bicep"
  | "variable.other.readwrite.bicep"
  | "variable.other.property.bicep"
  | "punctuation.definition.template-expression.begin.bicep"
  | "punctuation.definition.template-expression.end.bicep";

const bounded = (text: string) => `\\b${text}\\b`;
// eslint-disable-next-line @typescript-eslint/no-unused-vars
const after = (regex: string) => `(?<=${regex})`;
const notAfter = (regex: string) => `(?<!${regex})`;
const before = (regex: string) => `(?=${regex})`;
const notBefore = (regex: string) => `(?!${regex})`;

const meta: typeof tm.meta = tm.meta;
const identifierStart = "[_$[:alpha:]]";
const identifierContinue = "[_$[:alnum:]]";
const identifier = bounded(`${identifierStart}${identifierContinue}*`);
const directive = bounded(`[_a-zA-Z-0-9]+`);

// whitespace. ideally we'd tokenize in-line block comments, but that's a lot of work. For now, ignore them.
const ws = `(?:[ \\t\\r\\n]|\\/\\*(?:\\*(?!\\/)|[^*])*\\*\\/)*`;

const keywords = [
  "metadata",
  "targetScope",
  "resource",
  "module",
  "param",
  "var",
  "output",
  "for",
  "in",
  "if",
  "existing",
  "import",
  "as",
  "type",
  "with",
  "using",
  "extends",
  "func",
  "assert",
  "extension",
];

const keywordExpression: MatchRule = {
  key: "keyword",
  scope: "keyword.control.declaration.bicep",
  match: bounded(`(${keywords.join("|")})`),
};

const lineComment: MatchRule = {
  key: "line-comment",
  scope: "comment.line.double-slash.bicep",
  match: `//.*${before(`$`)}`,
};

const blockComment: BeginEndRule = {
  key: "block-comment",
  scope: "comment.block.bicep",
  begin: `/\\*`,
  end: `\\*/`,
};

const comments: IncludeRule = {
  key: "comments",
  patterns: [lineComment, blockComment],
};

function withComments(input: Rule[]): Rule[] {
  return [...input, comments];
}

const expression: IncludeRule = {
  key: "expression",
  patterns: [
    /* placeholder filled later due to cycle*/
  ],
};

const escapeChar: MatchRule = {
  key: "escape-character",
  scope: "constant.character.escape.bicep",
  match: `\\\\(u{[0-9A-Fa-f]+}|n|r|t|\\\\|'|\\\${)`,
};

const stringVerbatim: BeginEndRule = {
  key: "string-verbatim",
  scope: "string.quoted.multi.bicep",
  begin: `'''`,
  end: `'''${notBefore(`'`)}`,
  patterns: [],
};

const stringSubstitution: BeginEndRule = {
  key: "string-literal-subst",
  scope: meta,
  begin: `${notAfter(`\\\\`)}(\\\${)`,
  beginCaptures: {
    "1": { scope: "punctuation.definition.template-expression.begin.bicep" },
  },
  end: `(})`,
  endCaptures: {
    "1": { scope: "punctuation.definition.template-expression.end.bicep" },
  },
  patterns: withComments([expression]),
};

const stringLiteral: BeginEndRule = {
  key: "string-literal",
  scope: "string.quoted.single.bicep",
  begin: `'${notBefore(`''`)}`,
  end: `'`,
  patterns: [escapeChar, stringSubstitution],
};

const numericLiteral: MatchRule = {
  key: "numeric-literal",
  scope: "constant.numeric.bicep",
  match: `[0-9]+`,
};

const namedLiteral: MatchRule = {
  key: "named-literal",
  scope: "constant.language.bicep",
  match: bounded(`(true|false|null)`),
};

const identifierExpression: MatchRule = {
  key: "identifier",
  scope: "variable.other.readwrite.bicep",
  match: `${identifier}${notBefore(`${ws}\\(`)}`,
};

const objectLiteral: BeginEndRule = {
  key: "object-literal",
  scope: meta,
  begin: `{`,
  end: `}`,
  patterns: withComments([
    {
      key: "object-property-key",
      scope: "variable.other.property.bicep",
      match: `${identifier}${before(`${ws}:`)}`,
    },
    expression,
  ]),
};

const arrayLiteral: BeginEndRule = {
  key: "array-literal",
  scope: meta,
  begin: `\\[${notBefore(`${ws}${bounded(`for`)}`)}`,
  end: `]`,
  patterns: withComments([expression]),
};

const functionCall: BeginEndRule = {
  key: "function-call",
  scope: meta,
  begin: `(${identifier})${ws}\\(`,
  beginCaptures: {
    "1": { scope: "entity.name.function.bicep" },
  },
  end: `\\)`,
  patterns: withComments([expression]),
};

const decorator: BeginEndRule = {
  key: "decorator",
  scope: meta,
  begin: `@${ws}${before(identifier)}`,
  end: ``,
  patterns: withComments([expression]),
};

const lambdaStart =
  // biome-ignore lint/style/useTemplate: <explanation>
  `(` +
  `\\(${ws}${identifier}${ws}(,${ws}${identifier}${ws})*\\)|` +
  `\\(${ws}\\)|` +
  `${ws}${identifier}${ws}` +
  `)${before(`${ws}=>`)}`;

const lambda: BeginEndRule = {
  key: "lambda-start",
  scope: meta,
  begin: lambdaStart,
  beginCaptures: {
    "1": {
      scope: meta,
      patterns: withComments([identifierExpression]),
    },
  },
  end: `${ws}=>`,
};

const directiveStatement: BeginEndRule = {
  key: "directive",
  scope: meta,
  begin: `#${directive}`,
  end: `$`,
  patterns: withComments([
    {
      key: "directive-variable",
      scope: "keyword.control.declaration.bicep",
      match: directive,
    },
  ]),
};

expression.patterns = [
  stringLiteral,
  stringVerbatim,
  numericLiteral,
  namedLiteral,
  objectLiteral,
  arrayLiteral,
  keywordExpression,
  identifierExpression,
  functionCall,
  decorator,
  lambda,
  directiveStatement,
];

export const grammar: Grammar = {
  $schema: tm.schema,
  name: "Bicep",
  scopeName: "source.bicep",
  fileTypes: [".bicep", ".bicepparam"],
  patterns: withComments([expression]),
};
```

### examples/tmlanguage-generator/tmlanguage-generator.ts

```ts
import { readFile } from "fs/promises";
import { loadWASM, OnigRegExp } from "onigasm";
import { dirname, resolve } from "path";
import plist from "plist";

export const schema =
  "https://raw.githubusercontent.com/martinring/tmlanguage/master/tmlanguage.json";

/**
 * Special scope that indicates a larger construct that doesn't get a single color.
 * Expanded to meta.<key>.<grammar name> during emit.
 */
export const meta = Symbol("meta");

export interface RuleKey {
  /** Rule's unique key through which identifies the rule in the repository. */
  key: string;
}

export interface RuleScope<Scope extends string = string> {
  /**
   * The TextMate scope that gets assigned to a match and colored by a theme.
   * See https://macromates.com/manual/en/language_grammars#naming_conventions
   */
  scope: Scope | typeof meta;
}

export interface RulePatterns<Scope extends string = string> {
  patterns: Rule<Scope>[];
}

export type Captures<Scope extends string = string> = Record<
  string,
  RuleScope<Scope> | RulePatterns<Scope>
>;

export type Rule<Scope extends string = string> =
  | MatchRule<Scope>
  | BeginEndRule<Scope>
  | IncludeRule<Scope>;

export interface MatchRule<Scope extends string = string> extends RuleScope<Scope>, RuleKey {
  match: string;
  captures?: Captures<Scope>;
}

export interface BeginEndRule<Scope extends string = string>
  extends RuleKey,
    RuleScope<Scope>,
    Partial<RulePatterns<Scope>> {
  begin: string;
  end: string;
  beginCaptures?: Captures<Scope>;
  endCaptures?: Captures<Scope>;
}

export interface IncludeRule<Scope extends string = string> extends RuleKey, RulePatterns<Scope> {}

export interface Grammar<Scope extends string = string> extends RulePatterns<Scope> {
  $schema: typeof schema;
  name: string;
  scopeName: string;
  fileTypes: string[];
}

let initialized = false;
async function initialize() {
  if (!initialized) {
    const onigasmPath = require.resolve("onigasm");
    const wasmPath = resolve(dirname(onigasmPath), "onigasm.wasm");
    const wasm = await readFile(wasmPath);
    await loadWASM(wasm.buffer as any);
    initialized = true;
  }
}

export interface EmitOptions {
  errorSourceFilePath?: string;
}

/**
 * Emit the given grammar to JSON.
 */
export async function emitJSON(grammar: Grammar, options: EmitOptions = {}): Promise<string> {
  await initialize();
  const indent = 2;
  const processed = await processGrammar(grammar, options);
  return JSON.stringify(processed, undefined, indent);
}

/**
 * Emit the given grammar to PList XML
 */
export async function emitPList(grammar: Grammar, options: EmitOptions = {}): Promise<string> {
  await initialize();
  const processed = await processGrammar(grammar, options);
  return plist.build(processed);
}

/**
 * Convert the grammar from our more convenient representation to the
 * tmlanguage schema. Perform some validation in the process.
 */
async function processGrammar(grammar: Grammar, options: EmitOptions): Promise<any> {
  await initialize();

  // key is rule.key, value is [unprocessed rule, processed rule]. unprocessed
  // rule is used for its identity to check for duplicates and deal with cycles.
  const repository = new Map<string, [Rule, any]>();
  const output = processNode(grammar, options);
  output.repository = processRepository();
  return output;

  function processNode(node: any, options: EmitOptions): any {
    if (typeof node !== "object") {
      return node;
    }
    if (Array.isArray(node)) {
      return node.map((n) => processNode(n, options));
    }
    const output: any = {};
    for (const key in node) {
      const value = node[key];
      switch (key) {
        case "key":
          // Drop it. It was used to place the node in the repository, and does
          // not need to be retained on the node in the final structure.
          break;
        case "scope":
          // tmlanguage uses "name" confusingly for scope. We avoid "name" which
          // can be confused with the repository key.
          output.name = value === meta ? `meta.${node.key}.${grammar.name.toLowerCase()}` : value;
          break;
        case "begin":
        case "end":
        case "match":
          validateRegexp(value, node, key, options);
          output[key] = value;
          break;
        case "patterns":
          output[key] = processPatterns(value, options);
          break;
        default:
          output[key] = processNode(value, options);
          break;
      }
    }
    return output;
  }

  function processPatterns(rules: Rule[], options: EmitOptions) {
    for (const rule of rules) {
      if (!repository.has(rule.key)) {
        // put placeholder first to prevent cycles
        const entry: [Rule, any] = [rule, undefined];
        repository.set(rule.key, entry);
        // fill placeholder with processed node.
        entry[1] = processNode(rule, options);
      } else if (repository.get(rule.key)![0] !== rule) {
        throw new Error("Duplicate key: " + rule.key);
      }
    }

    return rules.map((r) => ({ include: `#${r.key}` }));
  }

  function processRepository() {
    const output: any = {};
    for (const key of [...repository.keys()].sort()) {
      output[key] = repository.get(key)![1];
    }
    return output;
  }

  function validateRegexp(regexp: string, node: any, prop: string, options: EmitOptions) {
    try {
      new OnigRegExp(regexp).testSync("");
    } catch (err: any) {
      if (/^[0-9,]+$/.test(err.message)) {
        // Work around for https://github.com/NeekSandhu/onigasm/issues/26
        const array = new Uint8Array(err.message.split(",").map((s: string) => Number(s)));
        const buffer = Buffer.from(array);
        err = new Error(buffer.toString("utf-8"));
      }
      const sourceFile = options.errorSourceFilePath ?? "unknown_file";
      //prettier-ignore
      // eslint-disable-next-line no-console
      console.error(`${sourceFile}(1,1): error TM0001: Bad regex: ${JSON.stringify({[prop]: regexp})}: ${err.message}`);
      // eslint-disable-next-line no-console
      console.error(node);
      throw err;
    }
  }
}

```

### examples/tmlanguage-generator/typescpec.ts

```ts
// TextMate-based syntax highlighting is implemented in this file.
// typespec.tmLanguage is generated by running this script.

import { mkdir, writeFile } from "fs/promises";
import { resolve } from "path";
import * as tm from "tmlanguage-generator";

type IncludeRule = tm.IncludeRule<TypeSpecScope>;
type BeginEndRule = tm.BeginEndRule<TypeSpecScope>;
type MatchRule = tm.MatchRule<TypeSpecScope>;
type Grammar = tm.Grammar<TypeSpecScope>;

export type TypeSpecScope =
  // Comments
  | "comment.block.tsp"
  | "comment.line.double-slash.tsp"
  // Constants
  | "constant.character.escape.tsp"
  | "constant.numeric.tsp"
  | "constant.language.tsp"
  // Keywords
  | "keyword.directive.name.tsp"
  | "keyword.other.tsp"
  | "keyword.tag.tspdoc"
  // Entities
  | "entity.name.type.tsp"
  | "entity.name.function.tsp"
  | "entity.name.tag.tsp"
  | "entity.name.function.macro.tsp"
  // Strings
  | "string.quoted.double.tsp"
  | "string.quoted.triple.tsp"
  // Variables
  | "variable.name.tsp"
  // Operators
  | "keyword.operator.type.annotation.tsp"
  | "keyword.operator.assignment.tsp"
  | "keyword.operator.optional.tsp"
  | "keyword.operator.selector.tsp"
  | "keyword.operator.spread.tsp"
  // Punctuation
  | "punctuation.comma.tsp"
  | "punctuation.accessor.tsp"
  | "punctuation.terminator.statement.tsp"
  | "punctuation.definition.typeparameters.begin.tsp"
  | "punctuation.definition.typeparameters.end.tsp"
  | "punctuation.definition.template-expression.begin.tsp"
  | "punctuation.definition.template-expression.end.tsp"
  | "punctuation.squarebracket.open.tsp"
  | "punctuation.squarebracket.close.tsp"
  | "punctuation.curlybrace.open.tsp"
  | "punctuation.curlybrace.close.tsp"
  | "punctuation.parenthesis.open.tsp"
  | "punctuation.parenthesis.close.tsp"
  | "punctuation.hashcurlybrace.open.tsp"
  | "punctuation.hashsquarebracket.open.tsp";

const meta: typeof tm.meta = tm.meta;
const identifierStart = "[_$[:alpha:]]";
// cspell:disable-next-line
const identifierContinue = "[_$[:alnum:]]";
const beforeIdentifier = `(?=(${identifierStart}|\`))`;
const escapedIdentifier = "`(?:[^`\\\\]|\\\\.)*`";
const simpleIdentifier = `\\b${identifierStart}${identifierContinue}*\\b`;
const identifier = `${simpleIdentifier}|${escapedIdentifier}`;
const qualifiedIdentifier = `\\b${identifierStart}(?:${identifierContinue}|\\.${identifierStart})*\\b`;
const stringPattern = '\\"(?:[^\\"\\\\]|\\\\.)*\\"';
const modifierKeyword = `\\b(?:extern)\\b`;
const statementKeyword = `\\b(?:namespace|model|op|using|import|enum|alias|union|interface|dec|fn)\\b`;
const universalEnd = `(?=,|;|@|\\)|\\}|${modifierKeyword}|${statementKeyword})`;
const universalEndExceptComma = `(?=;|@|\\)|\\}|${modifierKeyword}|${statementKeyword})`;

/**
 * Universal end with extra end char: `=`
 */
const expressionEnd = `(?=,|;|@|\\)|\\}|=|${statementKeyword})`;
const hexNumber = "\\b(?<!\\$)0(?:x|X)[0-9a-fA-F][0-9a-fA-F_]*(n)?\\b(?!\\$)";
const binaryNumber = "\\b(?<!\\$)0(?:b|B)[01][01_]*(n)?\\b(?!\\$)";
const decimalNumber =
  "(?<!\\$)(?:" +
  "(?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|" + // 1.1E+3
  "(?:\\b[0-9][0-9_]*(\\.)[eE][+-]?[0-9][0-9_]*(n)?\\b)|" + // 1.E+3
  "(?:\\B(\\.)[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|" + // .1E+3
  "(?:\\b[0-9][0-9_]*[eE][+-]?[0-9][0-9_]*(n)?\\b)|" + // 1E+3
  "(?:\\b[0-9][0-9_]*(\\.)[0-9][0-9_]*(n)?\\b)|" + // 1.1
  "(?:\\b[0-9][0-9_]*(\\.)(n)?\\B)|" + // 1.
  "(?:\\B(\\.)[0-9][0-9_]*(n)?\\b)|" + // .1
  "(?:\\b[0-9][0-9_]*(n)?\\b(?!\\.))" + // 1
  ")(?!\\$)";
const anyNumber = `(?:${hexNumber}|${binaryNumber}|${decimalNumber})`;

const expression: IncludeRule = {
  key: "expression",
  patterns: [
    /* placeholder filled later due to cycle*/
  ],
};

const statement: IncludeRule = {
  key: "statement",
  patterns: [
    /*placeholder filled later due to cycle*/
  ],
};

const booleanLiteral: MatchRule = {
  key: "boolean-literal",
  scope: "constant.language.tsp",
  match: `\\b(true|false)\\b`,
};

const escapeChar: MatchRule = {
  key: "escape-character",
  scope: "constant.character.escape.tsp",
  match: "\\\\.",
};

const templateExpression: BeginEndRule = {
  key: "template-expression",
  scope: meta,
  begin: "\\$\\{",
  beginCaptures: {
    "0": { scope: "punctuation.definition.template-expression.begin.tsp" },
  },
  end: "\\}",
  endCaptures: {
    "0": { scope: "punctuation.definition.template-expression.end.tsp" },
  },
  patterns: [expression],
};

const stringLiteral: BeginEndRule = {
  key: "string-literal",
  scope: "string.quoted.double.tsp",
  begin: '"',
  end: '"|$',
  patterns: [templateExpression, escapeChar],
};

const tripleQuotedStringLiteral: BeginEndRule = {
  key: "triple-quoted-string-literal",
  scope: "string.quoted.triple.tsp",
  begin: '"""',
  end: '"""',
  patterns: [templateExpression, escapeChar],
};

const punctuationComma: MatchRule = {
  key: "punctuation-comma",
  scope: "punctuation.comma.tsp",
  match: ",",
};

const punctuationAccessor: MatchRule = {
  key: "punctuation-accessor",
  scope: "punctuation.accessor.tsp",
  match: "\\.",
};

const punctuationSemicolon: MatchRule = {
  key: "punctuation-semicolon",
  scope: "punctuation.terminator.statement.tsp",
  match: ";",
};

const operatorAssignment: MatchRule = {
  key: "operator-assignment",
  scope: "keyword.operator.assignment.tsp",
  match: "=",
};

const numericLiteral: MatchRule = {
  key: "numeric-literal",
  scope: "constant.numeric.tsp",
  match: anyNumber,
};

const lineComment: MatchRule = {
  key: "line-comment",
  scope: "comment.line.double-slash.tsp",
  match: "//.*$",
};

const blockComment: BeginEndRule = {
  key: "block-comment",
  scope: "comment.block.tsp",
  begin: "/\\*",
  end: "\\*/",
};

const docCommentParam: MatchRule = {
  key: "doc-comment-param",
  scope: "comment.block.tsp",
  match: `(?x)((@)(?:param|template|prop))\\s+(${identifier})\\b`,
  captures: {
    "1": { scope: "keyword.tag.tspdoc" },
    "2": { scope: "keyword.tag.tspdoc" },
    "3": { scope: "variable.name.tsp" },
  },
};

const docCommentReturn: MatchRule = {
  key: "doc-comment-return-tag",
  scope: "comment.block.tsp",
  match: `(?x)((@)(?:returns))\\b`,
  captures: {
    "1": { scope: "keyword.tag.tspdoc" },
    "2": { scope: "keyword.tag.tspdoc" },
  },
};

const docCommentUnknownTag: MatchRule = {
  key: "doc-comment-unknown-tag",
  scope: "comment.block.tsp",
  match: `(?x)((@)(?:${identifier}))\\b`,
  captures: {
    "1": { scope: "entity.name.tag.tsp" },
    "2": { scope: "entity.name.tag.tsp" },
  },
};

const docCommentBlock: IncludeRule = {
  key: "doc-comment-block",
  patterns: [docCommentParam, docCommentReturn, docCommentUnknownTag],
};

const docComment: BeginEndRule = {
  key: "doc-comment",
  scope: "comment.block.tsp",
  begin: "/\\*\\*",
  beginCaptures: {
    "0": { scope: "comment.block.tsp" },
  },
  end: "\\*/",
  endCaptures: {
    "0": { scope: "comment.block.tsp" },
  },
  patterns: [docCommentBlock],
};

// Tokens that match standing alone in any context: literals and comments
const token: IncludeRule = {
  key: "token",
  patterns: [
    docComment,
    lineComment,
    blockComment,

    // `"""` must come before `"` or first two quotes of `"""` will match as
    // empty string
    tripleQuotedStringLiteral,
    stringLiteral,
    booleanLiteral,
    numericLiteral,
  ],
};

const parenthesizedExpression: BeginEndRule = {
  key: "parenthesized-expression",
  scope: meta,
  begin: "\\(",
  beginCaptures: {
    "0": { scope: "punctuation.parenthesis.open.tsp" },
  },
  end: "\\)",
  endCaptures: {
    "0": { scope: "punctuation.parenthesis.close.tsp" },
  },
  patterns: [expression, punctuationComma],
};

const callExpression: BeginEndRule = {
  key: "callExpression",
  scope: meta,
  begin: `(${qualifiedIdentifier})\\s*(\\()`,
  beginCaptures: {
    "1": { scope: "entity.name.function.tsp" },
    "2": { scope: "punctuation.parenthesis.open.tsp" },
  },
  end: "\\)",
  endCaptures: {
    "0": { scope: "punctuation.parenthesis.close.tsp" },
  },
  patterns: [token, expression, punctuationComma],
};

const decorator: BeginEndRule = {
  key: "decorator",
  scope: meta,
  begin: `((@)${qualifiedIdentifier})`,
  beginCaptures: {
    "1": { scope: "entity.name.tag.tsp" },
    "2": { scope: "entity.name.tag.tsp" },
  },
  end: `${beforeIdentifier}|${universalEnd}`,
  patterns: [token, parenthesizedExpression],
};

const augmentDecoratorStatement: BeginEndRule = {
  key: "augment-decorator-statement",
  scope: meta,
  begin: `((@@)${qualifiedIdentifier})`,
  beginCaptures: {
    "1": { scope: "entity.name.tag.tsp" },
    "2": { scope: "entity.name.tag.tsp" },
  },
  end: `${beforeIdentifier}|${universalEnd}`,
  patterns: [token, parenthesizedExpression],
};

const identifierExpression: MatchRule = {
  key: "identifier-expression",
  scope: "entity.name.type.tsp",
  match: identifier,
};

const valueOfExpression: BeginEndRule = {
  key: "valueof",
  scope: meta,
  begin: `\\b(valueof)`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: `(?=>)|${universalEnd}`,
  patterns: [expression],
};
const typeOfExpression: BeginEndRule = {
  key: "typeof",
  scope: meta,
  begin: `\\b(typeof)`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: `(?=>)|${universalEnd}`,
  patterns: [expression],
};

const typeArgument: BeginEndRule = {
  key: "type-argument",
  scope: meta,
  begin: `(?:(${identifier})\\s*(=))`,
  beginCaptures: {
    "1": { scope: "entity.name.type.tsp" },
    "2": { scope: "keyword.operator.assignment.tsp" },
  },
  end: `(?=>)|${universalEnd}`,
  endCaptures: {
    "0": { scope: "keyword.operator.assignment.tsp" },
  },
  patterns: [token, expression, punctuationComma],
};
const typeArguments: BeginEndRule = {
  key: "type-arguments",
  scope: meta,
  begin: "<",
  beginCaptures: {
    "0": { scope: "punctuation.definition.typeparameters.begin.tsp" },
  },
  end: ">",
  endCaptures: {
    "0": { scope: "punctuation.definition.typeparameters.end.tsp" },
  },
  patterns: [typeArgument, expression, punctuationComma],
};

const typeParameterConstraint: BeginEndRule = {
  key: "type-parameter-constraint",
  scope: meta,
  begin: `extends`,
  beginCaptures: {
    "0": { scope: "keyword.other.tsp" },
  },
  end: `(?=>)|${universalEnd}`,
  patterns: [expression],
};

const typeParameterDefault: BeginEndRule = {
  key: "type-parameter-default",
  scope: meta,
  begin: `=`,
  beginCaptures: {
    "0": { scope: "keyword.operator.assignment.tsp" },
  },
  end: `(?=>)|${universalEnd}`,
  patterns: [expression],
};

const typeParameter: BeginEndRule = {
  key: "type-parameter",
  scope: meta,
  begin: `(${identifier})`,
  beginCaptures: {
    "1": { scope: "entity.name.type.tsp" },
  },
  end: `(?=>)|${universalEnd}`,
  patterns: [token, typeParameterConstraint, typeParameterDefault],
};

const typeParameters: BeginEndRule = {
  key: "type-parameters",
  scope: meta,
  begin: "<",
  beginCaptures: {
    "0": { scope: "punctuation.definition.typeparameters.begin.tsp" },
  },
  end: ">",
  endCaptures: {
    "0": { scope: "punctuation.definition.typeparameters.end.tsp" },
  },
  patterns: [typeParameter, punctuationComma],
};

const tupleLiteral: BeginEndRule = {
  key: "tuple-literal",
  scope: meta,
  begin: "#\\[",
  beginCaptures: {
    "0": { scope: "punctuation.hashsquarebracket.open.tsp" },
  },
  end: "\\]",
  endCaptures: {
    "0": { scope: "punctuation.squarebracket.close.tsp" },
  },
  patterns: [expression, punctuationComma],
};

const tupleExpression: BeginEndRule = {
  key: "tuple-expression",
  scope: meta,
  begin: "\\[",
  beginCaptures: {
    "0": { scope: "punctuation.squarebracket.open.tsp" },
  },
  end: "\\]",
  endCaptures: {
    "0": { scope: "punctuation.squarebracket.close.tsp" },
  },
  patterns: [expression],
};

const typeAnnotation: BeginEndRule = {
  key: "type-annotation",
  scope: meta,
  begin: "\\s*(\\??)\\s*(:)",
  beginCaptures: {
    "1": { scope: "keyword.operator.optional.tsp" },
    "2": { scope: "keyword.operator.type.annotation.tsp" },
  },
  end: expressionEnd,
  patterns: [expression],
};

const modelProperty: BeginEndRule = {
  key: "model-property",
  scope: meta,
  begin: `(?:(${identifier})|(${stringPattern}))`,
  beginCaptures: {
    "1": { scope: "variable.name.tsp" },
    "2": { scope: "string.quoted.double.tsp" },
  },
  end: universalEnd,
  patterns: [token, typeAnnotation, operatorAssignment, expression],
};

const spreadExpression: BeginEndRule = {
  key: "spread-operator",
  scope: meta,
  begin: "\\.\\.\\.",
  beginCaptures: {
    "0": { scope: "keyword.operator.spread.tsp" },
  },
  end: universalEnd,
  patterns: [expression],
};

const directive: BeginEndRule = {
  key: "directive",
  scope: meta,
  begin: `\\s*(#${simpleIdentifier})`,
  beginCaptures: {
    "1": { scope: "keyword.directive.name.tsp" },
  },
  end: `$|${universalEnd}`,
  patterns: [stringLiteral, identifierExpression],
};

const modelExpression: BeginEndRule = {
  key: "model-expression",
  scope: meta,
  begin: "\\{",
  beginCaptures: {
    "0": { scope: "punctuation.curlybrace.open.tsp" },
  },
  end: "\\}",
  endCaptures: {
    "0": { scope: "punctuation.curlybrace.close.tsp" },
  },
  patterns: [
    // modelProperty must come before token or quoted property name will be
    // considered an arbitrarily positioned string literal and not match as part
    // of modelProperty begin.
    modelProperty,
    token,
    directive,
    decorator,
    spreadExpression,
    punctuationSemicolon,
  ],
};

const objectLiteralProperty: BeginEndRule = {
  key: "object-literal-property",
  scope: meta,
  begin: `(?:(${identifier})\\s*(:))`,
  beginCaptures: {
    "1": { scope: "variable.name.tsp" },
    "2": { scope: "keyword.operator.type.annotation.tsp" },
  },
  end: universalEnd,
  patterns: [token, expression],
};

const objectLiteral: BeginEndRule = {
  key: "object-literal",
  scope: meta,
  begin: "#\\{",
  beginCaptures: {
    "0": { scope: "punctuation.hashcurlybrace.open.tsp" },
  },
  end: "\\}",
  endCaptures: {
    "0": { scope: "punctuation.curlybrace.close.tsp" },
  },
  patterns: [token, objectLiteralProperty, directive, spreadExpression, punctuationComma],
};

const modelHeritage: BeginEndRule = {
  key: "model-heritage",
  scope: meta,
  begin: "\\b(extends|is)\\b",
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: `((?=\\{)|${universalEndExceptComma})`,
  patterns: [expression, punctuationComma],
};

const modelStatement: BeginEndRule = {
  key: "model-statement",
  scope: meta,
  begin: "\\b(model)\\b",
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: `(?<=\\})|${universalEnd}`,
  patterns: [
    token,
    typeParameters,
    modelHeritage, // before expression or `extends` or `is` will look like type name
    expression, // enough to match name, type parameters, and body.
  ],
};

const operationParameters: BeginEndRule = {
  key: "operation-parameters",
  scope: meta,
  begin: "\\(",
  beginCaptures: {
    "0": { scope: "punctuation.parenthesis.open.tsp" },
  },
  end: "\\)",
  endCaptures: {
    "0": { scope: "punctuation.parenthesis.close.tsp" },
  },
  patterns: [token, decorator, modelProperty, spreadExpression, punctuationComma],
};

const scalarExtends: BeginEndRule = {
  key: "scalar-extends",
  scope: meta,
  begin: "\\b(extends)\\b",
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: universalEndExceptComma,
  patterns: [expression, punctuationComma],
};

const scalarConstructor: BeginEndRule = {
  key: "scalar-constructor",
  scope: meta,
  begin: `\\b(init)\\b\\s+(${identifier})`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
    "2": { scope: "entity.name.function.tsp" },
  },
  end: universalEnd,
  patterns: [token, operationParameters],
};

const scalarBody: BeginEndRule = {
  key: "scalar-body",
  scope: meta,
  begin: "\\{",
  beginCaptures: {
    "0": { scope: "punctuation.curlybrace.open.tsp" },
  },
  end: "\\}",
  endCaptures: {
    "0": { scope: "punctuation.curlybrace.close.tsp" },
  },
  patterns: [token, directive, scalarConstructor, punctuationSemicolon],
};

const scalarStatement: BeginEndRule = {
  key: "scalar-statement",
  scope: meta,
  begin: `\\b(scalar)\\b\\s+(${identifier})`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
    "2": { scope: "entity.name.type.tsp" },
  },
  end: `(?<=\\})|${universalEnd}`,
  patterns: [
    token,
    typeParameters,
    scalarExtends, // before expression or `extends` will look like type name
    scalarBody,
  ],
};

const enumMember: BeginEndRule = {
  key: "enum-member",
  scope: meta,
  begin: `(?:(${identifier})\\s*(:?))`,
  beginCaptures: {
    "1": { scope: "variable.name.tsp" },
    "2": { scope: "keyword.operator.type.annotation.tsp" },
  },
  end: universalEnd,
  patterns: [token, typeAnnotation],
};

const enumBody: BeginEndRule = {
  key: "enum-body",
  scope: meta,
  begin: "\\{",
  beginCaptures: {
    "0": { scope: "punctuation.curlybrace.open.tsp" },
  },
  end: "\\}",
  endCaptures: {
    "0": { scope: "punctuation.curlybrace.close.tsp" },
  },
  patterns: [enumMember, token, directive, decorator, punctuationComma],
};

const enumStatement: BeginEndRule = {
  key: "enum-statement",
  scope: meta,
  begin: `\\b(enum)\\b\\s+(${identifier})`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
    "2": { scope: "entity.name.type.tsp" },
  },
  end: `(?<=\\})|${universalEnd}`,
  patterns: [token, enumBody],
};

const namedUnionVariant: BeginEndRule = {
  key: "union-variant",
  scope: meta,
  begin: `(?:(${identifier})\\s*(:))`,
  beginCaptures: {
    "1": { scope: "variable.name.tsp" },
    "2": { scope: "keyword.operator.type.annotation.tsp" },
  },
  end: universalEnd,
  patterns: [token, expression],
};

const unionBody: BeginEndRule = {
  key: "union-body",
  scope: meta,
  begin: "\\{",
  beginCaptures: {
    "0": { scope: "punctuation.curlybrace.open.tsp" },
  },
  end: "\\}",
  endCaptures: {
    "0": { scope: "punctuation.curlybrace.close.tsp" },
  },
  patterns: [namedUnionVariant, token, directive, decorator, expression, punctuationComma],
};

const unionStatement: BeginEndRule = {
  key: "union-statement",
  scope: meta,
  begin: `\\b(union)\\b\\s+(${identifier})`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
    "2": { scope: "entity.name.type.tsp" },
  },
  end: `(?<=\\})|${universalEnd}`,
  patterns: [token, unionBody],
};

const aliasAssignment: BeginEndRule = {
  key: "alias-id",
  scope: meta,
  begin: `(=)\\s*`,
  beginCaptures: {
    "1": { scope: "keyword.operator.assignment.tsp" },
  },
  end: universalEnd,
  patterns: [expression],
};

const aliasStatement: BeginEndRule = {
  key: "alias-statement",
  scope: meta,
  begin: `\\b(alias)\\b\\s+(${identifier})\\s*`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
    "2": { scope: "entity.name.type.tsp" },
  },
  end: universalEnd,
  patterns: [aliasAssignment, typeParameters],
};

const constStatement: BeginEndRule = {
  key: "const-statement",
  scope: meta,
  begin: `\\b(const)\\b\\s+(${identifier})`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
    "2": { scope: "variable.name.tsp" },
  },
  end: universalEnd,
  patterns: [typeAnnotation, operatorAssignment, expression],
};

const namespaceName: BeginEndRule = {
  key: "namespace-name",
  scope: meta,
  begin: beforeIdentifier,
  end: `((?=\\{)|${universalEnd})`,
  patterns: [identifierExpression, punctuationAccessor],
};

const namespaceBody: BeginEndRule = {
  key: "namespace-body",
  scope: meta,
  begin: "\\{",
  beginCaptures: {
    "0": { scope: "punctuation.curlybrace.open.tsp" },
  },
  end: "\\}",
  endCaptures: {
    "0": { scope: "punctuation.curlybrace.close.tsp" },
  },
  patterns: [statement],
};

const namespaceStatement: BeginEndRule = {
  key: "namespace-statement",
  scope: meta,
  begin: "\\b(namespace)\\b",
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: `((?<=\\})|${universalEnd})`,
  patterns: [token, namespaceName, namespaceBody],
};

const operationHeritage: BeginEndRule = {
  key: "operation-heritage",
  scope: meta,
  begin: "\\b(is)\\b",
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: universalEnd,
  patterns: [expression],
};

const operationSignature: IncludeRule = {
  key: "operation-signature",
  patterns: [
    typeParameters,
    operationHeritage,
    operationParameters,
    typeAnnotation, // return type
  ],
};

const operationStatement: BeginEndRule = {
  key: "operation-statement",
  scope: meta,
  begin: `\\b(op)\\b\\s+(${identifier})`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
    "2": { scope: "entity.name.function.tsp" },
  },
  end: universalEnd,
  patterns: [token, operationSignature],
};

const interfaceMember: BeginEndRule = {
  key: "interface-member",
  scope: meta,
  begin: `(?:\\b(op)\\b\\s+)?(${identifier})`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
    "2": { scope: "entity.name.function.tsp" },
  },
  end: universalEnd,
  patterns: [token, operationSignature],
};

const interfaceHeritage: BeginEndRule = {
  key: "interface-heritage",
  scope: meta,
  begin: "\\b(extends)\\b",
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: `((?=\\{)|${universalEndExceptComma})`,
  patterns: [expression, punctuationComma],
};

const interfaceBody: BeginEndRule = {
  key: "interface-body",
  scope: meta,
  begin: "\\{",
  beginCaptures: {
    "0": { scope: "punctuation.curlybrace.open.tsp" },
  },
  end: "\\}",
  endCaptures: {
    "0": { scope: "punctuation.curlybrace.close.tsp" },
  },
  patterns: [token, directive, decorator, interfaceMember, punctuationSemicolon],
};

const interfaceStatement: BeginEndRule = {
  key: "interface-statement",
  scope: meta,
  begin: "\\b(interface)\\b",
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: `(?<=\\})|${universalEnd}`,
  patterns: [
    token,
    typeParameters,
    interfaceHeritage, // before expression or extends will look like type name
    interfaceBody, // before expression or { will match model expression
    expression, // enough to match name and type parameters
  ],
};

const importStatement: BeginEndRule = {
  key: "import-statement",
  scope: meta,
  begin: "\\b(import)\\b",
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: universalEnd,
  patterns: [token],
};

const usingStatement: BeginEndRule = {
  key: "using-statement",
  scope: meta,
  begin: "\\b(using)\\b",
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
  },
  end: universalEnd,
  patterns: [token, identifierExpression, punctuationAccessor],
};

const decoratorDeclarationStatement: BeginEndRule = {
  key: "decorator-declaration-statement",
  scope: meta,
  begin: `(?:(extern)\\s+)?\\b(dec)\\b\\s+(${identifier})`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
    "2": { scope: "keyword.other.tsp" },
    "3": { scope: "entity.name.function.tsp" },
  },
  end: universalEnd,
  patterns: [token, operationParameters],
};

const functionDeclarationStatement: BeginEndRule = {
  key: "function-declaration-statement",
  scope: meta,
  begin: `(?:(extern)\\s+)?\\b(fn)\\b\\s+(${identifier})`,
  beginCaptures: {
    "1": { scope: "keyword.other.tsp" },
    "2": { scope: "keyword.other.tsp" },
    "3": { scope: "entity.name.function.tsp" },
  },
  end: universalEnd,
  patterns: [token, operationParameters, typeAnnotation],
};

// NOTE: We don't actually classify all the different expression types and their
// punctuation yet. For now, at least, we only deal with the ones that would
// break coloring due to breaking out of context inappropriately with parens/
// braces/brackets that weren't handled with appropriate precedence. The other
// expressions color acceptably as unclassified punctuation around those we do
// handle here.
expression.patterns = [
  token,
  directive,
  parenthesizedExpression,
  valueOfExpression,
  typeOfExpression,
  typeArguments,
  objectLiteral,
  tupleLiteral,
  tupleExpression,
  modelExpression,
  callExpression,
  identifierExpression,
];

statement.patterns = [
  token,
  directive,
  augmentDecoratorStatement,
  decorator,
  modelStatement,
  scalarStatement,
  unionStatement,
  interfaceStatement,
  enumStatement,
  aliasStatement,
  constStatement,
  namespaceStatement,
  operationStatement,
  importStatement,
  usingStatement,
  decoratorDeclarationStatement,
  functionDeclarationStatement,
  punctuationSemicolon,
];

export const grammar: Grammar = {
  $schema: tm.schema,
  name: "TypeSpec",
  scopeName: "source.tsp",
  fileTypes: ["tsp"],
  patterns: [statement],
};

```

