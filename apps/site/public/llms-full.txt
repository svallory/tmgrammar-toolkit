# tmgrammar-toolkit - Complete Documentation

A TypeScript toolkit for creating TextMate grammars with type safety, validation, and integrated testing.

---

## Main README

# tmgrammar-toolkit

To install dependencies:

```bash
bun install
```

To run:

```bash
bun run index.ts
```

This project was created using `bun init` in bun v1.2.18. [Bun](https://bun.sh) is a fast all-in-one JavaScript runtime.


---

## Project Instructions (CLAUDE.md)

# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

tmgrammar-toolkit is a TypeScript toolkit for creating TextMate grammars with type safety, validation, and integrated testing. It transforms writing TextMate grammars from error-prone JSON files into a type-safe, testable development experience.

## Essential Commands

```bash
# Development
bun run build        # Clean and compile TypeScript
bun run dev          # Watch mode compilation

# Testing
bun test             # Run all tests
bun test:watch       # Run tests in watch mode
bun test <file>      # Run specific test file

# Code Quality
bun run lint         # Run ESLint
bun run lint:fix     # Auto-fix linting issues
bun run format       # Format with Prettier

# CLI Commands (use bunx or npx)
bunx tmt emit <grammar.ts>           # Generate JSON grammar
bunx tmt test <test-files> -g <grammar>  # Run declarative tests
bunx tmt snap <files> --update       # Generate/update snapshots
bunx tmt validate <grammar>          # Validate grammar
```

## Architecture

### Core Modules
- **`/src/factory.ts`**: Main grammar creation API (`createGrammar()`)
- **`/src/scopes`**: Type-safe scope system with proxy-based access
- **`/src/cli`**: Command-line interface implementation
- **`/src/helpers`**: Regex construction utilities
- **`/src/terminals`**: Pre-built patterns for common language constructs
- **`/src/testing`**: Testing framework for grammars
- **`/src/validation`**: Grammar and pattern validation

### Key Patterns
1. **Factory Pattern**: Use `createGrammar()` with typed rule objects
2. **Type-Safe Scopes**: Access via `scopes.category.subcategory`
3. **Repository Auto-generation**: Rules with keys become repository items
4. **Modular Exports**: Each module has its own README and exports

### Testing
- Unit tests mirror source structure in `/tests`
- Use Vitest for testing
- Snapshot tests for grammar output
- Declarative test format support

## Development Guidelines

1. **Type Safety**: Maintain strong typing for all APIs
2. **Module Structure**: Each feature should be a separate module with README
3. **Testing**: Write tests for all new functionality
4. **Performance**: Use atomic grouping and pattern optimization
5. **Documentation**: Update module READMEs when changing APIs

## Common Tasks

### Adding New Features
1. Create module in appropriate directory
2. Add types to `types.ts` if needed
3. Export from module's index.ts
4. Add tests in corresponding test directory
5. Update module README

### Working with CLI
- CLI commands are in `/src/cli/commands`
- Use Commander.js patterns
- Support both TS and compiled JS grammars
- Handle Bun runtime for direct TS execution

### Grammar Development
- Use `createGrammar()` factory
- Define rules with proper types (MatchRule, BeginEndRule, etc.)
- Use scope helpers for readability
- Test with declarative tests or programmatic API\n\n
---

Default to using Bun instead of Node.js.

- Use `bun <file>` instead of `node <file>` or `ts-node <file>`
- Use `bun test` instead of `jest` or `vitest`
- Use `bun build <file.html|file.ts|file.css>` instead of `webpack` or `esbuild`
- Use `bun install` instead of `npm install` or `yarn install` or `pnpm install`
- Use `bun run <script>` instead of `npm run <script>` or `yarn run <script>` or `pnpm run <script>`
- Bun automatically loads .env, so don't use dotenv.

## APIs

- `Bun.serve()` supports WebSockets, HTTPS, and routes. Don't use `express`.
- `bun:sqlite` for SQLite. Don't use `better-sqlite3`.
- `Bun.redis` for Redis. Don't use `ioredis`.
- `Bun.sql` for Postgres. Don't use `pg` or `postgres.js`.
- `WebSocket` is built-in. Don't use `ws`.
- Prefer `Bun.file` over `node:fs`'s readFile/writeFile
- Bun.$`ls` instead of execa.

## Testing

Use `bun test` to run tests.

```ts#index.test.ts
import { test, expect } from "bun:test";

test("hello world", () => {
  expect(1).toBe(1);
});
```

## Frontend

Use HTML imports with `Bun.serve()`. Don't use `vite`. HTML imports fully support React, CSS, Tailwind.

Server:

```ts#index.ts
import index from "./index.html"

Bun.serve({
  routes: {
    "/": index,
    "/api/users/:id": {
      GET: (req) => {
        return new Response(JSON.stringify({ id: req.params.id }));
      },
    },
  },
  // optional websocket support
  websocket: {
    open: (ws) => {
      ws.send("Hello, world!");
    },
    message: (ws, message) => {
      ws.send(message);
    },
    close: (ws) => {
      // handle close
    }
  },
  development: {
    hmr: true,
    console: true,
  }
})
```

HTML files can import .tsx, .jsx or .js files directly and Bun's bundler will transpile & bundle automatically. `<link>` tags can point to stylesheets and Bun's CSS bundler will bundle.

```html#index.html
<html>
  <body>
    <h1>Hello, world!</h1>
    <script type="module" src="./frontend.tsx"></script>
  </body>
</html>
```

With the following `frontend.tsx`:

```tsx#frontend.tsx
import React from "react";

// import .css files directly and it works
import './index.css';

import { createRoot } from "react-dom/client";

const root = createRoot(document.body);

export default function Frontend() {
  return <h1>Hello, world!</h1>;
}

root.render(<Frontend />);
```

Then, run index.ts

```sh
bun --hot ./index.ts
```

For more information, read the Bun API docs in `node_modules/bun-types/docs/**.md`.


---

## docs/README.md

# TextMate Toolkit Documentation

Complete documentation for building, testing, and shipping TextMate grammars with TypeScript.

## üìö Documentation Overview

This documentation suite covers everything you need to know about the TextMate Toolkit, from basic concepts to advanced techniques.

### Getting Started
- **[Getting Started Guide](getting-started.md)** - Your first grammar in 15 minutes
- **[Core Concepts](modules-overview.md)** - Understanding the toolkit architecture
- **[API Reference](api-reference.md)** - Complete function and type reference

### Deep Dives
- **[TextMate Scopes Reference](textmate-scopes.md)** - Complete scope naming conventions
- **[Using Scopes](using-scopes.md)** - Type-safe scope management
- **[Troubleshooting Guide](troubleshooting.md)** - Common issues and solutions

## üéØ Quick Navigation

### By Experience Level

**New to TextMate Grammars?**
1. Start with [Getting Started Guide](getting-started.md)
2. Read [Core Concepts](modules-overview.md) 
3. Try the examples in the toolkit

**Experienced with TextMate?**
1. Check out [API Reference](api-reference.md)
2. Explore [TextMate Scopes Reference](textmate-scopes.md)
3. Use [Troubleshooting Guide](troubleshooting.md) when needed

**Building Production Grammars?**
1. Master [Testing patterns](modules-overview.md#testing---making-sure-it-actually-works)
2. Follow [Performance tips](troubleshooting.md#performance-optimization)
3. Set up comprehensive validation workflows

### By Task

| I want to... | Read this |
|--------------|-----------|
| Create my first grammar | [Getting Started Guide](getting-started.md) |
| Understand the architecture | [Modules Overview](modules-overview.md) |
| Look up API functions | [API Reference](api-reference.md) |
| Use type-safe scopes | [Using Scopes](using-scopes.md) |
| Fix highlighting issues | [Troubleshooting Guide](troubleshooting.md) |
| Learn scope conventions | [TextMate Scopes Reference](textmate-scopes.md) |
| Understand the CLI | [Modules Overview](modules-overview.md#cli-architecture) |

## üèóÔ∏è Architecture Overview

The toolkit is built around these core concepts:

```
Grammar Definition (TypeScript)
         ‚Üì
    Factory Functions
         ‚Üì
    Rule System (Match/BeginEnd/Include)
         ‚Üì
    Validation (during emit/load)
         ‚Üì
    Emission (JSON/Plist)
         ‚Üì
    TextMate Grammar File
```

**Key Components:**
- **Factory Functions** - Clean APIs for creating grammars and rules
- **Type-Safe Scopes** - Prevent typos and ensure consistency
- **Regex Helpers** - Readable pattern construction
- **Terminal Patterns** - Pre-built patterns for common constructs
- **Validation System** - On-demand validation during emission and loading
- **Testing Framework** - Programmatic and declarative testing
- **Emission System** - Convert TypeScript to TextMate JSON/Plist
- **CLI** - A modular and maintainable command-line interface

## üìñ Documentation Categories

### Core Documentation

**[Modules Overview](modules-overview.md)** *(15 min read)*
- Complete architectural guide
- Module-by-module breakdown
- Real-world workflow examples
- Performance optimization tips

**[API Reference](api-reference.md)** *(Reference)*
- All public functions and types
- Complete parameter documentation
- Usage examples for every API
- TypeScript interface definitions

### Scope Management

**[TextMate Scopes Reference](textmate-scopes.md)** *(20 min read)*
- Complete scope naming conventions
- TextMate specification compliance
- Best practices for editor compatibility
- Scope hierarchy explanations

**[Using Scopes](using-scopes.md)** *(10 min read)*
- Type-safe scope API usage
- Creating static and extensible scopes
- Language-specific scope patterns
- Editor integration tips

### Practical Guides

**[Getting Started Guide](getting-started.md)** *(10 min read)*
- Step-by-step first grammar
- Core concept explanations
- Testing your grammar
- Common patterns and examples

**[Troubleshooting Guide](troubleshooting.md)** *(Reference)*
- Common issues and solutions
- Debugging techniques
- Performance optimization
- Error message explanations

## üé® Examples and Patterns

The toolkit includes complete example implementations:

- **Simple Language** - Basic keywords, comments, strings
- **Bicep** - Azure resource definitions with complex patterns
- **TypeSpec** - API definition language with advanced features

Find these in the `examples/` directory.

## üöÄ Quick Reference

### Essential APIs

```typescript
// Grammar creation
import { createGrammar, scopes, regex } from 'tmgrammar-toolkit';

// Terminal patterns
import { COMMENT, NUM, ID, OP } from 'tmgrammar-toolkit/terminals';

// Testing
import { createTesterFromContent } from 'tmgrammar-toolkit/testing';

// Validation
import { validateRegex, validateGrammar } from 'tmgrammar-toolkit/validation';

// Emission
import { emitJSON, emitPList } from 'tmgrammar-toolkit';
```

### Common Patterns

```typescript
// Keywords
const keywords = { 
  key: 'keywords',
  match: regex.keywords(['if', 'else', 'while']),
  scope: scopes.keyword.control
};

// Strings with escapes
const strings = {
  key: 'string',
  begin: /"/,
  end: /"/,
  scope: scopes.string.quoted.double,
  patterns: [
    { key: 'escape', match: /\\./, scope: scopes.constant.character.escape }
  ]
};

// Numbers
const numbers = {
  key: 'numbers',
  match: NUM.DEC,
  scope: scopes.constant.numeric
};
```

## üîó External Resources

- **[TextMate Grammar Manual](https://macromates.com/manual/en/language_grammars)** - Official specification
- **[VS Code Syntax Highlighting Guide](https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide)** - VS Code specifics
- **[Oniguruma Regular Expressions](https://github.com/kkos/oniguruma/blob/master/doc/RE)** - Regex engine reference
- **[TextMate Scope Naming](https://www.sublimetext.com/docs/scope_naming.html)** - Naming conventions

## üìù Contributing to Documentation

Found an error or want to improve the docs?

1. **Small fixes**: Edit the Markdown files directly
2. **New sections**: Follow the existing structure and style
3. **Examples**: Include working code samples
4. **Cross-references**: Link to related sections

The documentation is written in Markdown and should be:
- **Clear and concise** - Get to the point quickly
- **Example-driven** - Show, don't just tell
- **Comprehensive** - Cover edge cases and gotchas
- **Up-to-date** - Reflect the current API

## üìã Document Status

| Document | Status | Last Updated | Covers Version |
|----------|--------|--------------|----------------|
| Getting Started | ‚úÖ Complete | Latest | v2.x |
| Modules Overview | ‚úÖ Complete | Latest | v2.x |
| API Reference | ‚úÖ Complete | Latest | v2.x |
| Scopes Reference | ‚úÖ Complete | Latest | v2.x |
| Using Scopes | ‚úÖ Complete | Latest | v2.x |
| Troubleshooting | ‚úÖ Complete | Latest | v2.x |

---

**Need help?** Start with the [Getting Started Guide](getting-started.md) or jump to the [Troubleshooting Guide](troubleshooting.md) if you're facing specific issues. 

---

## docs/api-reference.md

# API Reference

Complete reference for all public APIs in the TextMate Toolkit.

## Core Factory Functions

### `createGrammar(name, scopeName, fileTypes, patterns, options?)`

Creates a new TextMate grammar.

**Parameters:**
- `name: string` - Human-readable name for the grammar
- `scopeName: string` - Root scope name (e.g., 'source.typescript')
- `fileTypes: string[]` - File extensions this grammar applies to
- `patterns: Rule[]` - Top-level patterns/rules
- `options?: object` - Optional grammar configuration
  - `firstLineMatch?: RegexValue` - Regex to match first line for grammar detection
  - `foldingStartMarker?: RegexValue` - Regex marking start of foldable sections
  - `foldingStopMarker?: RegexValue` - Regex marking end of foldable sections
  - `repositoryItems?: Rule[]` - Explicitly declare all repository rules for reliable processing

**Returns:** `GrammarResult<Grammar>` - Result type requiring error checking

**Example:**
```typescript
const grammar = createGrammar(
  'My Language',
  'source.mylang',
  ['mylang', 'ml'],
  [keywordRule, commentRule],
  {
    firstLineMatch: /^#!/,
    repositoryItems: [keywordRule, commentRule]
  }
);
```

### `createRule(key, definition)`

Creates a rule with automatic type inference.

**Parameters:**
- `key: string` - Unique identifier for the rule
- `definition: RuleDefinition` - Rule pattern definition

**Returns:** `Rule`

## Emission Functions

### `emitJSON(grammar, options?)`

Converts a grammar to JSON format.

**Parameters:**
- `grammar: Grammar` - The grammar to emit
- `options?: EmitOptions` - Optional emission configuration

**Returns:** `Promise<StringResult<string>>` - Result type with potential validation errors

**Options:**
```typescript
interface EmitOptions {
  errorSourceFilePath?: string;  // For better error messages
  validate?: boolean;            // Validate patterns (default: true)
  formatOutput?: boolean;        // Pretty-print JSON (default: true)
}
```

### `emitPlist(grammar, options?)`

Converts a grammar to Plist format.

**Parameters:**
- `grammar: Grammar` - The grammar to emit
- `options?: EmitOptions` - Optional emission configuration

**Returns:** `Promise<StringResult<string>>` - Result type with potential validation errors

### `prepareGrammarForEmit(grammar, options?)`

Processes a grammar for emission without serializing it. This is useful for validating a grammar and then emitting it to multiple formats.

**Parameters:**
- `grammar: Grammar` - The grammar to process
- `options?: EmitOptions` - Optional emission configuration

**Returns:** `Promise<any>` - The processed grammar object

**Example:**
```typescript
const processedGrammar = await prepareGrammarForEmit(myGrammar);
const jsonOutput = JSON.stringify(processedGrammar, null, 2);
const plistOutput = plist.build(processedGrammar);
```

## Rule Types

### `MatchRule`

For simple pattern matching.

```typescript
interface MatchRule {
  key: string;
  match: RegExp | string;
  scope?: string;
  captures?: CaptureMap;
}
```

**Example:**
```typescript
const keywordRule: MatchRule = {
  key: 'keywords',
  match: /\b(if|else|while)\b/,
  scope: 'keyword.control'
};
```

### `BeginEndRule`

For multi-line constructs.

```typescript
interface BeginEndRule {
  key: string;
  begin: RegExp | string;
  end: RegExp | string;
  scope?: string;
  contentScope?: string;
  beginCaptures?: CaptureMap;
  endCaptures?: CaptureMap;
  patterns?: Rule[];
}
```

**Example:**
```typescript
const stringRule: BeginEndRule = {
  key: 'string',
  begin: /"/,
  end: /"/,
  scope: 'string.quoted.double',
  patterns: [escapeRule]
};
```

### `IncludeRule`

For grouping patterns or including other grammars.

```typescript
interface IncludeRule {
  key: string;
  patterns?: Rule[];
  include?: string;
}
```

**Example:**
```typescript
const expressionRule: IncludeRule = {
  key: 'expression',
  patterns: [numberRule, stringRule, identifierRule]
};
```

## Scopes API

### Accessing Scopes

```typescript
import { scopes, scopesFor } from 'tmgrammar-toolkit';

// Recommended: Use scopesFor for language-specific grammars
const langScopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });
const keywordScope = langScopes.keyword;          // "keyword.mylang"
const controlScope = langScopes.keyword.control;  // "keyword.control.mylang"

// Alternative: Global scopes (for dynamic or extensible grammars)
const jsKeyword = scopes.keyword('javascript');   // "keyword.javascript"
const pyControl = scopes.keyword.control('python'); // "keyword.control.python"
```

### Common Scope Categories

#### Keywords
```typescript
scopes.keyword                    // "keyword"
scopes.keyword.control           // "keyword.control"
scopes.keyword.control.conditional // "keyword.control.conditional"
scopes.keyword.operator          // "keyword.operator"
scopes.keyword.operator.assignment // "keyword.operator.assignment"
```

#### Constants
```typescript
scopes.constant                  // "constant"
scopes.constant.numeric         // "constant.numeric"
scopes.constant.numeric.integer // "constant.numeric.integer"
scopes.constant.language        // "constant.language"
scopes.constant.character.escape // "constant.character.escape"
```

#### Entities
```typescript
scopes.entity.name.function     // "entity.name.function"
scopes.entity.name.class        // "entity.name.class"
scopes.entity.name.type         // "entity.name.type"
scopes.entity.other.attribute   // "entity.other.attribute-name"
```

#### Comments
```typescript
scopes.comment.line             // "comment.line"
scopes.comment.line['double-slash'] // "comment.line.double-slash"
scopes.comment.block            // "comment.block"
```

#### Strings
```typescript
scopes.string.quoted.single     // "string.quoted.single"
scopes.string.quoted.double     // "string.quoted.double"
scopes.string.quoted.triple     // "string.quoted.triple"
```

## Regex Helpers

### Basic Helpers

```typescript
import { regex } from 'tmgrammar-toolkit/helpers';

// Word boundaries
regex.bounded('text')            // "\\btext\\b"
regex.wordBoundary               // "\\b"

// Quantifiers
regex.optional('text')           // "(?:text)?"
regex.zeroOrMore('text')         // "(?:text)*"
regex.oneOrMore('text')          // "(?:text)+"

// Grouping
regex.capture('text')            // "(text)"
regex.group('text')              // "(?:text)"
regex.nonCapture('text')         // "(?:text)"

// Escaping
regex.escape('text.with.dots')   // "text\\.with\\.dots"

// Wrapping
regex.wrap('foo', '"')           // "\\"foo\\""

### Pattern Construction

```typescript
// Alternation
regex.oneOf(['if', 'else'])      // "(?:if|else)"
regex.keywords(['if', 'else'])   // "\\b(?:if|else)\\b"

// Lookahead/Lookbehind
regex.before('pattern')          // "(?=pattern)"
regex.notBefore('pattern')       // "(?!pattern)"
regex.after('pattern')           // "(?<=pattern)"
regex.notAfter('pattern')        // "(?<!pattern)"

// Character classes
regex.anyOf('abc')               // "[abc]"
regex.range('a', 'z')            // "[a-z]"
regex.notAnyOf('abc')            // "[^abc]"

// Concatenation
regex.concat('a', /b/, 'c')      // "(?:abc)"
```

## Terminal Patterns

### Comments

```typescript
import { COMMENT } from 'tmgrammar-toolkit/terminals';

COMMENT.SLASHES                  // "//"
COMMENT.HASH                     // "#"
COMMENT.DASHES                   // "--"
COMMENT.PERCENT                  // "%"
COMMENT.BLOCK.START              // "/*"
COMMENT.BLOCK.END                // "*/"
```

### Numbers

```typescript
import { NUM } from 'tmgrammar-toolkit/terminals';

NUM.INT                          // Integer patterns
NUM.FLOAT                        // Float patterns
NUM.DEC                          // Decimal numbers
NUM.HEX                          // Hexadecimal (0xFF)
NUM.BIN                          // Binary (0b1010)
NUM.OCT                          // Octal (0o777)
```

### Identifiers

```typescript
import { ID } from 'tmgrammar-toolkit/terminals';

ID                               // Standard identifier
CAMEL_CASE_ID                    // camelCase
PASCAL_CASE_ID                   // PascalCase
SNAKE_CASE_ID                    // snake_case
CONSTANT_ID                      // ALL_CAPS
KEBAB_CASE_ID                    // kebab-case
```

### Operators

```typescript
import { OP } from 'tmgrammar-toolkit/terminals';

OP.ASSIGNMENT                    // =, +=, -=, etc.
OP.COMPARISON                    // ==, !=, <, >, etc.
OP.ARITHMETIC                    // +, -, *, /, %
OP.LOGICAL                       // &&, ||, !
OP.BITWISE                       // &, |, ^, ~, <<, >>
```

### Character and Marker Patterns

```typescript
import { DOT, WB, EOL, BOL } from 'tmgrammar-toolkit/terminals';

// From terminals/chars.ts
DOT                              // /\./

// From terminals/markers.ts  
WB                               // /\b/ (word boundary)
EOL                              // /$/ (end of line)
BOL                              // /^/ (beginning of line)
```

## Testing API

### Programmatic Testing

```typescript
import { createTesterFromFile, createTesterFromContent } from 'tmgrammar-toolkit/testing';

// From grammar file
const tester = createTesterFromFile('./grammar.json', 'source.mylang');

// From grammar object
const tester = createTesterFromContent(grammarObject, 'source.mylang');

// Tokenize code
const tokens = await tester.tokenize('if (true) { }');

// Expectations
tester.expectTokenScope(tokens, 'if', 'keyword.control');
tester.expectTokenContent(tokens, 1, '(');
tester.expectTokenLength(tokens, 5);
```

### Declarative Testing

**Note:** The correct function names are `declarativeTest` and `snapshot`.

```typescript
import { declarativeTest, snapshot } from 'tmgrammar-toolkit/testing';

// Run tests with embedded scope assertions
await declarativeTest('./tests/**/*.test.mylang', {
  grammar: './grammar.json',
  compact: true
});

// Snapshot testing
await snapshot('./tests/**/*.mylang', {
  grammar: './grammar.json',
  updateSnapshots: false
});
```

## Validation API

### Pattern Validation

```typescript
import { validateRegex, validateRegexPatterns } from 'tmgrammar-toolkit/validation';

// Single pattern
const result = await validateRegex('\\b(if|else)\\b');
if (!result.valid) {
  console.error(result.error);
}

// Multiple patterns
const results = await validateRegexPatterns([
  '\\b(if|else)\\b',
  '[a-zA-Z_]\\w*'
]);
```

### Grammar Validation

```typescript
import { validateGrammar, validateScopeName } from 'tmgrammar-toolkit/validation';

// Grammar structure
const grammarResult = validateGrammar(myGrammar);

// Scope names
const scopeResult = validateScopeName('keyword.control.conditional');
```

## CLI Commands

### Grammar Emission

```bash
# Basic emission to JSON
tmt emit grammar.ts -o output.json

# Specific export
tmt emit grammar.ts myGrammarExport

# The CLI currently only supports JSON output.
# For other formats like Plist, use the programmatic API.
```

### Testing

```bash
# Declarative tests
tmt test 'tests/**/*.test.mylang'
tmt test 'tests/**/*.test.mylang' -g grammar.json --compact

# Snapshot tests  
tmt snap 'tests/**/*.mylang'
tmt snap 'tests/**/*.mylang' --update
```

### Validation

```bash
# Validate grammar files
tmt validate grammar.json
tmt validate grammar.ts
tmt validate grammar.ts specificExport
```

## Type Definitions

### Core Types

```typescript
interface Grammar {
  name: string;
  scopeName: string;
  fileTypes: string[];
  patterns: Rule[];
  repository?: Record<string, Rule>;
  foldingStartMarker?: string;
  foldingStopMarker?: string;
  firstLineMatch?: string;
  injections?: Record<string, Rule>;
}

type Rule = MatchRule | BeginEndRule | IncludeRule;

interface CaptureMap {
  [key: string]: {
    name?: string;
    patterns?: Rule[];
  };
}
```

### Emission Types

```typescript
interface EmitOptions {
  errorSourceFilePath?: string;
  validate?: boolean;
  formatOutput?: boolean;
}

interface ValidationResult {
  valid: boolean;
  error?: string;
  warnings?: string[];
}
```

### Testing Types

```typescript
interface Token {
  content: string;
  scope: string[];
  startIndex: number;
  endIndex: number;
}

interface TestOptions {
  grammar?: string;
  compact?: boolean;
  updateSnapshots?: boolean;
}
``` 

---

## docs/getting-started.md

# Getting Started

Welcome to the TextMate Toolkit! This guide will walk you through creating your first grammar and understanding the core concepts.

## Prerequisites

- **Bun (highly recommended)** or Node.js 18+
- TypeScript knowledge
- Basic understanding of regular expressions
- Familiarity with syntax highlighting concepts

**Why Bun?** The toolkit leverages Bun's seamless TypeScript integration to let you work directly with `.ts` grammar files without a separate build step. This dramatically improves the development experience.

## Installation

```bash
# Using Bun (recommended)
bun add tmgrammar-toolkit

# Using npm
npm install tmgrammar-toolkit

# Using yarn
yarn add tmgrammar-toolkit
```

## Your First Grammar

Let's create a simple grammar for a fictional language called "MyLang". We'll add support for keywords, comments, and strings.

### Step 1: Create the Grammar File

Create a new file `mylang-grammar.ts`:

```typescript
import { createGrammar, scopesFor, regex } from 'tmgrammar-toolkit';
import { COMMENT } from 'tmgrammar-toolkit/terminals';
import type { MatchRule, BeginEndRule } from 'tmgrammar-toolkit';

// Create static scopes for performance (recommended)
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });

// Define keywords rule
const keywordRule: MatchRule = {
  key: 'keywords',
  match: regex.keywords(['if', 'else', 'while', 'for', 'function', 'return']),
  scope: scopes.keyword.control
};

// Define line comment rule
const lineCommentRule: MatchRule = {
  key: 'line-comment',
  match: regex.concat(COMMENT.SLASHES, /.*$/),
  scope: scopes.comment.line.double_slash
};

// Define string rule with escape sequences
const stringRule: BeginEndRule = {
  key: 'string',
  begin: /"/,
  end: /"/,
  scope: scopes.string.quoted.double,
  patterns: [
    {
      key: 'string-escape',
      match: /\\./,
      scope: scopes.constant.character.escape
    }
  ]
};

// Create the complete grammar
export const myLangGrammar = createGrammar(
  'MyLang',              // Human-readable name
  'source.mylang',       // Root scope identifier
  ['mylang', 'ml'],      // File extensions
  [                      // Top-level patterns
    keywordRule,
    lineCommentRule,
    stringRule
  ]
);
```

### Step 2: Generate the Grammar File

Now generate the actual TextMate grammar file. With Bun, you can work directly with TypeScript:

```bash
# Using the CLI with Bun (works directly with .ts files!)
bunx tmt emit mylang-grammar.ts -o mylang.tmLanguage.json

# Or with npx
npx tmt emit mylang-grammar.ts -o mylang.tmLanguage.json
```

Or programmatically:

```typescript
import { emitJSON, isError } from 'tmgrammar-toolkit';
import { myLangGrammar } from './mylang-grammar.js';
import { writeFile } from 'node:fs/promises';

// emitJSON accepts a Result and handles the unwrapping
const result = await emitJSON(myLangGrammar);
if (isError(result)) {
  console.error('Grammar validation failed:', result.error);
  process.exit(1);
}

await writeFile('mylang.tmLanguage.json', result.value);
```

### Step 3: Test Your Grammar

Create a test file to verify your grammar works. The CLI provides a handy test runner:

```bash
# Create a test file with assertions
# See the testing documentation for more details
# tests/mylang.test.lang

# Run the test command
bunx tmt test 'tests/**/*.test.lang' -g mylang.tmLanguage.json
```

Or test programmatically:

```typescript
// mylang-test.ts
import { createTesterFromContent } from 'tmgrammar-toolkit/testing';
import { myLangGrammar } from './mylang-grammar.js';

const tester = createTesterFromContent(myLangGrammar, 'source.mylang');

// Test code sample
const code = `
if (condition) {
  // This is a comment
  return "Hello, world!";
}
`;

const tokens = await tester.tokenize(code);

// Verify token scopes
tester.expectTokenScope(tokens, 'if', 'keyword.control.mylang');
tester.expectTokenScope(tokens, '//', 'comment.line.double-slash.mylang');
tester.expectTokenScope(tokens, 'Hello, world!', 'string.quoted.double.mylang');

console.log('All tests passed!');
```

## Core Concepts

### Rules Are Everything

In TextMate grammars, everything is a **Rule**. There are three types:

1. **MatchRule** - For simple patterns
2. **BeginEndRule** - For multi-line constructs  
3. **IncludeRule** - For grouping patterns

```typescript
// Simple pattern matching
const numberRule: MatchRule = {
  key: 'numbers',
  match: /\d+(\.\d+)?/,
  scope: scopes.constant.numeric
};

// Multi-line constructs
const blockCommentRule: BeginEndRule = {
  key: 'block-comment',
  begin: /\/\*/,
  end: /\*\//,
  scope: scopes.comment.block
};

// Grouping patterns
const expressionRule: IncludeRule = {
  key: 'expression',
  patterns: [numberRule, stringRule, identifierRule]
};
```

### Scopes Define Meaning

Scopes tell editors how to highlight and understand your code. Use our type-safe scopes API:

```typescript
// Create scopes for your language
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });

// Use the type-safe scope properties
scope: scopes.keyword.control.conditional  // "keyword.control.conditional.mylang"
```

Common scope patterns:
- `keyword.*` - Language keywords
- `string.*` - String literals
- `comment.*` - Comments
- `constant.*` - Constants and literals
- `entity.name.*` - Names of functions, classes, etc.

### Automatic Repository Management

**This is a major convenience feature**: The toolkit automatically collects rules with a `key` property and places them into the grammar's repository during emission. You don't need to manually manage the repository structure!

```typescript
const keywordRule = { key: 'keywords', /* ... */ };
const stringRule = { key: 'strings', /* ... */ };
// No duplicate keys allowed - the emit system catches this

// For explicit control, use repositoryItems:
export const myLangGrammar = createGrammar(
  'My Language',
  'source.mylang',
  ['mylang'],
  [keywordRule, stringRule],
  {
    repositoryItems: [keywordRule, stringRule], // Explicitly declare all rules
    firstLineMatch: /^#!/
  }
);
```

**Why this matters**: Traditional TextMate grammar development requires manually managing a complex repository structure. Our system eliminates this source of errors and makes grammars much more maintainable.

## Adding More Features

### Numbers with Multiple Formats

```typescript
import { NUM } from 'tmgrammar-toolkit/terminals';

const numberRule: MatchRule = {
  key: 'numbers',
  match: regex.oneOf([
    NUM.DEC,    // Decimal: 123, 123.45, 1.23e-4
    NUM.HEX,    // Hexadecimal: 0xFF, 0xABCD  
    NUM.BIN,    // Binary: 0b1010
    NUM.OCT     // Octal: 0o777
  ]),
  scope: scopes.constant.numeric
};
```

### Function Declarations with Parameters

```typescript
const functionDeclaration: BeginEndRule = {
  key: 'function-declaration',
  scope: scopes.meta.function,
  begin: regex.concat(
    /(function)\s+/,     // function keyword
    regex.capture(ID),   // function name
    /\s*(\()/           // opening parenthesis
  ),
  beginCaptures: {
    '1': { scope: scopes.keyword.declaration.function },
    '2': { scope: scopes.entity.name.function },
    '3': { scope: scopes.punctuation.section.parens.begin }
  },
  end: /\)/,
  endCaptures: {
    '0': { scope: scopes.punctuation.section.parens.end }
  },
  patterns: [
    {
      key: 'parameter',
      scope: scopes.variable.parameter,
      match: ID
    },
    {
      key: 'parameter-separator',
      scope: scopes.punctuation.separator.comma,
      match: /,/
    }
  ]
};
```

### Block Comments with Nesting

```typescript
const blockComment: BeginEndRule = {
  key: 'block-comment',
  scope: scopes.comment.block,
  begin: /\/\*/,
  end: /\*\//,
  patterns: [
    // Nested block comments
    { include: '#block-comment' }
  ]
};
```

## Scope System Deep Dive

### Static vs Callable Scopes

```typescript
// Static scopes (recommended for production)
const staticScopes = scopesFor({ suffix: 'lang', allowScopeExtension: false });
console.log(staticScopes.keyword.control.conditional);  // "keyword.control.conditional.lang"

// Callable scopes (for extensible grammars)
const callableScopes = scopesFor({ suffix: 'lang', allowScopeExtension: true });
console.log(callableScopes.keyword.control.conditional('async'));  // "keyword.control.conditional.lang.async"
```

### Custom Scope Definitions

```typescript
const customScopes = scopesFor({ 
  suffix: 'mylang', 
  allowScopeExtension: false 
}, {
  // Add language-specific custom scopes
  meta: {
    section: {
      header: null,
      body: null
    }
  }
});

// Use your custom scopes
scope: customScopes.meta.section.header  // "meta.section.header.mylang"
```

## Testing Your Grammar

### Basic Testing

```typescript
import { createTesterFromContent } from 'tmgrammar-toolkit/testing';

const tester = createTesterFromContent(myGrammar, 'source.mylang');
const tokens = await tester.tokenize('if (true) { }');

// Check individual tokens
tester.expectTokenScope(tokens, 'if', 'keyword.control.mylang');
tester.expectTokenScope(tokens, 'true', 'constant.language.mylang');
```

### Advanced Testing

```typescript
// Test multi-line constructs
const multiLineCode = `
function hello() {
  /* block comment */
  return "world";
}
`;

const tokens = await tester.tokenize(multiLineCode);

// Test scope hierarchy
tester.expectScopeAtPosition(tokens, { line: 1, character: 0 }, [
  'source.mylang',
  'meta.function.mylang',
  'keyword.declaration.function.mylang'
]);

// Test that comments don't interfere with function scope
tester.expectTokenScope(tokens, 'return', 'keyword.control.mylang');
```

## Common Patterns

### Keywords with Boundaries

```typescript
// Always use word boundaries for keywords
const keywords: MatchRule = {
  key: 'keywords',
  match: regex.keywords(['class', 'interface', 'extends']),  // Automatically adds \b boundaries
  scope: scopes.keyword.declaration
};
```

### Identifiers vs Function Calls

```typescript
// Regular identifiers
const identifier: MatchRule = {
  key: 'identifier',
  match: regex.concat(ID, regex.notBefore(/\s*\(/)),  // Not followed by opening paren
  scope: scopes.variable.other.readwrite
};

// Function calls
const functionCall: MatchRule = {
  key: 'function-call',
  match: regex.concat(ID, regex.before(/\s*\(/)),    // Followed by opening paren
  scope: scopes.entity.name.function
};
```

### String Interpolation

```typescript
const templateLiteral: BeginEndRule = {
  key: 'template-literal',
  scope: scopes.string.template,
  begin: /`/,
  end: /`/,
  patterns: [
    {
      key: 'template-expression',
      scope: scopes.meta.interpolation,
      begin: /\$\{/,
      end: /\}/,
      patterns: [
        // Include all expressions here
        { include: '#expression' }
      ]
    }
  ]
};
```

## Development Workflow with Bun

The toolkit is designed for rapid iteration. Here's the recommended workflow:

```bash
# 1. Create your grammar in TypeScript
code my-grammar.ts

# 2. Generate and validate in one step
bunx tmt emit my-grammar.ts --validate -o grammar.json

# 3. Test with real code samples
bunx tmt test 'tests/**/*.test' -g grammar.json

# 4. Iterate quickly - no build step needed!
```

**Key Benefits:**
- **No Build Step**: Work directly with TypeScript files
- **Instant Feedback**: CLI commands work immediately
- **Type Safety**: Catch errors at development time
- **Rich Testing**: Comprehensive testing APIs

## Key Concepts Recap

1. **Automatic Repository**: Rules with `key` properties are automatically managed
2. **Type-Safe Scopes**: Use `scopesFor()` to avoid scope name typos
3. **Rich Terminals**: Pre-built patterns for common language constructs
4. **Validation**: Built-in regex and grammar validation using VS Code's engine
5. **Testing First**: Comprehensive testing APIs for reliable grammars

## Next Steps

1. **Study the Examples**: Check out the complete examples in the toolkit:
   - [Simple Example](../examples/simple-example.ts) - Educational with best practices
   - [Bicep Example](../examples/tmgrammar-toolkit/bicep.ts) - Real-world language
   - [TypeSpec Example](../examples/tmgrammar-toolkit/typespec.ts) - Complex features

2. **Read the Guides**:
   - [Modules Overview](modules-overview.md) - Understand the architecture
   - [Using Scopes](using-scopes.md) - Master the scope system
   - [API Reference](api-reference.md) - Complete function reference
   - [Troubleshooting](troubleshooting.md) - Common issues and solutions

3. **Test Everything**: Use the testing framework to ensure your grammar works correctly

4. **Performance**: Use static scopes for production grammars for better performance

Happy grammar building! üéâ 

---

## docs/modules-overview.md

# TextMate Toolkit: Complete Guide

You know that feeling when you're staring at a 500-line JSON file full of regex patterns, wondering if there's a better way to build TextMate grammars? We've been there too. After building several language grammars and watching our team struggle with the same repetitive patterns, we created this toolkit to make the whole process more... human.

## What This Toolkit Actually Solves

TextMate grammars are powerful, but writing them by hand is like performing surgery with oven mitts. You're dealing with:

- **Regex soup**: Hundreds of patterns scattered across a massive JSON file
- **Scope name typos**: One wrong character and your highlighting breaks
- **Repository chaos**: Managing references between patterns without going insane  
- **Testing nightmares**: "Did my change break something? Let me manually check 47 test cases..."
- **Copy-paste hell**: The same patterns showing up in every grammar you write

We built this toolkit because we got tired of reinventing the wheel every time we needed to tokenize a new language.

## The Mental Model

Think of building a TextMate grammar like constructing a building:

1. **Foundation** (`types.ts`): The architectural blueprints - strict TypeScript definitions that map exactly to the tmlanguage spec
2. **Building Blocks** (`terminals/`, `helpers/`): Pre-fabricated components - common patterns you'll use everywhere
3. **Assembly Tools** (`factory.ts`, `scopes.ts`): The construction equipment - clean APIs for putting pieces together
4. **Quality Control** (`validation/`): The inspectors - making sure your regex actually works
5. **Final Output** (`emit.ts`): The general contractor - converts your readable code into the JSON that VS Code expects
6. **Testing Suite** (`testing/`): The stress tests - make sure everything works before you ship

## Core Architecture: How It All Fits Together

### The Rule System

Everything in a TextMate grammar is a **Rule**. We've designed our type system around this concept:

```typescript
// Every rule needs a unique key for the repository
interface RuleKey {
  key: string;
}

// Three main rule types:
type Rule = MatchRule | BeginEndRule | IncludeRule;
```

The beauty here is that you define rules using clean TypeScript objects, and our emit system handles all the gnarly repository management behind the scenes.

### Scope Management 

Instead of typing `"keyword.control.conditional"` everywhere and inevitably fat-fingering it, we built a type-safe scopes API:

```typescript
import { scopesFor } from 'tmgrammar-toolkit';

// Create type-safe scopes for your language (recommended)
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });

// This gives you autocomplete and catches typos at compile time
const conditionalScope = scopes.keyword.control.conditional;  // "keyword.control.conditional.mylang"
```

### Automatic Repository Management 

**This is the killer feature**: TextMate grammars use a "repository" to organize patterns, but managing it manually is a nightmare. You end up with duplicate keys, circular references, and patterns that reference things that don't exist.

Our emit system solves this by:
- **Automatically collecting rules** with a `key` property during emission
- **Detecting duplicate keys** and throwing clear errors with helpful context
- **Converting rule objects** into the messy JSON format VS Code expects
- **Supporting explicit control** via the `repositoryItems` array when needed

```typescript
// Rules are automatically collected into the repository
const keywordRule = { key: 'keywords', match: /\b(if|else)\b/, scope: 'keyword.control' };
const stringRule = { key: 'strings', begin: /"/, end: /"/, scope: 'string.quoted.double' };

// The emit system builds this repository automatically:
// {
//   "repository": {
//     "keywords": { "match": "\\b(if|else)\\b", "name": "keyword.control" },
//     "strings": { "begin": "\"", "end": "\"", "name": "string.quoted.double" }
//   }
// }
```

### The `meta` Symbol System

The special `meta` symbol gets expanded to `meta.<rule_key>.<grammar_name>` during emission, providing structural scopes without boilerplate:

```typescript
import { meta } from 'tmgrammar-toolkit';

const functionRule: BeginEndRule = {
  key: 'function-declaration',
  scope: meta,  // Expands to "meta.function-declaration.mylang"
  begin: /function\s+(\w+)/,
  // ...
};
```

This creates consistent, meaningful meta scopes that help editors understand code structure.

## Module Deep Dive

### `/helpers` - Regex Construction Kit

When you're building regex patterns, you end up writing the same utility functions over and over. We collected all the common ones:

```typescript
import { regex } from 'tmgrammar-toolkit/helpers';

// Instead of: "\\b(if|else|while)\\b"
const keywords = regex.keywords(['if', 'else', 'while']);

// Instead of: "(?=\\()"  
const beforeParen = regex.before('\\(');

// Instead of manually escaping: "test\\.file\\.name"
const escaped = regex.escape('test.file.name');
```

**Why we built this**: After the fourth time someone wrote a buggy `oneOf` function, we realized this should just be a library.

The helpers include:
- `bounded()` - Word boundaries around text
- `before()`, `notBefore()` - Positive/negative lookahead
- `after()`, `notAfter()` - Positive/negative lookbehind  
- `oneOf()` - Alternation from arrays
- `keywords()` - Word-bounded alternation
- `escape()` - Proper regex escaping
- `optional()`, `zeroOrMore()`, `oneOrMore()` - Quantifiers
- `capture()`, `group()` - Grouping utilities

### `/terminals` - The Pattern Library

Every programming language has the same basic building blocks. Instead of reinventing these patterns for each grammar, we've collected the most common ones:

#### Comments (`/terminals/comments.ts`)
```typescript
import { COMMENT } from 'tmgrammar-toolkit/terminals';

// Line comments: //
COMMENT.SLASHES

// Block comments: /* */
COMMENT.BLOCK.START
COMMENT.BLOCK.END
```

#### Numbers (`/terminals/numbers.ts`)
```typescript
import { NUM } from 'tmgrammar-toolkit/terminals';

// Covers decimal, hex, binary, octal with proper edge cases
NUM.DEC   // 123, 123.45, 1.23e-4, 123n
NUM.HEX   // 0xFF, 0xABCD_1234
NUM.BIN   // 0b1010_1111
NUM.OCT   // 0o777
NUM.INT   // Simple integers
NUM.FLOAT // Simple floats with scientific notation
```

#### Identifiers (`/terminals/identifiers.ts`)
Different languages have different identifier conventions:
```typescript
ID                // Standard: [a-zA-Z_][a-zA-Z0-9_]*
CAMEL_CASE_ID     // camelCase
PASCAL_CASE_ID    // PascalCase  
SNAKE_CASE_ID     // snake_case
CONSTANT_ID       // ALL_CAPS
KEBAB_CASE_ID     // kebab-case
```

#### And More...
- **Operators**: Assignment, comparison, logical, arithmetic operators
- **Strings**: Escape sequences, quote patterns
- **Whitespace**: Required/optional spaces, tabs, newlines
- **Markers**: Word boundaries, line start/end

**The philosophy**: If you find yourself writing the same regex pattern in multiple grammars, it probably belongs in terminals.

### `/validation` - Catching Problems Early

Nothing's worse than spending an hour debugging a grammar only to find out you had a typo in a regex pattern. Our validation system catches these issues before they become problems.

#### Regex Validation (`/validation/regex.ts`)
```typescript
import { validateRegex, validateRegexPatterns } from 'tmgrammar-toolkit/validation';

// Test a single pattern
const result = await validateRegex('\\b(if|else)\\b');
if (!result.valid) {
  console.log(`Bad regex: ${result.error}`);
}

// Test multiple patterns at once
const results = await validateRegexPatterns([
  '\\b(if|else)\\b',
  '[invalid[regex',
  '(?<=start)content(?=end)'
]);
```

**This uses the actual Oniguruma engine that VS Code uses**, so you're testing against the real thing. This catches regex issues that would only surface when your grammar is loaded in an editor, saving hours of debugging.

#### Scope Validation (`/validation/scope.ts`)
```typescript
import { validateScopeName } from 'tmgrammar-toolkit/validation';

const result = validateScopeName('keyword.control.conditional');
// Checks for:
// - Valid characters (letters, numbers, dots, hyphens)
// - Proper structure (no empty parts, no consecutive dots)
// - Common root scopes
// - TextMate conventions
```

#### Grammar Validation (`/validation/grammar.ts`)
Basic structural validation for your complete grammar:
```typescript
import { validateGrammar } from 'tmgrammar-toolkit/validation';

const result = validateGrammar(myGrammar);
// Checks for required fields, proper types, common issues
```

### `/testing` - Making Sure It Actually Works

We learned the hard way that a grammar that "looks right" and a grammar that "works right" are different things. The testing module gives you tools to actually verify your patterns work.

#### Programmatic Testing (`/testing/programmatic.ts`)

This is your bread and butter for unit testing individual patterns:

```typescript
import { createTesterFromFile } from 'tmgrammar-toolkit/testing';

const tester = createTesterFromFile('./my-grammar.json', 'source.mylang');

// Test tokenization
const tokens = await tester.tokenize('if (condition) { }');

// Verify specific tokens have expected scopes
tester.expectTokenScope(tokens, 'if', 'keyword.control.conditional');
tester.expectTokenScope(tokens, '(', 'punctuation.section.parens');
```

**Why this matters**: We once spent three days debugging why function calls weren't highlighting properly, only to discover our `(` pattern was being matched by the wrong rule. Programmatic testing catches this stuff immediately.

#### Declarative Testing (`/testing/helpers.ts`)

For integration testing, we support the vscode-tmgrammar-test format:

```typescript
import { declarativeTest, snapshot } from 'tmgrammar-toolkit/testing';

// Run tests with embedded scope assertions
declarativeTest('./tests/**/*.test.mylang', {
  grammar: './grammars/mylang.json',
  compact: true
});

// Generate/compare snapshots
snapshot('./tests/**/*.test.mylang', {
  updateSnapshots: true
});
```

This lets you write test files like:
```
if (true) {
// <- keyword.control.conditional
//   ^ constant.language.boolean
}
```

## The Complete Workflow

Here's how we typically build a grammar with this toolkit:

### 1. Start with Types and Structure

```typescript
import { createGrammar, scopes, regex } from 'tmgrammar-toolkit';

const myGrammar = createGrammar(
  'MyLanguage',           // Display name
  'source.mylang',        // Scope name  
  ['mylang', 'ml'],       // File extensions
  [                       // Top-level patterns
    keywordRule,
    commentRule,
    stringRule
  ]
);
```

### 2. Build Rules with Helpers and Terminals

```typescript
import { COMMENT, NUM, ID } from 'tmgrammar-toolkit/terminals';
import { regex } from 'tmgrammar-toolkit/helpers';

const keywordRule: MatchRule = {
  key: 'keywords',
  match: regex.keywords(['if', 'else', 'while', 'for']),
  scope: scopes.keyword.control
};

const numberRule: MatchRule = {
  key: 'numbers', 
  match: NUM.DEC,
  scope: scopes.constant.numeric
};
```

### 3. Validate as You Go

```typescript
import { validateRegex } from 'tmgrammar-toolkit/validation';

// Check your patterns before using them
const regexResult = await validateRegex(regex.keywords(['if', 'else']));
if (!regexResult.valid) {
  throw new Error(`Invalid regex: ${regexResult.error}`);
}
```

### 4. Test Your Patterns

```typescript
import { createTesterFromContent } from 'tmgrammar-toolkit/testing';

const tester = createTesterFromContent(myGrammar, 'source.mylang');
const tokens = await tester.tokenize('if (true) { return 42; }');

// Verify each token gets the right scope
tester.expectTokenScope(tokens, 'if', 'keyword.control');
tester.expectTokenScope(tokens, 'true', 'constant.language.boolean');
tester.expectTokenScope(tokens, '42', 'constant.numeric');
```

### 5. Generate the Final Grammar

```typescript
import { emitJSON } from 'tmgrammar-toolkit';

const grammarJSON = await emitJSON(myGrammar, {
  errorSourceFilePath: './my-grammar.ts' // For better error messages
});

// Write to .tmLanguage.json file
await writeFile('./grammars/mylang.tmLanguage.json', grammarJSON);
```

## Real-World Patterns

### Complex Begin/End Rules

For multi-line constructs like strings or comments:

```typescript
const multiLineStringRule: BeginEndRule = {
  key: 'multiline-string',
  scope: scopes.string.quoted.triple,
  begin: /"""/,
  end: /"""/,
  patterns: [
    {
      key: 'string-escape',
      match: COMMON_ESCAPE,
      scope: scopes.constant.character.escape
    }
  ]
};
```

### Embedded Languages

For things like SQL in Python strings or CSS in HTML:

```typescript
const sqlStringRule: BeginEndRule = {
  key: 'sql-string',
  scope: scopes.string.quoted.double,
  begin: regex.after('sql\\s*=\\s*')/"/,
  end: /"/,
  patterns: [
    {
      key: 'embedded-sql',
      include: 'source.sql' // Reference external grammar
    }
  ]
};
```

## Common Gotchas We've Learned

### Repository Key Conflicts
Every rule needs a unique key. We've seen this pattern too many times:
```typescript
// ‚ùå Both rules have the same key
const stringRule1 = { key: 'string', match: /"[^"]*"/, scope: 'string.quoted.double' };
const stringRule2 = { key: 'string', match: /'[^']*'/, scope: 'string.quoted.single' };
```

The emit system will catch this and throw a clear error.

### Regex Escaping
JavaScript strings and regex have different escaping rules:
```typescript
// ‚ùå Wrong - not enough escaping
match: "\b(function)\b"

// ‚úÖ Right - proper escaping  
match: "\\b(function)\\b"

// ‚úÖ Even better - use our helpers
match: regex.bounded('function')
```

### Scope Ordering
More specific scopes should come before general ones:
```typescript
patterns: [
  functionDeclarationRule,  // matches "function foo()"
  keywordRule              // matches "function" 
]
```

## Performance Tips

### Use Atomic Groups
For performance, use atomic groups when you don't need backtracking:
```typescript
// Instead of: (if|else|while)+
// Use: (?>if|else|while)+
```

### Limit Lookahead/Lookbehind
These are expensive operations. Use sparingly:
```typescript
// ‚ùå Expensive
match: /(?<=\w)\.(?=\w)/

// ‚úÖ Often faster
match: /\w\.\w/
```

### Profile Your Grammar
Use the testing tools to identify slow patterns:
```typescript
const start = performance.now();
const tokens = await tester.tokenize(largeCodeSample);
const time = performance.now() - start;
console.log(`Tokenized ${largeCodeSample.length} chars in ${time}ms`);
```

## What's Next?

This toolkit is designed to grow with your needs. We're constantly adding new terminals and helpers based on patterns we see across different grammars. 

If you find yourself writing the same pattern multiple times, consider contributing it back to the terminals library. And if you run into edge cases our validation doesn't catch, let us know - we want this toolkit to save you from the same mistakes we made.

## CLI Architecture

The `tmt` CLI is designed for a seamless development experience, especially when working with TypeScript.

### Key Features

- **Modular Design**: The CLI is architected with a clear separation of concerns, with each command residing in its own module under `src/cli/commands`. This makes the CLI easy to maintain and extend.
- **Direct TypeScript Execution**: Powered by Bun, the CLI can execute `.ts` grammar files directly, eliminating the need for a separate build step.
- **Automatic Runtimes**: It gracefully falls back to Node.js for `.js` files, so you can use the toolkit in any JavaScript environment.
- **Smart Grammar Loading**: The CLI automatically detects and loads the correct grammar export from a file, whether it's a default export, a named `grammar` export, or another named export you specify.

### Workflow Example

The refactored CLI streamlines the grammar development workflow:

1. **Write your grammar** in a TypeScript file (`my-grammar.ts`).
2. **Generate the grammar file** directly from the source:
   ```bash
   bunx tmt emit my-grammar.ts -o mylang.tmLanguage.json
   ```
3. **Run tests** against your source file or the generated grammar:
   ```bash
   bunx tmt test 'tests/**/*.test.lang' -g mylang.tmLanguage.json
   ```
4. **Iterate quickly**. Since there's no build step, you can make changes and re-run commands instantly.

This architecture is designed to reduce friction and keep you focused on what matters: building a high-quality grammar. 

---

## docs/textmate-scopes.md

# TextMate Scope Naming Conventions

A practical guide to scope naming for tmLanguage files. This covers the conventions used by TextMate, Sublime Text, VS Code, and other editors that support TextMate grammars.

## Understanding Scopes

Scopes are hierarchical, dot-separated strings that identify code elements. They flow from general to specific, enabling powerful contextual features such as syntax highlighting, intelligent code completion, and context-aware key bindings.

**Example breakdown:**
~~~
keyword.control.conditional.php
‚îÇ       ‚îÇ       ‚îÇ           ‚îÇ
‚îÇ       ‚îÇ       ‚îÇ           ‚îî‚îÄ‚îÄ Language
‚îÇ       ‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Specific keyword type
‚îÇ       ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Category of control
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ Root scope
~~~

This hierarchy enables **cascading styles** ‚Äì if a theme doesn't define `keyword.control.conditional.php`, it falls back to `keyword.control.conditional`, then `keyword.control`, and finally to `keyword`.

**Key principles:**
- Always end with the language name (e.g., `.python`, `.javascript`)
- Reuse existing sub-types rather than inventing new ones
- Choose scopes based on meaning, not just appearance
- Spread elements across different root categories for better theme support

## Scope Categories

### `comment`

Comments are non-executable text. Use specific variants for better tooling support.

- `comment.line` - Single-line comments
  - `double-slash` - `// comment`
  - `double-dash` - `-- comment`  
  - `number-sign` - `# comment`
  - `percentage` - `% comment`
- `comment.block` - Multi-line comments
  - `documentation` - JSDoc, PHPDoc, etc.

Apply `punctuation.definition.comment` to comment delimiters (`//`, `/*`, `*/`). Use `meta.toc-list` for section headers that should appear in symbol lists.

### `constant`

Fixed values including literals, language constants, and escape sequences. Distinguish between user-defined constants (`entity.name.constant`) and literal values.

- `constant.numeric` - All numeric literals
  - `integer` - Integer values
    - `binary` - Binary integers (`0b1010`)
    - `octal` - Octal integers (`0o777`)
    - `decimal` - Decimal integers (`42`)
    - `hexadecimal` - Hex integers (`0xFF`)
    - `other` - Other integer formats
  - `float` - Floating-point values
    - `binary` - Binary floats
    - `octal` - Octal floats
    - `decimal` - Decimal floats (`3.14`)
    - `hexadecimal` - Hex floats (`0x1.5p3`)
    - `other` - Other float formats
  - `complex` - Complex numbers
    - `real` - Real part
    - `imaginary` - Imaginary part
- `constant.character.escape` - Escape sequences (`\\n`, `\\t`, `\\u0041`)
- `constant.language` - Built-in constants (`true`, `false`, `nil`, `undefined`)
- `constant.other.placeholder` - Format placeholders (`%s`, `{0}`)
- `constant.other` - Other constants (CSS colors, symbols)

### `entity`

Names of data structures, types, and uniquely-identifiable constructs. **Avoid** `entity.name.type.class` and `entity.name.type.struct` - use specific terminology instead.

The entity scopes target the **names** only, not entire constructs (use `meta.*` for that). Notable exceptions are `entity.name.tag` and `entity.other.attribute-name` for HTML/XML.

- `entity.name.class` - Class names
- `entity.name.struct` - Struct names  
- `entity.name.enum` - Enumeration names
- `entity.name.union` - Union names
- `entity.name.trait` - Trait names
- `entity.name.interface` - Interface names
- `entity.name.impl` - Implementation names
- `entity.name.type` - Generic type names
- `entity.name.function` - Function names (when defined)
  - `constructor` - Constructor names
  - `destructor` - Destructor names
- `entity.name.namespace` - Namespace/module/package names
- `entity.name.constant` - Named constants (vs `variable.other.constant`)
- `entity.name.label` - Labels for goto statements
- `entity.name.section` - Section/heading names in markup
- `entity.name.tag` - HTML/XML tag names (only `entity.name` scope applied to repeated constructs)
- `entity.other.inherited-class` - Superclass/baseclass names
- `entity.other.attribute-name` - HTML/XML attribute names

**Forward declarations:** Use `.forward-decl` variants (e.g., `entity.name.class.forward-decl`) to exclude from symbol lists and indexing.

### `invalid`

Invalid or deprecated code. Use sparingly to avoid unpleasant highlighting.

- `invalid.illegal` - Syntax errors, illegal characters
- `invalid.deprecated` - Deprecated features (use very rarely)

### `keyword`

Reserved words and operators with special language meaning.

- `keyword.control` - Control flow keywords
  - `conditional` - Conditional keywords (`if`, `else`)
  - `import` - Import/include keywords
- `keyword.operator` - Operators
  - `assignment` - Assignment operators
  - `arithmetic` - Math operators
  - `bitwise` - Bitwise operators
  - `logical` - Logical operators
  - `word` - Word operators (`and`, `or`, `not`)
- `keyword.declaration` - Declaration keywords (see `storage` section for combined usage)
  - `function` - Function declaration keywords
  - `class` - Class declaration keywords
  - `struct` - Struct declaration keywords
  - `enum` - Enum declaration keywords
  - `union` - Union declaration keywords
  - `trait` - Trait declaration keywords
  - `interface` - Interface declaration keywords
  - `impl` - Implementation declaration keywords
  - `type` - Type declaration keywords
- `keyword.other` - Other keywords

Apply `punctuation.definition.keyword` to punctuation within keywords (e.g., `@` in CSS).

### `markup`

Content markup in documentation and markup languages. Use for content formatting, not code syntax.

- `markup.heading` - Section headings
- `markup.list.unnumbered` - Bullet lists
- `markup.list.numbered` - Numbered lists
- `markup.bold` - Bold text
- `markup.italic` - Italic text
- `markup.underline` - Underlined text
  - `link` - Links (inherits underline styling)
- `markup.inserted` - Inserted content (diff)
- `markup.deleted` - Deleted content (diff)
- `markup.quote` - Blockquotes
- `markup.raw.inline` - Inline code
- `markup.raw.block` - Code blocks (disables spell checking)
- `markup.other` - Other markup constructs

### `meta`

Structural sections for larger code constructs. **Not intended for styling** - used by preferences and plugins for contextual behavior.

**Critical:** Never stack meta scopes of the same type. For example, `meta.function.php meta.function.parameters.php` should never occur - alternate between different meta scopes.

- `meta.class` - Complete class definitions
- `meta.struct` - Complete struct definitions
- `meta.enum` - Complete enum definitions
- `meta.union` - Complete union definitions
- `meta.trait` - Complete trait definitions
- `meta.interface` - Complete interface definitions
- `meta.impl` - Complete implementation definitions
- `meta.type` - Complete type definitions
- `meta.function` - Complete function definitions
  - `parameters` - Parameter lists
  - `return-type` - Return type annotations
- `meta.namespace` - Namespace/module definitions
- `meta.preprocessor` - Preprocessor statements
- `meta.annotation` - Annotations/decorators
  - `identifier` - Annotation names
  - `parameters` - Annotation parameters
- `meta.path` - Qualified identifiers
- `meta.function-call` - Function invocations
- `meta.block` - Code blocks `{}`
- `meta.braces` - Alternative for curly braces
- `meta.group` - Grouped expressions `()`
- `meta.parens` - Alternative for parentheses
- `meta.brackets` - Bracket expressions `[]`
- `meta.generic` - Generic type parameters `<>`
- `meta.tag` - Complete HTML/XML tags
- `meta.paragraph` - Paragraphs in markup
- `meta.string` - Complete string literals
- `meta.interpolation` - String interpolation
- `meta.toc-list` - Table of contents entries

### `punctuation`

Structural and syntactic punctuation. Use specific subtypes for precise editor behavior.

- `punctuation.separator` - Commas, colons
  - `continuation` - Line continuation characters
- `punctuation.terminator` - Semicolons, statement terminators
- `punctuation.accessor` - Member access (`.`, `->`, `::`)
- `punctuation.definition` - Punctuation that defines other scopes
  - `comment` - Comment delimiters
  - `string.begin` / `string.end` - String quotes
  - `keyword` - Keyword punctuation
  - `variable` - Variable symbols (`$` in PHP)
  - `annotation` - Annotation symbols
  - `generic.begin` / `generic.end` - Generic delimiters `<>`
- `punctuation.section` - Section delimiters
  - `block.begin` / `block.end` - Block delimiters `{}`
  - `group.begin` / `group.end` - Group delimiters `()`
  - `parens.begin` / `parens.end` - Alternative for parentheses
  - `brackets.begin` / `brackets.end` - Bracket delimiters `[]`
  - `braces.begin` / `braces.end` - Alternative for curly braces
  - `interpolation.begin` / `interpolation.end` - Interpolation delimiters

### `source` and `text`

Root scopes for different document types:
- `source` - Programming languages and executable code
- `text` - Content and markup (disables many code features)
  - `text.html` - HTML documents (variants like `text.html.markdown`)
  - `text.xml` - XML documents

### `storage`

Keywords affecting how variables, functions, or data structures are stored or accessed.

- `storage.type` - Type keywords (`int`, `bool`, `char`)
  - `function` - Function keywords (`def`, `function`) + `keyword.declaration.function`
  - `class` - Class keywords (`class`) + `keyword.declaration.class`
  - `struct` - Struct keywords + `keyword.declaration.struct`
  - `enum` - Enum keywords + `keyword.declaration.enum`
  - `union` - Union keywords + `keyword.declaration.union`
  - `trait` - Trait keywords + `keyword.declaration.trait`
  - `interface` - Interface keywords + `keyword.declaration.interface`
  - `impl` - Implementation keywords + `keyword.declaration.impl`
- `storage.modifier` - Storage modifiers (`static`, `const`, `public`, `private`)

**Note:** Declaration keywords should use both `storage.type.*` and `keyword.declaration.*` for backward compatibility.

### `string`

String literals and related constructs. Use `meta.string` for entire strings including punctuation.

- `string.quoted.single` - Single-quoted strings
- `string.quoted.double` - Double-quoted strings
- `string.quoted.triple` - Triple-quoted strings
- `string.quoted.other` - Other quoting styles
- `string.unquoted` - Unquoted strings (`shell`, `batch`)
- `string.regexp` - Regular expression literals

**String interpolation pattern:**
```
meta.string
  punctuation.definition.string.begin
  meta.interpolation
    punctuation.section.interpolation.begin
    source.language.embedded
    punctuation.section.interpolation.end
  punctuation.definition.string.end
```

When strings contain interpolated code, remove the `string.*` scope using `clear_scopes:` and apply `meta.interpolation` to the entire interpolation including punctuation.

### `support`

Elements provided by frameworks, libraries, and language runtimes (as opposed to user-defined elements).

- `support.function` - Library functions (`console.log`, `NSLog`)
- `support.class` - Library classes
- `support.type` - Library types
- `support.constant` - Library constants
- `support.module` - Library modules
- `support.variable` - Library variables

Many syntaxes also apply these to unrecognized user constructs, effectively scoping all user-defined elements.

### `variable`

Variable names and identifiers representing mutable data.

- `variable.other` - Generic variables
  - `readwrite` - Mutable variables
  - `constant` - Immutable variables
  - `member` - Object properties/fields
- `variable.language` - Language-reserved variables (`this`, `self`, `super`)
- `variable.parameter` - Function parameters
- `variable.function` - Function names (when called, not defined)
- `variable.annotation` - Annotation identifiers

Apply `punctuation.definition.variable` to variable prefixes like `$` in PHP.

## Color Scheme Guidelines

### Essential Scopes for Themes

Target these scopes for broad compatibility:

- `entity.name` (with overrides for `entity.name.tag` and `entity.name.section`)
- `entity.other.inherited-class`
- `variable` (with specific variants)
- `constant` (with specific variants)
- `storage.type` and `storage.modifier`
- `support`
- `keyword` (with specific variants)
- `string`
- `comment`
- `invalid`

### Best Practices

- Style general scopes first, then override specific ones
- Avoid styling `meta` scopes - they're for structural information
- Use scope inheritance - specific scopes inherit from general ones

## Common Decision Points

**Definition vs Usage:**
- Function definition: `entity.name.function`
- Function call: `variable.function`

**Constants vs Variables:**
- Named constants: `entity.name.constant` (appears in symbol list)
- Immutable variables: `variable.other.constant` (doesn't appear in symbol list)

**Framework vs User Code:**
- Library functions: `support.function`
- User-defined functions: `entity.name.function`

This guide covers the semantic foundation for creating consistent tmLanguage files that work well with existing themes and editor features. 

---

## docs/troubleshooting.md

# Troubleshooting Guide

Common issues and solutions when working with the TextMate Toolkit.

## Build and Compilation Issues

### TypeScript Compilation Errors

**Problem**: TypeScript compilation fails when importing the toolkit

**Solution**: Ensure you have compatible TypeScript settings

```json
// tsconfig.json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "node",
    "allowSyntheticDefaultImports": true,
    "esModuleInterop": true,
    "strict": true
  }
}
```

**Problem**: Cannot find module declarations

**Solution**: Install type dependencies
```bash
npm install --save-dev @types/node
```

### Import/Export Issues

**Problem**: `Cannot find module 'tmgrammar-toolkit/testing'`

**Solution**: Check your import paths and ensure submodule exports are correct
```typescript
// ‚úÖ Correct
import { createTesterFromFile } from 'tmgrammar-toolkit/testing';
import { scopes } from 'tmgrammar-toolkit';

// ‚ùå Incorrect  
import { createTesterFromFile } from 'tmgrammar-toolkit/src/testing';
```

## Grammar Definition Issues

### Regex Pattern Problems

**Problem**: Regex patterns not matching expected text

**Common Causes & Solutions**:

1. **Escaping Issues**
   ```typescript
   // ‚ùå Wrong - not enough escaping
   match: "\b(function)\b"
   
   // ‚úÖ Right - proper escaping
   match: "\\b(function)\\b"
   
   // ‚úÖ Best - use helpers
   match: regex.bounded('function')
   ```

2. **Case Sensitivity**
   ```typescript
   // ‚ùå Won't match "Function" or "FUNCTION"
   match: /function/
   
   // ‚úÖ Case insensitive
   match: /function/i
   
   // ‚úÖ Using helpers
   match: regex.caseInsensitive('function')
   ```

3. **Anchoring Issues**
   ```typescript
   // ‚ùå Matches anywhere in string
   match: /if/
   
   // ‚úÖ Word boundaries
   match: /\bif\b/
   
   // ‚úÖ Using helpers
   match: regex.keywords(['if'])
   ```

**Problem**: Oniguruma regex validation fails

**Solution**: Use the validation API to debug patterns
```typescript
import { validateRegex } from 'tmgrammar-toolkit/validation';

const result = await validateRegex('\\b(if|else)\\b');
if (!result.valid) {
  console.error(`Invalid regex: ${result.error}`);
  // Common fixes:
  // - Check escape sequences
  // - Verify character classes
  // - Test lookbehind/lookahead syntax
}
```

### Repository Key Conflicts

**Problem**: `Error: Duplicate repository key 'string'`

**Solution**: Ensure all rule keys are unique across your grammar
```typescript
// ‚ùå Duplicate keys
const singleQuotedString = { key: 'string', /* ... */ };
const doubleQuotedString = { key: 'string', /* ... */ };

// ‚úÖ Unique keys
const singleQuotedString = { key: 'string-single', /* ... */ };
const doubleQuotedString = { key: 'string-double', /* ... */ };
```

### Scope Naming Issues

**Problem**: Editor not applying correct highlighting

**Common Causes**:

1. **Typos in scope names**
   ```typescript
   // ‚ùå Typo in scope name
   scope: 'keyword.controll.conditional'
   
   // ‚úÖ Use scopes API to prevent typos
   scope: scopes.keyword.control.conditional
   ```

2. **Non-standard scope names**
   ```typescript
   // ‚ùå Non-standard scope
   scope: 'my.custom.scope'
   
   // ‚úÖ Standard TextMate scope
   scope: scopes.keyword.control
   ```

3. **Missing language suffix**
   ```typescript
   // ‚ùå Generic scope (might conflict)
   scope: 'keyword.control'
   
   // ‚úÖ Language-specific scope with scopesFor
   const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });
   scope: scopes.keyword.control
   ```

### Scope Issues

If your scopes aren't being highlighted correctly:

```typescript
// ‚ùå Typo in scope name
scope: scopes.keyword.control

// ‚úÖ Use proper scope hierarchy
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });
scope: scopes.keyword.control
```

## Pattern Matching Issues

### Patterns Not Matching

**Problem**: Your patterns aren't matching the expected code

**Debugging Steps**:

1. **Test patterns in isolation**
   ```typescript
   import { validateRegex } from 'tmgrammar-toolkit/validation';
   
   const pattern = /\b(if|else|while)\b/;
   const testString = 'if (condition)';
   
   console.log(pattern.test(testString)); // Should be true
   ```

2. **Use the testing API to debug**
   ```typescript
   import { createTesterFromContent } from 'tmgrammar-toolkit/testing';
   
   const tester = createTesterFromContent(myGrammar, 'source.mylang');
   const tokens = await tester.tokenize('if (condition)');
   
   // Print all tokens to see what's being matched
   tokens.forEach((token, i) => {
     console.log(`Token ${i}: "${token.content}" -> ${token.scope.join('.')}`);
   });
   ```

### Pattern Order Issues

**Problem**: Wrong patterns are matching first

**Solution**: Order patterns from most specific to most general
```typescript
// ‚ùå General pattern matches before specific one
patterns: [
  { key: 'keyword', match: /\w+/, scope: 'keyword' },
  { key: 'function-keyword', match: /function/, scope: 'keyword.declaration' }
]

// ‚úÖ Specific pattern first
patterns: [
  { key: 'function-keyword', match: /function/, scope: 'keyword.declaration' },
  { key: 'keyword', match: /\w+/, scope: 'keyword' }
]
```

### Performance Issues

**Problem**: Grammar causes slow syntax highlighting

**Common Causes & Solutions**:

1. **Expensive regex patterns**
   ```typescript
   // ‚ùå Catastrophic backtracking
   match: /(a+)+b/
   
   // ‚úÖ Atomic grouping
   match: /(?>a+)+b/
   ```

2. **Excessive lookahead/lookbehind**
   ```typescript
   // ‚ùå Expensive
   match: /(?<=\w)\.(?=\w)/
   
   // ‚úÖ Simpler alternative
   match: /\w\.\w/
   ```

3. **Too many patterns**
   ```typescript
   // ‚ùå Many individual rules
   patterns: [
     { key: 'if', match: /if/, scope: 'keyword' },
     { key: 'else', match: /else/, scope: 'keyword' },
     // ... 50 more
   ]
   
   // ‚úÖ Combined rule
   patterns: [
     { 
       key: 'keywords', 
       match: regex.keywords(['if', 'else', /* ... */]), 
       scope: 'keyword' 
     }
   ]
   ```

## Testing Issues

### Test Failures

**Problem**: `expectTokenScope` assertions fail

**Debugging Steps**:

1. **Check actual token scopes**
   ```typescript
   const tokens = await tester.tokenize('if (condition)');
   const ifToken = tokens.find(t => t.content === 'if');
   console.log('Actual scopes:', ifToken?.scope);
   console.log('Expected:', 'keyword.control.mylang');
   ```

2. **Verify token content**
   ```typescript
   // Make sure you're checking the right token content
   tester.expectTokenScope(tokens, 'if', 'keyword.control.mylang');
   // Not: tester.expectTokenScope(tokens, 'IF', '...');
   ```

3. **Check scope hierarchy**
   ```typescript
   // Token might have multiple scopes
   // ['source.mylang', 'keyword.control.mylang']
   // Test for the most specific one
   ```

### Snapshot Test Issues

**Problem**: Snapshot tests always failing

**Solution**: Update snapshots when grammar changes are intentional
```bash
# Update all snapshots
npx tmt snap 'tests/**/*.mylang' --update

# Update specific test
npx tmt snap 'tests/keywords.test.mylang' --update
```

## CLI Debugging

### Command Issues

**Problem**: A CLI command is not behaving as expected.

**Solutions**:

1.  **Isolate the Command**: Since each command is a module, you can test it in isolation. Look in `src/cli/commands` to find the relevant command file.
2.  **Check Argument Parsing**: Ensure that the arguments and options you are passing on the command line are correctly defined and parsed in the command's file. The `commander` package handles this, so check the `.argument()` and `.option()` calls.
3.  **Verify Utility Functions**: Many commands use helpers from `src/cli/utils`. Check these functions (`loadGrammarFromFile`, etc.) to see if the issue lies there.
4.  **Run with Verbosity**: Add `console.log` statements within the command's action to trace its execution and inspect the values of variables.

### File Path Issues

**Problem**: `Cannot find file 'grammar.ts'`

**Solutions**:

1.  **Check Working Directory**: Make sure you are running the `tmt` command from the root of your project.
    ```bash
    pwd
    ls -la grammar.ts
    ```
2.  **Use Relative or Absolute Paths**: The CLI should handle both, but if you're having trouble, try providing a full path to the file.
3.  **Check File Extensions**: Ensure you're including the correct file extension (`.ts`, `.js`, etc.) in the command.

## Editor Integration Issues

### VS Code Not Recognizing Grammar

**Problem**: VS Code doesn't use your grammar for syntax highlighting

**Solutions**:

1. **Check file association**
   ```json
   // In your extension's package.json
   {
     "contributes": {
       "languages": [{
         "id": "mylang",
         "extensions": [".mylang", ".ml"],
         "configuration": "./language-configuration.json"
       }],
       "grammars": [{
         "language": "mylang",
         "scopeName": "source.mylang",
         "path": "./syntaxes/mylang.tmLanguage.json"
       }]
     }
   }
   ```

2. **Verify scope name matches**
   ```typescript
   // In your grammar
   const grammar = createGrammar('MyLang', 'source.mylang', ['mylang']);
   
   // Must match the scopeName in package.json
   ```

3. **Reload VS Code**
   - Press `Ctrl+Shift+P` (or `Cmd+Shift+P`)
   - Type "Developer: Reload Window"

### Incorrect Highlighting

**Problem**: Some tokens have wrong colors

**Debugging Steps**:

1. **Check scope inspector**
   - Press `Ctrl+Shift+P`
   - Type "Developer: Inspect Editor Tokens and Scopes"
   - Click on problematic tokens

2. **Verify theme support**
   ```typescript
   // Some themes might not support all scopes
   // Use common scopes for better compatibility
   scope: scopes.keyword.control  // Well-supported
   // vs
   scope: scopes.keyword.control.loop.for  // Might not be themed
   ```

## Common Error Messages

### "Invalid regular expression"

**Cause**: Regex syntax error
**Solution**: Use regex validation
```typescript
import { validateRegex } from 'tmgrammar-toolkit/validation';
const result = await validateRegex(yourPattern);
```

### "Cannot resolve include"

**Cause**: Including non-existent repository key
**Solution**: Check repository key names
```typescript
// ‚ùå Key doesn't exist
{ include: '#non-existent-key' }

// ‚úÖ Valid repository key
{ include: '#existing-pattern' }
```

### "Circular reference detected"

**Cause**: Patterns referencing each other in a loop
**Solution**: Restructure pattern hierarchy
```typescript
// ‚ùå Circular reference
const patternA = { key: 'a', patterns: [{ include: '#b' }] };
const patternB = { key: 'b', patterns: [{ include: '#a' }] };

// ‚úÖ Hierarchical structure
const patternA = { key: 'a', patterns: [patternB] };
const patternB = { key: 'b', match: /some-pattern/ };
```

## Getting Help

If you're still experiencing issues:

1. **Check the Examples**: Look at complete grammar implementations in `examples/`
2. **Read the API Reference**: Detailed documentation in `docs/api-reference.md`
3. **Use Validation Tools**: Run validation on your patterns and grammar
4. **Create Minimal Reproduction**: Isolate the problem to the smallest possible case
5. **Check GitHub Issues**: Search for similar issues in the repository

## Performance Optimization

### Profiling Your Grammar

```typescript
// Time tokenization performance
const start = performance.now();
const tokens = await tester.tokenize(largeCodeSample);
const time = performance.now() - start;
console.log(`Tokenized ${largeCodeSample.length} chars in ${time}ms`);
```

### Optimization Strategies

1. **Combine similar patterns**
2. **Use atomic groups for non-backtracking patterns**
3. **Avoid deep nesting of begin/end rules**
4. **Profile with realistic code samples**
5. **Use character classes instead of alternation when possible**

Remember: Most issues stem from regex patterns, scope naming, or pattern ordering. The validation and testing APIs are your best tools for debugging! üîß 

---

## docs/using-scopes.md

# Using Scopes in TMGrammar Toolkit

The TMGrammar Toolkit provides a powerful, type-safe scope system for creating TextMate grammars. This guide covers all the ways you can use scopes in your projects.

## Quick Start

The most common pattern is to create static scopes with a language suffix:

```typescript
import { scopesFor } from 'tmgrammar-toolkit';

// Create static scopes for your language (recommended)
const myScopes = scopesFor({ 
  suffix: 'mylang', 
  allowScopeExtension: false 
});

// Use in your grammar rules
const keywordRule = {
  name: myScopes.keyword.control.conditional,  // "keyword.control.conditional.mylang"
  match: /\b(if|else|for|while)\b/
};
```

## Scope Patterns

### 1. Static Scopes (Recommended)

Static scopes provide the best performance and are recommended for production grammars:

```typescript
const staticScopes = scopesFor({ 
  suffix: 'typescript', 
  allowScopeExtension: false 
});

// These return string values directly
console.log(staticScopes.keyword.control.conditional); // "keyword.control.conditional.typescript"
console.log(staticScopes.string.quoted.double); // "string.quoted.double.typescript"

// Perfect for template literals
const rule = `${staticScopes.comment.line.double_slash}`; // "comment.line.double-slash.typescript"

// Not callable (optimized for performance)
// staticScopes.keyword.control.conditional('extra'); // ‚ùå TypeError
```

**Benefits:**
- Best performance (no function call overhead)
- Smaller bundle size
- Easier for bundlers to optimize
- Clear, predictable behavior

### 2. Callable Scopes

Callable scopes allow dynamic extension with additional suffixes:

```typescript
const callableScopes = scopesFor({ 
  suffix: 'javascript', 
  allowScopeExtension: true 
});

// Base usage
console.log(callableScopes.keyword.control.conditional); // "keyword.control.conditional.javascript"

// Dynamic extension
console.log(callableScopes.keyword.control.conditional('async')); // "keyword.control.conditional.javascript.async"
console.log(callableScopes.string.quoted.double('template')); // "string.quoted.double.javascript.template"
```

**Use cases:**
- Grammar extensions or plugins
- Development and testing
- When you need runtime flexibility

### 3. On-Leafs Extension Mode

Only leaf nodes (terminal scopes) are callable, branch nodes are static:

```typescript
const leafScopes = scopesFor({ 
  suffix: 'python', 
  allowScopeExtension: 'on-leafs' 
});

// Leaf nodes are callable
console.log(leafScopes.keyword.control.conditional('comprehension')); // "keyword.control.conditional.python.comprehension"

// Branch nodes are not callable
console.log(leafScopes.keyword.control); // "keyword.control.python" (not callable)
// leafScopes.keyword.control('extra'); // ‚ùå TypeError
```

**Benefits:**
- Balance between performance and flexibility
- Prevents accidental extension of intermediate scopes
- Clear distinction between terminal and intermediate scopes

## Custom Scope Definitions

You can extend the base TextMate scopes with your own custom definitions:

```typescript
const customScopes = scopesFor({ 
  suffix: 'rcl', 
  allowScopeExtension: false 
}, {
  // Custom meta scopes for your language
  meta: {
    section: {
      agent: null,
      messages: null,
      flows: null
    },
    embedded: {
      expression: null,
      code: null
    }
  },
  // Custom source scopes
  source: {
    rcl: {
      import: null,
      section_header: null
    }
  }
});

// Use custom scopes
console.log(customScopes.meta.section.agent); // "meta.section.agent.rcl"
console.log(customScopes.source.rcl.import); // "source.rcl.import.rcl"

// Base scopes are still available
console.log(customScopes.keyword.control.conditional); // "keyword.control.conditional.rcl"
```

## Advanced Configuration

### Prefix for Embedded Languages

Use prefixes when creating scopes for embedded languages:

```typescript
const embeddedScopes = scopesFor({ 
  prefix: 'source.html.embedded',
  suffix: 'javascript',
  allowScopeExtension: false 
});

console.log(embeddedScopes.keyword.control.conditional); 
// "source.html.embedded.keyword.control.conditional.javascript"
```

### No Suffix (Base Scopes)

Create scopes without language suffixes:

```typescript
const baseScopes = scopesFor({ 
  allowScopeExtension: false 
});

console.log(baseScopes.keyword.control.conditional); // "keyword.control.conditional"
```

## Predefined Scopes

The toolkit provides predefined scopes that are always callable:

```typescript
import { scopes } from 'tmgrammar-toolkit';

// Global scopes (always callable)
console.log(scopes.keyword.control.conditional); // "keyword.control.conditional"
console.log(scopes.keyword.control.conditional('js')); // "keyword.control.conditional.js"

// Snake_case to kebab-case conversion
console.log(scopes.comment.line.double_slash); // "comment.line.double-slash"
console.log(scopes.entity.name.class.forward_decl); // "entity.name.class.forward-decl"
```

## Type Safety Features

The scope system provides full TypeScript support:

### Compile-time Type Checking

```typescript
const myScopes = scopesFor({ suffix: 'lang', allowScopeExtension: false });

// ‚úÖ Valid scope paths
myScopes.keyword.control.conditional;
myScopes.string.quoted.double;
myScopes.comment.line.double_slash;

// ‚ùå Invalid scope paths (TypeScript errors)
// myScopes.invalid.path.here;
// myScopes.keyword.invalid.property;
```

### Autocomplete and IntelliSense

Your editor will provide full autocomplete for all scope properties:

- `myScopes.keyword.` ‚Üí shows `control`, `operator`, `other`
- `myScopes.keyword.control.` ‚Üí shows `conditional`, `exception`, `flow`, etc.
- `myScopes.string.quoted.` ‚Üí shows `single`, `double`, `triple`

### Hover Documentation

Hover over any scope to see its full path and type information.

## Best Practices

### 1. Prefer Static Scopes

Use static scopes unless you specifically need dynamic extension:

```typescript
// ‚úÖ Recommended for production
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });

// ‚ö†Ô∏è Only when needed
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: true });
```

### 2. Use Descriptive Suffixes

Choose clear, standard language identifiers:

```typescript
// ‚úÖ Good
scopesFor({ suffix: 'typescript' })
scopesFor({ suffix: 'python' })
scopesFor({ suffix: 'rust' })

// ‚ùå Avoid
scopesFor({ suffix: 'ts' })
scopesFor({ suffix: 'py' })
scopesFor({ suffix: 'rs' })
```

### 3. Organize Custom Scopes Logically

Group related custom scopes under appropriate categories:

```typescript
const scopes = scopesFor({ suffix: 'mylang' }, {
  meta: {
    // Language structure scopes
    section: { header: null, body: null },
    block: { begin: null, end: null }
  },
  entity: {
    // Custom entity types
    name: { 
      custom_type: null,
      special_identifier: null 
    }
  }
});
```

### 4. Follow TextMate Naming Conventions

Stick to established TextMate scope naming patterns:

- `keyword.control.*` for control flow keywords
- `string.quoted.*` for string literals
- `comment.line.*` for line comments
- `entity.name.*` for identifiers and names
- `constant.numeric.*` for numeric literals

See the [TextMate scope naming conventions](https://macromates.com/manual/en/language_grammars#naming_conventions) for complete guidelines.

## Performance Considerations

### Static vs Callable Scopes

| Pattern | Performance | Flexibility | Use Case |
|---------|-------------|-------------|----------|
| Static (`false`) | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê | Production grammars |
| On-leafs (`"on-leafs"`) | ‚≠ê‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê | Balanced approach |
| Callable (`true`) | ‚≠ê‚≠ê‚≠ê | ‚≠ê‚≠ê‚≠ê‚≠ê‚≠ê | Development/extensible |

### Bundle Size Impact

Static scopes result in smaller bundles because:
- No function objects are created
- Better tree-shaking opportunities
- Simpler object structures

## Migration Guide

If you're updating from an older version:

### Old Pattern
```typescript
// Old complex API
const scopes = scopesFor('mylang');
const customScopes = scopesFor({ suffix: 'mylang' }, { custom: { token: null } });
```

### New Pattern
```typescript
// New simplified API
const scopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false });
const customScopes = scopesFor({ suffix: 'mylang', allowScopeExtension: false }, { 
  custom: { token: null } 
});
```

The new API is more explicit about extension behavior and provides better performance defaults.

## Examples

Check out these complete examples:

- [Simple Example](../examples/simple-example.ts) - Basic static scopes usage
- [Features Demo](../examples/scope-features-demo.ts) - Comprehensive feature showcase
- [Bicep Language](../examples/tmgrammar-toolkit/bicep.ts) - Real-world language example
- [TypeSpec Language](../examples/tmgrammar-toolkit/typespec.ts) - Another real-world example

## Further Reading

- [TMGrammar Toolkit API Reference](./api-reference.md)
- [TextMate Language Grammars](https://macromates.com/manual/en/language_grammars)
- [VSCode Syntax Highlighting Guide](https://code.visualstudio.com/api/language-extensions/syntax-highlight-guide) 

---

